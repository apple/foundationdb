<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>C API &#8212; FoundationDB ON documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-sphinx.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Error Codes" href="api-error-codes.html" />
    <link rel="prev" title="Ruby API" href="api-ruby.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          FoundationDB</a>
        <span class="navbar-text navbar-version pull-left"><b>7.4.3</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="contents.html">Site Map</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">C API</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#linking">Linking</a><ul>
<li><a class="reference internal" href="#linux">Linux</a></li>
<li><a class="reference internal" href="#macos">macOS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api-versioning">API versioning</a></li>
<li><a class="reference internal" href="#network">Network</a></li>
<li><a class="reference internal" href="#future">Future</a></li>
<li><a class="reference internal" href="#database">Database</a></li>
<li><a class="reference internal" href="#tenant">Tenant</a></li>
<li><a class="reference internal" href="#transaction">Transaction</a><ul>
<li><a class="reference internal" href="#snapshot-reads">Snapshot reads</a></li>
</ul>
</li>
<li><a class="reference internal" href="#key-selectors">Key selectors</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="api-ruby.html" title="Previous Chapter: Ruby API"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Ruby API</span>
    </a>
  </li>
  <li>
    <a href="api-error-codes.html" title="Next Chapter: Error Codes"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Error Codes &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">C API</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#linking">Linking</a><ul>
<li><a class="reference internal" href="#linux">Linux</a></li>
<li><a class="reference internal" href="#macos">macOS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api-versioning">API versioning</a></li>
<li><a class="reference internal" href="#network">Network</a></li>
<li><a class="reference internal" href="#future">Future</a></li>
<li><a class="reference internal" href="#database">Database</a></li>
<li><a class="reference internal" href="#tenant">Tenant</a></li>
<li><a class="reference internal" href="#transaction">Transaction</a><ul>
<li><a class="reference internal" href="#snapshot-reads">Snapshot reads</a></li>
</ul>
</li>
<li><a class="reference internal" href="#key-selectors">Key selectors</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <section id="c-api">
<h1>C API</h1>
<p>This API provides a very low-level interface to FoundationDB. It is primarily intended for use in implementing higher level APIs, rather than for direct use. If you are new to FoundationDB, you are probably better served by reading one of the other APIs first.</p>
<section id="installation">
<h2>Installation</h2>
<p>FoundationDB’s C bindings are installed with the FoundationDB client binaries (see <a class="reference internal" href="api-general.html#installing-client-binaries"><span class="std std-ref">Installing FoundationDB client binaries</span></a>).</p>
<dl>
<dt>On Linux,</dt><dd><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">fdb_c.h</span></code>, <code class="docutils literal notranslate"><span class="pre">fdb_c_types.h</span></code>, <code class="docutils literal notranslate"><span class="pre">fdb_c_internal.h</span></code>, <code class="docutils literal notranslate"><span class="pre">fdb_c_options.g.h</span></code>, <code class="docutils literal notranslate"><span class="pre">fdb.options</span></code> and <code class="docutils literal notranslate"><span class="pre">fdb_c_shim.h</span></code> are installed into <code class="docutils literal notranslate"><span class="pre">/usr/include/foundationdb/</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">libfdb_c.so</span></code> and <code class="docutils literal notranslate"><span class="pre">libfdb_c_shim.so</span></code> is installed into <code class="docutils literal notranslate"><span class="pre">/usr/lib/</span></code> with the <code class="docutils literal notranslate"><span class="pre">deb</span></code> package and into  <code class="docutils literal notranslate"><span class="pre">/usr/lib64/</span></code> with the <code class="docutils literal notranslate"><span class="pre">rpm</span></code> package</div>
</div>
</dd>
<dt>On macOS,</dt><dd><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">fdb_c.h</span></code>, <code class="docutils literal notranslate"><span class="pre">fdb_c_types.h</span></code>, <code class="docutils literal notranslate"><span class="pre">fdb_c_internal.h</span></code>, <code class="docutils literal notranslate"><span class="pre">fdb_c_options.g.h</span></code>, <code class="docutils literal notranslate"><span class="pre">fdb.options</span></code> and <code class="docutils literal notranslate"><span class="pre">fdb_c_shim.h</span></code> are installed into <code class="docutils literal notranslate"><span class="pre">/usr/local/include/foundationdb/</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">libfdb_c.dylib</span></code> is installed into <code class="docutils literal notranslate"><span class="pre">/usr/local/lib/</span></code></div>
</div>
</dd>
</dl>
</section>
<section id="linking">
<h2>Linking</h2>
<p>The FoundationDB C bindings are provided as a shared object which may be linked against at build time, or dynamically loaded at runtime. Any program that uses this API must be able to find a platform-appropriate shared library at runtime. Generally, this condition is best met by installing the FoundationDB client binaries (see <a class="reference internal" href="api-general.html#installing-client-binaries"><span class="std std-ref">Installing FoundationDB client binaries</span></a>) on any machine where the program will be run.</p>
<section id="linux">
<h3>Linux</h3>
<p>When linking against <code class="docutils literal notranslate"><span class="pre">libfdb_c.so</span></code>, you must also link against <code class="docutils literal notranslate"><span class="pre">libm</span></code>, <code class="docutils literal notranslate"><span class="pre">libpthread</span></code> and <code class="docutils literal notranslate"><span class="pre">librt</span></code>. These dependencies will be resolved by the dynamic linker when using this API via <code class="docutils literal notranslate"><span class="pre">dlopen()</span></code> or an FFI.</p>
</section>
<section id="macos">
<h3>macOS</h3>
<p>When linking against <code class="docutils literal notranslate"><span class="pre">libfdb_c.dylib</span></code>, no additional libraries are required.</p>
</section>
</section>
<section id="api-versioning">
<h2>API versioning</h2>
<p>Prior to including <code class="docutils literal notranslate"><span class="pre">fdb_c.h</span></code>, you must define the <code class="docutils literal notranslate"><span class="pre">FDB_API_VERSION</span></code> macro. This, together with the <a class="reference internal" href="#c.fdb_select_api_version" title="fdb_select_api_version"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_select_api_version()</span></code></a> function, allows programs written against an older version of the API to compile and run with newer versions of the C library. The current version of the FoundationDB C API is 740.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define FDB_API_VERSION 740</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;foundationdb/fdb_c.h&gt;</span>
</pre></div>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_select_api_version">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_select_api_version</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">version</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Must be called before any other API functions. <code class="docutils literal notranslate"><span class="pre">version</span></code> must be less than or equal to <code class="docutils literal notranslate"><span class="pre">FDB_API_VERSION</span></code> (and should almost always be equal).</p>
<p>Language bindings implemented in C which themselves expose API versioning will usually pass the version requested by the application, instead of always passing <code class="docutils literal notranslate"><span class="pre">FDB_API_VERSION</span></code>.</p>
<p>Passing a version less than <code class="docutils literal notranslate"><span class="pre">FDB_API_VERSION</span></code> will cause the API to behave as it did in the older version.</p>
<p>It is an error to call this function after it has returned successfully. It is not thread safe, and if called from more than one thread simultaneously its behavior is undefined.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is actually implemented as a macro. If you are accessing this API via <code class="docutils literal notranslate"><span class="pre">dlopen()</span></code> or an FFI, you will need to use <a class="reference internal" href="#c.fdb_select_api_version_impl" title="fdb_select_api_version_impl"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_select_api_version_impl()</span></code></a>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When using the <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">multi-version client API</span></a>, setting an API version that is not supported by a particular client library will prevent that client from being used to connect to the cluster. In particular, you should not advance the API version of your application after upgrading your client until the cluster has also been upgraded.</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_select_api_version_impl">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_select_api_version_impl</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">runtime_version</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">header_version</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>This is the actual entry point called by the <a class="reference internal" href="#c.fdb_select_api_version" title="fdb_select_api_version"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_select_api_version()</span></code></a> macro. It should never be called directly from C, but if you are accessing this API via <code class="docutils literal notranslate"><span class="pre">dlopen()</span></code> or an FFI, you will need to use it. <code class="docutils literal notranslate"><span class="pre">fdb_select_api_version(v)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">fdb_select_api_version_impl(v,</span> <span class="pre">FDB_API_VERSION)</span></code>.</p>
<p>It is an error to call this function after it has returned successfully. It is not thread safe, and if called from more than one thread simultaneously its behavior is undefined.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">runtime_version</span></code></dt><dd><p>The version of run-time behavior the API is requested to provide. Must be less than or equal to <code class="docutils literal notranslate"><span class="pre">header_version</span></code>, and should almost always be equal.</p>
<p>Language bindings which themselves expose API versioning will usually pass the version requested by the application.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header_version</span></code></dt><dd><p>The version of the ABI (application binary interface) that the calling code expects to find in the shared library. If you are using an FFI, this <em>must</em> correspond to the version of the API you are using as a reference (currently 740). For example, the number of arguments that a function takes may be affected by this value, and an incorrect value is unlikely to yield success.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When using the <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">multi-version client API</span></a>, setting an API version that is not supported by a particular client library will prevent that client from being used to connect to the cluster. In particular, you should not advance the API version of your application after upgrading your client until the cluster has also been upgraded.</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_get_max_api_version">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_get_max_api_version</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">FDB_API_VERSION</span></code>, the current version of the FoundationDB C API.  This is the maximum version that may be passed to <a class="reference internal" href="#c.fdb_select_api_version" title="fdb_select_api_version"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_select_api_version()</span></code></a>.</p>
</dd></dl>

</section>
<section id="network">
<h2>Network</h2>
<p>The FoundationDB client library performs most tasks on a singleton thread (which usually will be a different thread than your application runs on). These functions are used to configure, start and stop the FoundationDB event loop on this thread.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_network_set_option">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_network_set_option</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBNetworkOption" title="FDBNetworkOption"><span class="n"><span class="pre">FDBNetworkOption</span></span></a><span class="w"> </span><span class="n"><span class="pre">option</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">value_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Called to set network options. If the given option is documented as taking a parameter, you must also pass a pointer to the parameter value and the parameter value’s length. If the option is documented as taking an <code class="docutils literal notranslate"><span class="pre">Int</span></code> parameter, <code class="docutils literal notranslate"><span class="pre">value</span></code> must point to a signed 64-bit integer (little-endian), and <code class="docutils literal notranslate"><span class="pre">value_length</span></code> must be 8. This memory only needs to be valid until <a class="reference internal" href="#c.fdb_network_set_option" title="fdb_network_set_option"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_network_set_option()</span></code></a> returns.</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.FDBNetworkOption">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBNetworkOption</span></span></span><br /></dt>
<dd><p>Please see <code class="docutils literal notranslate"><span class="pre">fdb_c_options.g.h</span></code> for a definition of this type, along with documentation of its allowed values.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_setup_network">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_setup_network</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Must be called after <a class="reference internal" href="#c.fdb_select_api_version" title="fdb_select_api_version"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_select_api_version()</span></code></a> (and zero or more calls to <a class="reference internal" href="#c.fdb_network_set_option" title="fdb_network_set_option"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_network_set_option()</span></code></a>) and before any other function in this API. <a class="reference internal" href="#c.fdb_setup_network" title="fdb_setup_network"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_setup_network()</span></code></a> can only be called once.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_add_network_thread_completion_hook">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_add_network_thread_completion_hook</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hook</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hook_parameter</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Must be called after <a class="reference internal" href="#c.fdb_setup_network" title="fdb_setup_network"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_setup_network()</span></code></a> and prior to <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_run_network()</span></code></a> if called at all. This will register the given callback to run at the completion of the network thread. If there are multiple network threads running (which might occur if one is running multiple versions of the client, for example), then the callback is invoked once on each thread. When the supplied function is called, the supplied parameter is passed to it.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_run_network">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_run_network</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Must be called after <a class="reference internal" href="#c.fdb_setup_network" title="fdb_setup_network"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_setup_network()</span></code></a> before any asynchronous functions in this API can be expected to complete. Unless your program is entirely event-driven based on results of asynchronous functions in this API and has no event loop of its own, you will want to invoke this function on an auxiliary thread (which it is your responsibility to create).</p>
<p>This function will not return until <a class="reference internal" href="#c.fdb_stop_network" title="fdb_stop_network"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_stop_network()</span></code></a> is called by you or a serious error occurs. It is not possible to run more than one network thread, and the network thread cannot be restarted once it has been stopped. This means that once <code class="docutils literal notranslate"><span class="pre">fdb_run_network</span></code> has been called, it is not legal to call it again for the lifetime of the running program.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_stop_network">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_stop_network</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Signals the event loop invoked by <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_run_network()</span></code></a> to terminate. You must call this function <strong>and wait for</strong> <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_run_network()</span></code></a> <strong>to return</strong> before allowing your program to exit, or else the behavior is undefined. For example, when running <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_run_network()</span></code></a> on a thread (using pthread), this will look like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pthread_t</span><span class="w"> </span><span class="n">network_thread</span><span class="p">;</span><span class="w"> </span><span class="cm">/* handle for thread which invoked fdb_run_network() */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdb_stop_network</span><span class="p">();</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* An error occurred (probably network not running) */</span>
<span class="p">}</span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pthread_join</span><span class="p">(</span><span class="w"> </span><span class="n">network_thread</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Unknown error */</span>
<span class="p">}</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>This function may be called from any thread. Once the network is stopped it cannot be restarted during the lifetime of the running program.</p>
</dd></dl>

</section>
<section id="future">
<h2>Future</h2>
<p>Most functions in the FoundationDB API are asynchronous, meaning that they may return to the caller before actually delivering their result. These functions always return <code class="docutils literal notranslate"><span class="pre">FDBFuture*</span></code>. An <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> object represents a result value or error to be delivered at some future time. You can wait for a Future to be “ready” – to have a value or error delivered – by setting a callback function, or by blocking a thread, or by polling. Once a Future is ready, you can extract either an error code or a value of the appropriate type (the documentation for the original function will tell you which <code class="docutils literal notranslate"><span class="pre">fdb_future_get_()</span></code> function you should call).</p>
<p>To use the API in a synchronous way, you would typically do something like this for each asynchronous call:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Call an API that returns FDBFuture*, documented as returning type foo in the future</span>
<span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdb_something</span><span class="p">();</span>

<span class="c1">// Wait for the Future to be *ready*</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">fdb_future_block_until_ready</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Exceptional error (e.g. out of memory)</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdb_future_get_foo</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Use result</span>
<span class="w">    </span><span class="c1">// In some cases, you must be finished with result before calling</span>
<span class="w">    </span><span class="c1">// fdb_future_destroy() (see the documentation for the specific</span>
<span class="w">    </span><span class="c1">// fdb_future_get_*() method)</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Handle the error. If this is an error in a transaction, see</span>
<span class="w">    </span><span class="c1">// fdb_transaction_on_error()</span>
<span class="p">}</span>

<span class="n">fdb_future_destroy</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
<p>Futures make it easy to do multiple operations in parallel, by calling several asynchronous functions before waiting for any of the results. This can be important for reducing the latency of transactions.</p>
<p>See <a class="reference internal" href="developer-guide.html#developer-guide-programming-with-futures"><span class="std std-ref">Programming with futures</span></a> for further (language-independent) discussion.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.FDBFuture">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBFuture</span></span></span><br /></dt>
<dd><p>An opaque type that represents a Future in the FoundationDB C API.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_cancel">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_cancel</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Cancels an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> object and its associated asynchronous operation. If called before the future is ready, attempts to access its value will return an <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">operation_cancelled</span></a> error. Cancelling a future which is already ready has no effect. Note that even if a future is not ready, its associated asynchronous operation may have successfully completed and be unable to be cancelled.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_destroy</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Destroys an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> object. It must be called exactly once for each FDBFuture* returned by an API function. It may be called before or after the future is ready. It will also cancel the future (and its associated operation if the latter is still outstanding).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_block_until_ready">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_block_until_ready</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Blocks the calling thread until the given Future is ready. It will return success even if the Future is set to an error – you must call <a class="reference internal" href="#c.fdb_future_get_error" title="fdb_future_get_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_error()</span></code></a> to determine that. <a class="reference internal" href="#c.fdb_future_block_until_ready" title="fdb_future_block_until_ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_block_until_ready()</span></code></a> will return an error only in exceptional conditions (e.g. deadlock detected, out of memory or other operating system resources).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Never call this function from a callback passed to <a class="reference internal" href="#c.fdb_future_set_callback" title="fdb_future_set_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_set_callback()</span></code></a>. This may block the thread on which <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_run_network()</span></code></a> was invoked, resulting in a deadlock. In some cases the client can detect the deadlock and throw a <code class="docutils literal notranslate"><span class="pre">blocked_from_network_thread</span></code> error.</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_is_ready">
<a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_is_ready</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns non-zero if the Future is ready. A Future is ready if it has been set to a value or an error.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_set_callback">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_set_callback</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span>, <a class="reference internal" href="#c.FDBCallback" title="FDBCallback"><span class="n"><span class="pre">FDBCallback</span></span></a><span class="w"> </span><span class="n"><span class="pre">callback</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">callback_parameter</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Causes the <a class="reference internal" href="#c.FDBCallback" title="FDBCallback"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBCallback</span></code></a> function to be invoked as <code class="docutils literal notranslate"><span class="pre">callback(future,</span> <span class="pre">callback_parameter)</span></code> when the given Future is ready. If the Future is already ready, the call may occur in the current thread before this function returns (but this behavior is not guaranteed). Alternatively, the call may be delayed indefinitely and take place on the thread on which <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_run_network()</span></code></a> was invoked, and the callback is responsible for any necessary thread synchronization (and/or for posting work back to your application event loop, thread pool, etc. if your application’s architecture calls for that).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function guarantees the callback will be executed <strong>at most once</strong>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Never call <a class="reference internal" href="#c.fdb_future_block_until_ready" title="fdb_future_block_until_ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_block_until_ready()</span></code></a> from a callback passed to this function. This may block the thread on which <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_run_network()</span></code></a> was invoked, resulting in a deadlock.</p>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.FDBCallback">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBCallback</span></span></span><br /></dt>
<dd><p>A pointer to a function which takes <code class="docutils literal notranslate"><span class="pre">FDBFuture*</span></code> and <code class="docutils literal notranslate"><span class="pre">void*</span></code> and returns <code class="docutils literal notranslate"><span class="pre">void</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_release_memory">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_release_memory</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span><span class="sig-paren">)</span><br /></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function provides no benefit to most application code. It is designed for use in writing generic, thread-safe language bindings. Applications should normally call <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a> only.</p>
</div>
<p>This function may only be called after a successful (zero return value) call to <a class="reference internal" href="#c.fdb_future_get_key" title="fdb_future_get_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_key()</span></code></a>, <a class="reference internal" href="#c.fdb_future_get_value" title="fdb_future_get_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_value()</span></code></a>, or <a class="reference internal" href="#c.fdb_future_get_keyvalue_array" title="fdb_future_get_keyvalue_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_keyvalue_array()</span></code></a>. It indicates that the memory returned by the prior get call is no longer needed by the application. After this function has been called the same number of times as <code class="docutils literal notranslate"><span class="pre">fdb_future_get_*()</span></code>, further calls to <code class="docutils literal notranslate"><span class="pre">fdb_future_get_*()</span></code> will return a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">future_released</span></a> error. It is still necessary to later destroy the future with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>Calling this function is optional, since <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a> will also release the memory returned by get functions. However, <a class="reference internal" href="#c.fdb_future_release_memory" title="fdb_future_release_memory"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_release_memory()</span></code></a> leaves the future object itself intact and provides a specific error code which can be used for coordination by multiple threads racing to do something with the results of a specific future. This has proven helpful in writing binding code.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_get_error">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_get_error</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns zero if <code class="docutils literal notranslate"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_get_int64">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_get_int64</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span>, <span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Extracts a 64-bit integer from a pointer to <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> into a caller-provided variable of type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>. <code class="docutils literal notranslate"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal notranslate"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_get_double">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_get_double</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Extracts a double from a pointer to <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> into a caller-provided variable of type <code class="docutils literal notranslate"><span class="pre">double</span></code>. <code class="docutils literal notranslate"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal notranslate"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_get_key_array">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_get_key_array</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">FDBKey</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_key_array</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_count</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Extracts an array of <code class="xref c c-type docutils literal notranslate"><span class="pre">FDBKey</span></code> from an <code class="docutils literal notranslate"><span class="pre">FDBFuture*</span></code> into a caller-provided variable of type <code class="docutils literal notranslate"><span class="pre">FDBKey*</span></code>. The size of the array will also be extracted and passed back by a caller-provided variable of type <code class="docutils literal notranslate"><span class="pre">int</span></code> <code class="docutils literal notranslate"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal notranslate"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_get_key">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_get_key</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_key</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_key_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Extracts a key from an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> into caller-provided variables of type <code class="docutils literal notranslate"><span class="pre">uint8_t*</span></code> (a pointer to the beginning of the key) and <code class="docutils literal notranslate"><span class="pre">int</span></code> (the length of the key). <code class="docutils literal notranslate"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal notranslate"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
<p>The memory referenced by the result is owned by the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> object and will be valid until either <code class="docutils literal notranslate"><span class="pre">fdb_future_destroy(future)</span></code> or <code class="docutils literal notranslate"><span class="pre">fdb_future_release_memory(future)</span></code> is called.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_get_value">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_get_value</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_present</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_value</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_value_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Extracts a database value from an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> into caller-provided variables. <code class="docutils literal notranslate"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal notranslate"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">*out_present</span></code></dt><dd><p>Set to non-zero if (and only if) the requested value was present in the database. (If zero, the other outputs are meaningless.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*out_value</span></code></dt><dd><p>Set to point to the first byte of the value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*out_value_length</span></code></dt><dd><p>Set to the length of the value (in bytes).</p>
</dd>
</dl>
<p>The memory referenced by the result is owned by the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> object and will be valid until either <code class="docutils literal notranslate"><span class="pre">fdb_future_destroy(future)</span></code> or <code class="docutils literal notranslate"><span class="pre">fdb_future_release_memory(future)</span></code> is called.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_get_string_array">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_get_string_array</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_strings</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_count</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Extracts an array of null-terminated C strings from an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> into caller-provided variables. <code class="docutils literal notranslate"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal notranslate"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">*out_strings</span></code></dt><dd><p>Set to point to the first string in the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*out_count</span></code></dt><dd><p>Set to the number of strings in the array.</p>
</dd>
</dl>
<p>The memory referenced by the result is owned by the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> object and will be valid until either <code class="docutils literal notranslate"><span class="pre">fdb_future_destroy(future)</span></code> or <code class="docutils literal notranslate"><span class="pre">fdb_future_release_memory(future)</span></code> is called.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_future_get_keyvalue_array">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_future_get_keyvalue_array</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">future</span></span>, <a class="reference internal" href="#c.FDBKeyValue" title="FDBKeyValue"><span class="n"><span class="pre">FDBKeyValue</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_kv</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_count</span></span>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_more</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Extracts an array of <a class="reference internal" href="#c.FDBKeyValue" title="FDBKeyValue"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBKeyValue</span></code></a> objects from an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> into caller-provided variables. <code class="docutils literal notranslate"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal notranslate"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">*out_kv</span></code></dt><dd><p>Set to point to the first <a class="reference internal" href="#c.FDBKeyValue" title="FDBKeyValue"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBKeyValue</span></code></a> object in the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*out_count</span></code></dt><dd><p>Set to the number of <a class="reference internal" href="#c.FDBKeyValue" title="FDBKeyValue"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBKeyValue</span></code></a> objects in the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*out_more</span></code></dt><dd><p>Set to true if (but not necessarily only if) values remain in the <em>key</em> range requested (possibly beyond the limits requested).</p>
</dd>
</dl>
<p>The memory referenced by the result is owned by the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> object and will be valid until either <code class="docutils literal notranslate"><span class="pre">fdb_future_destroy(future)</span></code> or <code class="docutils literal notranslate"><span class="pre">fdb_future_release_memory(future)</span></code> is called.</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.FDBKeyValue">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBKeyValue</span></span></span><br /></dt>
<dd><p>Represents a single key-value pair in the output of <a class="reference internal" href="#c.fdb_future_get_keyvalue_array" title="fdb_future_get_keyvalue_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_keyvalue_array()</span></code></a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">key_length</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">value_length</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">FDBKeyValue</span><span class="p">;</span>
</pre></div>
</div>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>A pointer to a key.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_length</span></code></dt><dd><p>The length of the key pointed to by <code class="docutils literal notranslate"><span class="pre">key</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>A pointer to a value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value_length</span></code></dt><dd><p>The length of the value pointed to by <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="database">
<h2>Database</h2>
<p>An <code class="docutils literal notranslate"><span class="pre">FDBDatabase</span></code> represents a FoundationDB database — a mutable, lexicographically ordered mapping from binary keys to binary values. Modifications to a database are performed via transactions.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.FDBDatabase">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBDatabase</span></span></span><br /></dt>
<dd><p>An opaque type that represents a database in the FoundationDB C API.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_create_database">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_create_database</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cluster_file_path</span></span>, <a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><span class="n"><span class="pre">FDBDatabase</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_database</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Creates a new database connected the specified cluster. The caller assumes ownership of the <a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBDatabase</span></code></a> object and must destroy it with <a class="reference internal" href="#c.fdb_database_destroy" title="fdb_database_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_database_destroy()</span></code></a>.</p>
<p>A single client can use this function multiple times to connect to different clusters simultaneously, with each invocation requiring its own cluster file. To connect to multiple clusters running at different, incompatible versions, the <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">multi-version client API</span></a> must be used.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cluster_file_path</span></code></dt><dd><p>A NULL-terminated string giving a local path of a <a class="reference internal" href="administration.html#foundationdb-cluster-file"><span class="std std-ref">cluster file</span></a> (often called ‘fdb.cluster’) which contains connection information for the FoundationDB cluster. If cluster_file_path is NULL or an empty string, then a <a class="reference internal" href="administration.html#default-cluster-file"><span class="std std-ref">default cluster file</span></a> will be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*out_database</span></code></dt><dd><p>Set to point to the newly created <a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBDatabase</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_database_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_database_destroy</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><span class="n"><span class="pre">FDBDatabase</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">database</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Destroys an <a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBDatabase</span></code></a> object. It must be called exactly once for each successful call to <a class="reference internal" href="#c.fdb_create_database" title="fdb_create_database"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_create_database()</span></code></a>. This function only destroys a handle to the database – your database will be fine!</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_database_set_option">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_database_set_option</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><span class="n"><span class="pre">FDBDatabase</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">database</span></span>, <a class="reference internal" href="#c.FDBDatabaseOption" title="FDBDatabaseOption"><span class="n"><span class="pre">FDBDatabaseOption</span></span></a><span class="w"> </span><span class="n"><span class="pre">option</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">value_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Called to set an option an on <a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBDatabase</span></code></a>. If the given option is documented as taking a parameter, you must also pass a pointer to the parameter value and the parameter value’s length. If the option is documented as taking an <code class="docutils literal notranslate"><span class="pre">Int</span></code> parameter, <code class="docutils literal notranslate"><span class="pre">value</span></code> must point to a signed 64-bit integer (little-endian), and <code class="docutils literal notranslate"><span class="pre">value_length</span></code> must be 8. This memory only needs to be valid until <a class="reference internal" href="#c.fdb_database_set_option" title="fdb_database_set_option"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_database_set_option()</span></code></a> returns.</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.FDBDatabaseOption">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBDatabaseOption</span></span></span><br /></dt>
<dd><p>Please see <code class="docutils literal notranslate"><span class="pre">fdb_c_options.g.h</span></code> for a definition of this type, along with documentation of its allowed values.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_database_open_tenant">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_database_open_tenant</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><span class="n"><span class="pre">FDBDatabase</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">database</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tenant_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">tenant_name_length</span></span>, <a class="reference internal" href="#c.FDBTenant" title="FDBTenant"><span class="n"><span class="pre">FDBTenant</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_tenant</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Opens a tenant on the given database. All transactions created by this tenant will operate on the tenant’s key-space. The caller assumes ownership of the <a class="reference internal" href="#c.FDBTenant" title="FDBTenant"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBTenant</span></code></a> object and must destroy it with <a class="reference internal" href="#c.fdb_tenant_destroy" title="fdb_tenant_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_tenant_destroy()</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tenant_name</span></code></dt><dd><p>The name of the tenant being accessed, as a byte string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tenant_name_length</span></code></dt><dd><p>The length of the tenant name byte string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*out_tenant</span></code></dt><dd><p>Set to point to the newly created <a class="reference internal" href="#c.FDBTenant" title="FDBTenant"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBTenant</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_database_create_transaction">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_database_create_transaction</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><span class="n"><span class="pre">FDBDatabase</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">database</span></span>, <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_transaction</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Creates a new transaction on the given database without using a tenant, meaning that it will operate on the entire database key-space. The caller assumes ownership of the <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBTransaction</span></code></a> object and must destroy it with <a class="reference internal" href="#c.fdb_transaction_destroy" title="fdb_transaction_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_destroy()</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">*out_transaction</span></code></dt><dd><p>Set to point to the newly created <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBTransaction</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_database_reboot_worker">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_database_reboot_worker</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><span class="n"><span class="pre">FDBDatabase</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">database</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">address</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">address_length</span></span>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">check</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">duration</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Reboot the specified process in the database.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to a <code class="xref c c-type docutils literal notranslate"><span class="pre">int64_t</span></code> which represents whether the reboot request is sent or not. In particular, 1 means request sent and 0 means failure (e.g. the process with the specified address does not exist). You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_int64" title="fdb_future_get_int64"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_int64()</span></code></a> to extract the result, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">address</span></code></dt><dd><p>A pointer to the network address of the process.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">address_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">address</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">check</span></code></dt><dd><p>whether to perform a storage engine integrity check. In particular, the check-on-reboot is implemented by writing a check/validation file on disk as breadcrumb for the process to find after reboot, at which point it will eat the breadcrumb file and pass true to the integrityCheck parameter of the openKVStore() factory method.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duration</span></code></dt><dd><p>If positive, the process will be first suspended for <code class="docutils literal notranslate"><span class="pre">duration</span></code> seconds before being rebooted.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_database_force_recovery_with_data_loss">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_database_force_recovery_with_data_loss</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><span class="n"><span class="pre">FDBDatabase</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">database</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dcId</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">dcId_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Force the database to recover into the given datacenter.</p>
<p>This function is only useful in a fearless configuration where you want to recover your database even with losing recently committed mutations.</p>
<p>In particular, the function will set usable_regions to 1 and the amount of mutations that will be lost depends on how far behind the remote datacenter is.</p>
<p>The function will change the region configuration to have a positive priority for the chosen dcId, and a negative priority for all other dcIds.</p>
<p>In particular, no error will be thrown if the given dcId does not exist. It will just not attempt to force a recovery.</p>
<p>If the database has already recovered, the function does nothing. Thus it’s safe to call it multiple times.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> representing an empty value. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_database_create_snapshot">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_database_create_snapshot</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><span class="n"><span class="pre">FDBDatabase</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">database</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">snapshot_command</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">snapshot_command_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Create a snapshot of the database.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">uid</span></code></dt><dd><p>A UID used to create snapshot. A valid uid is a 32-length hex string, otherwise, it will fail with error_code_snap_invalid_uid_string.</p>
<p>It is the user’s responsibility to make sure the given <code class="docutils literal notranslate"><span class="pre">uid</span></code> is unique.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uid_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">uid</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snapshot_command</span></code></dt><dd><p>A pointer to all the snapshot command arguments.</p>
<p>In particular, if the original <code class="docutils literal notranslate"><span class="pre">fdbcli</span></code> command is <code class="docutils literal notranslate"><span class="pre">snapshot</span> <span class="pre">&lt;arg1&gt;</span> <span class="pre">&lt;arg2&gt;</span> <span class="pre">&lt;argN&gt;</span></code>, then the string <code class="docutils literal notranslate"><span class="pre">snapshot_command</span></code> points to is <code class="docutils literal notranslate"><span class="pre">&lt;arg1&gt;</span> <span class="pre">&lt;arg2&gt;</span> <span class="pre">&lt;argN&gt;</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snapshot_command_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">snapshot_command</span></code></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function is exposing the functionality of the fdbcli command <code class="docutils literal notranslate"><span class="pre">snapshot</span></code>. Please take a look at the documentation before using (see <a class="reference internal" href="disk-snapshot-backup.html#disk-snapshot-backups"><span class="std std-ref">Disk snapshot backup and Restore</span></a>).</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_database_get_main_thread_busyness">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_database_get_main_thread_busyness</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><span class="n"><span class="pre">FDBDatabase</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">database</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns a value where 0 indicates that the client is idle and 1 (or larger) indicates that the client is saturated. By default, this value is updated every second.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_database_get_client_status">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_database_get_client_status</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><span class="n"><span class="pre">FDBDatabase</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">db</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns a JSON string containing database client-side status information. If the Multi-version client API is disabled an empty string will be returned.
At the top level the report describes the status of the Multi-Version Client database - its initialization state, the protocol version, the available client versions. The report schema is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w">  </span><span class="s">&quot;Healthy&quot;</span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">overall</span><span class="w"> </span><span class="n">health</span><span class="w"> </span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="nb">false</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">   </span><span class="s">&quot;InitializationState&quot;</span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">initializing</span><span class="o">|</span><span class="n">initialization_failed</span><span class="o">|</span><span class="n">created</span><span class="o">|</span><span class="n">incompatible</span><span class="o">|</span><span class="n">closed</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">   </span><span class="s">&quot;InitializationError&quot;</span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">initialization</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">code</span><span class="p">,</span><span class="w"> </span><span class="n">present</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">initialization</span><span class="w"> </span><span class="n">failed</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">   </span><span class="s">&quot;ProtocolVersion&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">determined</span><span class="w"> </span><span class="n">protocol</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cluster</span><span class="p">,</span><span class="w"> </span><span class="n">present</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">determined</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">   </span><span class="s">&quot;ConnectionRecord&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">connection</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">connection</span><span class="w"> </span><span class="n">string</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">   </span><span class="s">&quot;DatabaseStatus&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Native</span><span class="w"> </span><span class="n">Database</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="n">report</span><span class="p">,</span><span class="w"> </span><span class="n">present</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">successfully</span><span class="w"> </span><span class="n">retrieved</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">   </span><span class="s">&quot;ErrorRetrievingDatabaseStatus&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">error</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">retrieving</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Native</span><span class="w"> </span><span class="n">Database</span><span class="p">,</span><span class="w"> </span><span class="n">present</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">failed</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">   </span><span class="s">&quot;AvailableClients&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;ProtocolVersion&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">protocol</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">client</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">         </span><span class="s">&quot;ReleaseVersion&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">release</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">client</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">         </span><span class="s">&quot;ThreadIndex&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">the</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="n">serving</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">database</span><span class="o">&gt;</span>
<span class="w">      </span><span class="p">},</span><span class="w">  </span><span class="p">...</span>
<span class="w">   </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The status of the actual version-specific database is embedded within the <code class="docutils literal notranslate"><span class="pre">DatabaseStatus</span></code> attribute. It lists the addresses of various FDB
server roles the client is aware of and their connection status. The schema of the <code class="docutils literal notranslate"><span class="pre">DatabaseStatus</span></code> object is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w">  </span><span class="s">&quot;Healthy&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">overall</span><span class="w"> </span><span class="n">health</span><span class="w"> </span><span class="n">status</span><span class="o">:</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="nb">false</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">   </span><span class="s">&quot;ClusterID&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">UUID</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">   </span><span class="s">&quot;Coordinators&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">  </span><span class="p">],</span>
<span class="w">   </span><span class="s">&quot;CurrentCoordinator&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span>
<span class="w">   </span><span class="s">&quot;GrvProxies&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">  </span><span class="p">],</span>
<span class="w">   </span><span class="s">&quot;CommitProxies&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">],</span>
<span class="w">   </span><span class="s">&quot;StorageServers&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;Address&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SSID&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Storage</span><span class="w"> </span><span class="n">Server</span><span class="w"> </span><span class="n">ID</span><span class="o">&gt;</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">],</span>
<span class="w">   </span><span class="s">&quot;Connections&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;Address&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;Status&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">failed</span><span class="o">|</span><span class="n">connected</span><span class="o">|</span><span class="n">connecting</span><span class="o">|</span><span class="n">disconnected</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;Compatible&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">is</span><span class="w"> </span><span class="n">protocol</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="n">compatible</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">client</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;ConnectFailedCount&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">failed</span><span class="w"> </span><span class="n">connection</span><span class="w"> </span><span class="n">attempts</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;LastConnectTime&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">elapsed</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">seconds</span><span class="w"> </span><span class="n">since</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="n">connection</span><span class="w"> </span><span class="n">attempt</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;PingCount&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">total</span><span class="w"> </span><span class="n">ping</span><span class="w"> </span><span class="n">count</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;PingTimeoutCount&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">ping</span><span class="w"> </span><span class="n">timeouts</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;BytesSampleTime&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">elapsed</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">reported</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="n">received</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">sent</span><span class="w"> </span><span class="n">values</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;BytesReceived&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">bytes</span><span class="w"> </span><span class="n">received</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;BytesSent&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">bytes</span><span class="w"> </span><span class="n">sent</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;ProtocolVersion&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">protocol</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="n">missing</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">unknown</span><span class="o">&gt;</span>
<span class="w">   </span><span class="p">},</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="tenant">
<h2>Tenant</h2>
<p><code class="docutils literal notranslate"><span class="pre">FDBTenant</span></code> represents a FoundationDB tenant. Tenants are optional named transaction domains that can be used to provide multiple disjoint key-spaces to client applications. A transaction created in a tenant will be limited to the keys contained within that tenant, and transactions operating on different tenants can use the same key names without interfering with each other.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.FDBTenant">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBTenant</span></span></span><br /></dt>
<dd><p>An opaque type that represents a tenant in the FoundationDB C API.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_tenant_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_tenant_destroy</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTenant" title="FDBTenant"><span class="n"><span class="pre">FDBTenant</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tenant</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Destroys an <a class="reference internal" href="#c.FDBTenant" title="FDBTenant"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBTenant</span></code></a> object. It must be called exactly once for each successful call to <code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_database_create_tenant()</span></code>. This function only destroys a handle to the tenant – the tenant and its data will be fine!</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_tenant_create_transaction">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_tenant_create_transaction</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTenant" title="FDBTenant"><span class="n"><span class="pre">FDBTenant</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tenant</span></span>, <span class="n"><span class="pre">FDBTronsaction</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_transaction</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Creates a new transaction on the given tenant. This transaction will operate within the tenant’s key-space and cannot access data outside the tenant. The caller assumes ownership of the <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBTransaction</span></code></a> object and must destroy it with <a class="reference internal" href="#c.fdb_transaction_destroy" title="fdb_transaction_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_destroy()</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">*out_transaction</span></code></dt><dd><p>Set to point to the newly created <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBTransaction</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="transaction">
<h2>Transaction</h2>
<p>In FoundationDB, a transaction is a mutable snapshot of a database. All read and write operations on a transaction see and modify an otherwise-unchanging version of the database and only change the underlying database if and when the transaction is committed. Read operations do see the effects of previous write operations on the same transaction. Committing a transaction usually succeeds in the absence of <a class="reference internal" href="developer-guide.html#conflict-ranges"><span class="std std-ref">conflicts</span></a>.</p>
<p>Applications must provide error handling and an appropriate retry loop around the application code for a transaction. See the documentation for <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_on_error()</span></code></a>.</p>
<p>Transactions group operations into a unit with the properties of <em>atomicity</em>, <em>isolation</em>, and <em>durability</em>. Transactions also provide the ability to maintain an application’s invariants or integrity constraints, supporting the property of <em>consistency</em>. Together these properties are known as <a class="reference internal" href="developer-guide.html#acid"><span class="std std-ref">ACID</span></a>.</p>
<p>Transactions are also causally consistent: once a transaction has been successfully committed, all subsequently created transactions will see the modifications made by it.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.FDBTransaction">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBTransaction</span></span></span><br /></dt>
<dd><p>An opaque type that represents a transaction in the FoundationDB C API.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_destroy</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Destroys an <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBTransaction</span></code></a> object. It must be called exactly once for each successful call to <a class="reference internal" href="#c.fdb_database_create_transaction" title="fdb_database_create_transaction"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_database_create_transaction()</span></code></a>. Destroying a transaction which has not had <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_commit()</span></code></a> called implicitly “rolls back” the transaction (sets and clears do not take effect on the database).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_set_option">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_set_option</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <a class="reference internal" href="#c.FDBTransactionOption" title="FDBTransactionOption"><span class="n"><span class="pre">FDBTransactionOption</span></span></a><span class="w"> </span><span class="n"><span class="pre">option</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">value_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Called to set an option on an <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBTransaction</span></code></a>. If the given option is documented as taking a parameter, you must also pass a pointer to the parameter value and the parameter value’s length. If the option is documented as taking an <code class="docutils literal notranslate"><span class="pre">Int</span></code> parameter, <code class="docutils literal notranslate"><span class="pre">value</span></code> must point to a signed 64-bit integer (little-endian), and <code class="docutils literal notranslate"><span class="pre">value_length</span></code> must be 8. This memory only needs to be valid until <a class="reference internal" href="#c.fdb_transaction_set_option" title="fdb_transaction_set_option"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_set_option()</span></code></a> returns.</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.FDBTransactionOption">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBTransactionOption</span></span></span><br /></dt>
<dd><p>Please see <code class="docutils literal notranslate"><span class="pre">fdb_c_options.g.h</span></code> for a definition of this type, along with documentation of its allowed values.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_set_read_version">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_set_read_version</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="n"><span class="pre">version</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Sets the snapshot read version used by a transaction. This is not needed in simple cases. If the given version is too old, subsequent reads will fail with error_code_transaction_too_old; if it is too new, subsequent reads may be delayed indefinitely and/or fail with error_code_future_version. If any of <code class="docutils literal notranslate"><span class="pre">fdb_transaction_get_*()</span></code> have been called on this transaction already, the result is undefined.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get_read_version">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get_read_version</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to the transaction snapshot read version. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_int64" title="fdb_future_get_int64"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_int64()</span></code></a> to extract the version into an int64_t that you provide, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>The transaction obtains a snapshot read version automatically at the time of the first call to <code class="docutils literal notranslate"><span class="pre">fdb_transaction_get_*()</span></code> (including this one) and (unless causal consistency has been deliberately compromised by transaction options) is guaranteed to represent all transactions which were reported committed before that call.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key_name_length</span></span>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">snapshot</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Reads a value from the database snapshot represented by <code class="docutils literal notranslate"><span class="pre">transaction</span></code>.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to the value of <code class="docutils literal notranslate"><span class="pre">key_name</span></code> in the database. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_value" title="fdb_future_get_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_value()</span></code></a> to extract the value, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>See <a class="reference internal" href="#c.fdb_future_get_value" title="fdb_future_get_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_value()</span></code></a> to see exactly how results are unpacked. If <code class="docutils literal notranslate"><span class="pre">key_name</span></code> is not present in the database, the result is not an error, but a zero for <code class="docutils literal notranslate"><span class="pre">*out_present</span></code> returned from that function.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key_name</span></code></dt><dd><p>A pointer to the name of the key to be looked up in the database. The value does not need to be NULL-terminated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_name_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">key_name</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snapshot</span></code></dt><dd><p>Non-zero if this is a <a class="reference internal" href="#snapshots"><span class="std std-ref">snapshot read</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get_estimated_range_size_bytes">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get_estimated_range_size_bytes</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tr</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">begin_key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">begin_key_name_length</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">end_key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">end_key_name_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns an estimated byte size of the key range.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The estimated size is calculated based on the sampling done by FDB server. The sampling algorithm works roughly in this way: the larger the key-value pair is, the more likely it would be sampled and the more accurate its sampled size would be. And due to that reason it is recommended to use this API to query against large ranges for accuracy considerations. For a rough reference, if the returned size is larger than 3MB, one can consider the size to be accurate.</p>
</div>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to the estimated size of the key range given. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_int64" title="fdb_future_get_int64"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_int64()</span></code></a> to extract the size, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get_range_split_points">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get_range_split_points</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tr</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">begin_key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">begin_key_name_length</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">end_key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">end_key_name_length</span></span>, <span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="n"><span class="pre">chunk_size</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns a list of keys that can split the given range into (roughly) equally sized chunks based on <code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned split points contain the start key and end key of the given range</p>
</div>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to the list of split points. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_key_array" title="fdb_future_get_key_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_key_array()</span></code></a> to extract the array, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get_key">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get_key</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key_name_length</span></span>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">or_equal</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">snapshot</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Resolves a <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a> against the keys in the database snapshot represented by <code class="docutils literal notranslate"><span class="pre">transaction</span></code>.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to the key in the database matching the <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a>. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_key" title="fdb_future_get_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_key()</span></code></a> to extract the key, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key_name</span></code>, <code class="docutils literal notranslate"><span class="pre">key_name_length</span></code>, <code class="docutils literal notranslate"><span class="pre">or_equal</span></code>, <code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>The four components of a <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snapshot</span></code></dt><dd><p>Non-zero if this is a <a class="reference internal" href="#snapshots"><span class="std std-ref">snapshot read</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get_addresses_for_key">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get_addresses_for_key</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key_name_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns a list of public network addresses as strings, one for each of the storage servers responsible for storing <code class="docutils literal notranslate"><span class="pre">key_name</span></code> and its associated value.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to an array of strings. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_string_array" title="fdb_future_get_string_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_string_array()</span></code></a> to extract the string array, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key_name</span></code></dt><dd><p>A pointer to the name of the key whose location is to be queried.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_name_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">key_name</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get_range">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get_range</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">begin_key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">begin_key_name_length</span></span>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">begin_or_equal</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">begin_offset</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">end_key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">end_key_name_length</span></span>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">end_or_equal</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">end_offset</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">limit</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">target_bytes</span></span>, <a class="reference internal" href="#c.FDBStreamingMode" title="FDBStreamingMode"><span class="n"><span class="pre">FDBStreamingMode</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">iteration</span></span>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">snapshot</span></span>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">reverse</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Reads all key-value pairs in the database snapshot represented by <code class="docutils literal notranslate"><span class="pre">transaction</span></code> (potentially limited by <a class="reference internal" href="#c.fdb_transaction_get_range" title="limit"><code class="xref c c-data docutils literal notranslate"><span class="pre">limit</span></code></a>, <a class="reference internal" href="#c.fdb_transaction_get_range" title="target_bytes"><code class="xref c c-data docutils literal notranslate"><span class="pre">target_bytes</span></code></a>, or <a class="reference internal" href="#c.fdb_transaction_get_range" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>) which have a key lexicographically greater than or equal to the key resolved by the begin <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a> and lexicographically less than the key resolved by the end <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a>.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to an <a class="reference internal" href="#c.FDBKeyValue" title="FDBKeyValue"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBKeyValue</span></code></a> array. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_keyvalue_array" title="fdb_future_get_keyvalue_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_keyvalue_array()</span></code></a> to extract the key-value array, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">begin_key_name</span></code>, <a class="reference internal" href="#c.fdb_transaction_get_range" title="begin_key_name_length"><code class="xref c c-data docutils literal notranslate"><span class="pre">begin_key_name_length</span></code></a>, <a class="reference internal" href="#c.fdb_transaction_get_range" title="begin_or_equal"><code class="xref c c-data docutils literal notranslate"><span class="pre">begin_or_equal</span></code></a>, <a class="reference internal" href="#c.fdb_transaction_get_range" title="begin_offset"><code class="xref c c-data docutils literal notranslate"><span class="pre">begin_offset</span></code></a></dt><dd><p>The four components of a <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a> describing the beginning of the range.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end_key_name</span></code>, <a class="reference internal" href="#c.fdb_transaction_get_range" title="end_key_name_length"><code class="xref c c-data docutils literal notranslate"><span class="pre">end_key_name_length</span></code></a>, <a class="reference internal" href="#c.fdb_transaction_get_range" title="end_or_equal"><code class="xref c c-data docutils literal notranslate"><span class="pre">end_or_equal</span></code></a>, <a class="reference internal" href="#c.fdb_transaction_get_range" title="end_offset"><code class="xref c c-data docutils literal notranslate"><span class="pre">end_offset</span></code></a></dt><dd><p>The four components of a <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a> describing the end of the range.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">limit</span></code></dt><dd><p>If non-zero, indicates the maximum number of key-value pairs to return. If this limit was reached before the end of the specified range, then the <code class="docutils literal notranslate"><span class="pre">*more</span></code> return of <a class="reference internal" href="#c.fdb_future_get_keyvalue_array" title="fdb_future_get_keyvalue_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_keyvalue_array()</span></code></a> will be set to a non-zero value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">target_bytes</span></code></dt><dd><p>If non-zero, indicates a (soft) cap on the combined number of bytes of keys and values to return. If this limit was reached before the end of the specified range, then the <code class="docutils literal notranslate"><span class="pre">*more</span></code> return of <a class="reference internal" href="#c.fdb_future_get_keyvalue_array" title="fdb_future_get_keyvalue_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_keyvalue_array()</span></code></a> will be set to a non-zero value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>One of the <a class="reference internal" href="#c.FDBStreamingMode" title="FDBStreamingMode"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBStreamingMode</span></code></a> values indicating how the caller would like the data in the range returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iteration</span></code></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">mode</span></code> is <code class="xref c c-data docutils literal notranslate"><span class="pre">FDB_STREAMING_MODE_ITERATOR</span></code>, this parameter should start at 1 and be incremented by 1 for each successive call while reading this range. In all other cases it is ignored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snapshot</span></code></dt><dd><p>Non-zero if this is a <a class="reference internal" href="#snapshots"><span class="std std-ref">snapshot read</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reverse</span></code></dt><dd><p>If non-zero, key-value pairs will be returned in reverse lexicographical order beginning at the end of the range. Reading ranges in reverse is supported natively by the database and should have minimal extra cost.</p>
</dd>
</dl>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.FDBStreamingMode">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBStreamingMode</span></span></span><br /></dt>
<dd><p>An enumeration of available streaming modes to be passed to <a class="reference internal" href="#c.fdb_transaction_get_range" title="fdb_transaction_get_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_get_range()</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_STREAMING_MODE_ITERATOR</span></code></p>
<p>The caller is implementing an iterator (most likely in a binding to a higher level language). The amount of data returned depends on the value of the <code class="docutils literal notranslate"><span class="pre">iteration</span></code> parameter to <a class="reference internal" href="#c.fdb_transaction_get_range" title="fdb_transaction_get_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_get_range()</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_STREAMING_MODE_SMALL</span></code></p>
<p>Data is returned in small batches (not much more expensive than reading individual key-value pairs).</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_STREAMING_MODE_MEDIUM</span></code></p>
<p>Data is returned in batches between _SMALL and _LARGE.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_STREAMING_MODE_LARGE</span></code></p>
<p>Data is returned in batches large enough to be, in a high-concurrency environment, nearly as efficient as possible. If the caller does not need the entire range, some disk and network bandwidth may be wasted. The batch size may be still be too small to allow a single client to get high throughput from the database.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_STREAMING_MODE_SERIAL</span></code></p>
<p>Data is returned in batches large enough that an individual client can get reasonable read bandwidth from the database. If the caller does not need the entire range, considerable disk and network bandwidth may be wasted.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_STREAMING_MODE_WANT_ALL</span></code></p>
<p>The caller intends to consume the entire range and would like it all transferred as early as possible.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_STREAMING_MODE_EXACT</span></code></p>
<p>The caller has passed a specific row limit and wants that many rows delivered in a single batch.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key_name_length</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">value_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Modify the database snapshot represented by <code class="docutils literal notranslate"><span class="pre">transaction</span></code> to change the given key to have the given value. If the given key was not previously present in the database it is inserted.</p>
<p>The modification affects the actual database only if <code class="docutils literal notranslate"><span class="pre">transaction</span></code> is later committed with <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_commit()</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key_name</span></code></dt><dd><p>A pointer to the name of the key to be inserted into the database. The value does not need to be NULL-terminated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_name_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">key_name</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>A pointer to the value to be inserted into the database. The value does not need to be NULL-terminated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key_name_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Modify the database snapshot represented by <code class="docutils literal notranslate"><span class="pre">transaction</span></code> to remove the given key from the database. If the key was not previously present in the database, there is no effect.</p>
<p>The modification affects the actual database only if <code class="docutils literal notranslate"><span class="pre">transaction</span></code> is later committed with <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_commit()</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key_name</span></code></dt><dd><p>A pointer to the name of the key to be removed from the database. The value does not need to be NULL-terminated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_name_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">key_name</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_clear_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_clear_range</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">begin_key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">begin_key_name_length</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">end_key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">end_key_name_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Modify the database snapshot represented by <code class="docutils literal notranslate"><span class="pre">transaction</span></code> to remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.</p>
<p>The modification affects the actual database only if <code class="docutils literal notranslate"><span class="pre">transaction</span></code> is later committed with <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_commit()</span></code></a>.</p>
<p>Range clears are efficient with FoundationDB – clearing large amounts of data will be fast. However, this will not immediately free up disk - data for the deleted range is cleaned up in the background. For purposes of computing the transaction size, only the begin and end keys of a clear range are counted. The size of the data stored in the range does not count against the transaction size limit.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">begin_key_name</span></code></dt><dd><p>A pointer to the name of the key specifying the beginning of the range to clear. The value does not need to be NULL-terminated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">begin_key_name_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">begin_key_name</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end_key_name</span></code></dt><dd><p>A pointer to the name of the key specifying the end of the range to clear. The value does not need to be NULL-terminated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end_key_name_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">end_key_name_length</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_atomic_op">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_atomic_op</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key_name_length</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">param</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">param_length</span></span>, <a class="reference internal" href="#c.FDBMutationType" title="FDBMutationType"><span class="n"><span class="pre">FDBMutationType</span></span></a><span class="w"> </span><span class="n"><span class="pre">operationType</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Modify the database snapshot represented by <code class="docutils literal notranslate"><span class="pre">transaction</span></code> to perform the operation indicated by <code class="docutils literal notranslate"><span class="pre">operationType</span></code> with operand <code class="docutils literal notranslate"><span class="pre">param</span></code> to the value stored by the given key.</p>
<p>An atomic operation is a single database command that carries out several logical steps: reading the value of a key, performing a transformation on that value, and writing the result. Different atomic operations perform different transformations. Like other database operations, an atomic operation is used within a transaction; however, its use within a transaction will not cause the transaction to conflict.</p>
<p>Atomic operations do not expose the current value of the key to the client but simply send the database the transformation to apply. In regard to conflict checking, an atomic operation is equivalent to a write without a read. It can only cause <em>other</em> transactions performing reads of the key to conflict.</p>
<p>By combining these logical steps into a single, read-free operation, FoundationDB can guarantee that the transaction will not conflict due to the operation. This makes atomic operations ideal for operating on keys that are frequently modified. A common example is the use of a key-value pair as a counter.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If a transaction uses both an atomic operation and a strictly serializable read on the same key, the benefits of using the atomic operation (for both conflict checking and performance) are lost.</p>
</div>
<p>The modification affects the actual database only if <code class="docutils literal notranslate"><span class="pre">transaction</span></code> is later committed with <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_commit()</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key_name</span></code></dt><dd><p>A pointer to the name of the key whose value is to be mutated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_name_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">key_name</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">param</span></code></dt><dd><p>A pointer to the parameter with which the atomic operation will mutate the value associated with <code class="docutils literal notranslate"><span class="pre">key_name</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">param_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">operation_type</span></code></dt><dd><p>One of the <a class="reference internal" href="#c.FDBMutationType" title="FDBMutationType"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBMutationType</span></code></a> values indicating which operation should be performed.</p>
</dd>
</dl>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.FDBMutationType">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBMutationType</span></span></span><br /></dt>
<dd><p>An enumeration of available opcodes to be passed to <a class="reference internal" href="#c.fdb_transaction_atomic_op" title="fdb_transaction_atomic_op"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_atomic_op()</span></code></a></p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_MUTATION_TYPE_ADD</span></code></p>
<p>Performs an addition of little-endian integers. If the existing value in the database is not present or shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes.  If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>. In case of overflow, the result is truncated to the width of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<p>The integers to be added must be stored in a little-endian representation. They can be signed in two’s complement representation or unsigned. You can add to an integer at a known offset in the value by prepending the appropriate number of zero bytes to <code class="docutils literal notranslate"><span class="pre">param</span></code> and padding with zero bytes to match the length of the value. However, this offset technique requires that you know the addition will not cause the integer field within the value to overflow.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_MUTATION_TYPE_AND</span></code></p>
<p>Performs a bitwise “and” operation. If the existing value in the database is not present, then <code class="docutils literal notranslate"><span class="pre">param</span></code> is stored in the database. If the existing value in the database is  shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_MUTATION_TYPE_OR</span></code></p>
<p>Performs a bitwise “or” operation. If the existing value in the database is not present or shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_MUTATION_TYPE_XOR</span></code></p>
<p>Performs a bitwise “xor” operation. If the existing value in the database is not present or shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_MUTATION_TYPE_COMPARE_AND_CLEAR</span></code></p>
<p>Performs an atomic <code class="docutils literal notranslate"><span class="pre">compare</span> <span class="pre">and</span> <span class="pre">clear</span></code> operation. If the existing value in the database is equal to the given value, then given key is cleared.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_MUTATION_TYPE_MAX</span></code></p>
<p>Sets the value in the database to the larger of the existing value and <code class="docutils literal notranslate"><span class="pre">param</span></code>. If the existing value in the database is not present or shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<p>Both the existing value and <code class="docutils literal notranslate"><span class="pre">param</span></code> are treated as unsigned integers. (This differs from the behavior of atomic addition.)</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_MUTATION_TYPE_BYTE_MAX</span></code></p>
<p>Performs lexicographic comparison of byte strings. If the existing value in the database is not present, then <code class="docutils literal notranslate"><span class="pre">param</span></code> is stored. Otherwise the larger of the two values is then stored in the database.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_MUTATION_TYPE_MIN</span></code></p>
<p>Sets the value in the database to the smaller of the existing value and <code class="docutils literal notranslate"><span class="pre">param</span></code>. If the existing value in the database is not present, then <code class="docutils literal notranslate"><span class="pre">param</span></code> is stored in the database. If the existing value in the database is shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<p>Both the existing value and <code class="docutils literal notranslate"><span class="pre">param</span></code> are treated as unsigned integers. (This differs from the behavior of atomic addition.)</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_MUTATION_TYPE_BYTE_MIN</span></code></p>
<p>Performs lexicographic comparison of byte strings. If the existing value in the database is not present, then <code class="docutils literal notranslate"><span class="pre">param</span></code> is stored. Otherwise the smaller of the two values is then stored in the database.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_MUTATION_TYPE_SET_VERSIONSTAMPED_KEY</span></code></p>
<p>Transforms <code class="docutils literal notranslate"><span class="pre">key</span></code> using a versionstamp for the transaction. This key must be at least 14 bytes long. The final 4 bytes will be interpreted as a 32-bit little-endian integer denoting an index into the key at which to perform the transformation, and then trimmed off the key. The 10 bytes in the key beginning at the index will be overwritten with the versionstamp. If the index plus 10 bytes points past the end of the key, the result will be an error. Sets the transformed key in the database to <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<p>A versionstamp is a 10 byte, unique, monotonically (but not sequentially) increasing value for each committed transaction. The first 8 bytes are the committed version of the database (serialized in big-endian order). The last 2 bytes are monotonic in the serialization order for transactions (serialized in big-endian order).</p>
<p>A transaction is not permitted to read any transformed key or value previously set within that transaction, and an attempt to do so will result in an <code class="docutils literal notranslate"><span class="pre">accessed_unreadable</span></code> error.  The range of keys marked unreadable when setting a versionstamped key begins at the transactions’s read version if it is known, otherwise a versionstamp of all <code class="docutils literal notranslate"><span class="pre">0x00</span></code> bytes is conservatively assumed.  The upper bound of the unreadable range is a versionstamp of all <code class="docutils literal notranslate"><span class="pre">0xFF</span></code> bytes.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>At this time, versionstamped keys are not compatible with the Tuple layer except in Java, Python, and Go. Note that this implies versionstamped keys may not be used with the Subspace and Directory layers except in those languages.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">FDB_MUTATION_TYPE_SET_VERSIONSTAMPED_VALUE</span></code></p>
<p>Transforms <code class="docutils literal notranslate"><span class="pre">param</span></code> using a versionstamp for the transaction. This parameter must be at least 14 bytes long. The final 4 bytes will be interpreted as a 32-bit little-endian integer denoting an index into the parameter at which to perform the transformation, and then trimmed off the key. The 10 bytes in the parameter beginning at the index will be overwritten with the versionstamp. If the index plus 10 bytes points past the end of the parameter, the result will be an error. Sets <code class="docutils literal notranslate"><span class="pre">key</span></code> in the database to the transformed parameter.</p>
<p>A versionstamp is a 10 byte, unique, monotonically (but not sequentially) increasing value for each committed transaction. The first 8 bytes are the committed version of the database (serialized in big-endian order). The last 2 bytes are monotonic in the serialization order for transactions (serialized in big-endian order).</p>
<p>A transaction is not permitted to read any transformed key or value previously set within that transaction, and an attempt to do so will result in an <code class="docutils literal notranslate"><span class="pre">accessed_unreadable</span></code> error.  The range of keys marked unreadable when setting a versionstamped key begins at the transactions’s read version if it is known, otherwise a versionstamp of all <code class="docutils literal notranslate"><span class="pre">0x00</span></code> bytes is conservatively assumed.  The upper bound of the unreadable range is a versionstamp of all <code class="docutils literal notranslate"><span class="pre">0xFF</span></code> bytes.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>At this time, versionstamped values are not compatible with the Tuple layer except in Java, Python, and Go. Note that this implies versionstamped values may not be used with the Subspace and Directory layers except in those languages.</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_commit">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_commit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Attempts to commit the sets and clears previously applied to the database snapshot represented by <code class="docutils literal notranslate"><span class="pre">transaction</span></code> to the actual database. The commit may or may not succeed – in particular, if a conflicting transaction previously committed, then the commit must fail in order to preserve transactional isolation. If the commit does succeed, the transaction is durably committed to the database and all subsequently started transactions will observe its effects.</p>
<p>It is not necessary to commit a read-only transaction – you can simply call <a class="reference internal" href="#c.fdb_transaction_destroy" title="fdb_transaction_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_destroy()</span></code></a>.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> representing an empty value. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>Callers will usually want to retry a transaction if the commit or a prior <code class="docutils literal notranslate"><span class="pre">fdb_transaction_get_*()</span></code> returns a retryable error (see <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_on_error()</span></code></a>).</p>
<p>As with other client/server databases, in some failure scenarios a client may be unable to determine whether a transaction succeeded. In these cases, <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_commit()</span></code></a> will return a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> error. The <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_on_error()</span></code></a> function treats this error as retryable, so retry loops that don’t check for <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> could execute the transaction twice. In these cases, you must consider the idempotence of the transaction. For more information, see <a class="reference internal" href="developer-guide.html#developer-guide-unknown-results"><span class="std std-ref">Transactions with unknown results</span></a>.</p>
<p>Normally, commit will wait for outstanding reads to return. However, if those reads were snapshot reads or the transaction option for disabling “read-your-writes” has been invoked, any outstanding reads will immediately return errors.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get_committed_version">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get_committed_version</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_version</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Retrieves the database version number at which a given transaction was committed. <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_commit()</span></code></a> must have been called on <code class="docutils literal notranslate"><span class="pre">transaction</span></code> and the resulting future must be ready and not an error before this function is called, or the behavior is undefined. Read-only transactions do not modify the database when committed and will have a committed version of -1. Keep in mind that a transaction which reads keys and then sets them to their current values may be optimized to a read-only transaction.</p>
<p>Note that database versions are not necessarily unique to a given transaction and so cannot be used to determine in what order two transactions completed. The only use for this function is to manually enforce causal consistency when calling <a class="reference internal" href="#c.fdb_transaction_set_read_version" title="fdb_transaction_set_read_version"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_set_read_version()</span></code></a> on another subsequent transaction.</p>
<p>Most applications will not call this function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get_tag_throttled_duration">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get_tag_throttled_duration</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to the time (in seconds) that the transaction was throttled by the tag throttler in the returned future. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_double" title="fdb_future_get_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_double()</span></code></a> to extract the duration, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get_total_cost">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get_total_cost</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to the cost of the transaction so far (in bytes) in the returned future, as computed by the tag throttler, and used for tag throttling if throughput quotas are specified. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_int64" title="fdb_future_get_int64"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_int64()</span></code></a> to extract the cost, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get_approximate_size">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get_approximate_size</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to the approximate transaction size so far in the returned future, which is the summation of the estimated size of mutations, read conflict ranges, and write conflict ranges. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_int64" title="fdb_future_get_int64"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_int64()</span></code></a> to extract the size, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>This can be called multiple times before the transaction is committed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_get_versionstamp">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_get_versionstamp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> which will be set to the versionstamp which was used by any versionstamp operations in this transaction. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_key" title="fdb_future_get_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_get_key()</span></code></a> to extract the key, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>The future will be ready only after the successful completion of a call to <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_commit()</span></code></a> on this Transaction. Read-only transactions do not modify the database when committed and will result in the future completing with an error. Keep in mind that a transaction which reads keys and then sets them to their current values may be optimized to a read-only transaction.</p>
<p>Most applications will not call this function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_watch">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_watch</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key_name_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>A watch’s behavior is relative to the transaction that created it. A watch will report a change in relation to the key’s value as readable by that transaction. The initial value used for comparison is either that of the transaction’s read version or the value as modified by the transaction itself prior to the creation of the watch. If the value changes and then changes back to its initial value, the watch might not report the change.</p>
<p>Until the transaction that created it has been committed, a watch will not report changes made by <em>other</em> transactions. In contrast, a watch will immediately report changes made by the transaction itself. Watches cannot be created if the transaction has set the READ_YOUR_WRITES_DISABLE <a class="reference internal" href="#c.fdb_transaction_set_option" title="fdb_transaction_set_option"><code class="xref c c-func docutils literal notranslate"><span class="pre">transaction</span> <span class="pre">option</span></code></a>, and an attempt to do so will return an <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">watches_disabled</span></a> error.</p>
<p>If the transaction used to create a watch encounters an error during commit, then the watch will be set with that error. A transaction whose <a class="reference internal" href="developer-guide.html#developer-guide-unknown-results"><span class="std std-ref">commit result is unknown</span></a> will set all of its watches with the <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> error. If an uncommitted transaction is reset or destroyed, then any watches it created will be set with the <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">transaction_cancelled</span></a> error.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> representing an empty value that will be set once the watch has detected a change to the value at the specified key. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>By default, each database connection can have no more than 10,000 watches that have not yet reported a change. When this number is exceeded, an attempt to create a watch will return a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">too_many_watches</span></a> error. This limit can be changed using the MAX_WATCHES <a class="reference internal" href="#c.fdb_database_set_option" title="fdb_database_set_option"><code class="xref c c-func docutils literal notranslate"><span class="pre">database</span> <span class="pre">option</span></code></a>. Because a watch outlives the transaction that creates it, any watch that is no longer needed should be cancelled by calling <a class="reference internal" href="#c.fdb_future_cancel" title="fdb_future_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_cancel()</span></code></a> on its returned future.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key_name</span></code></dt><dd><p>A pointer to the name of the key to watch. The value does not need to be NULL-terminated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_name_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">key_name</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_on_error">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><span class="n"><span class="pre">FDBFuture</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_on_error</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">error</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Implements the recommended retry and backoff behavior for a transaction. This function knows which of the error codes generated by other <code class="docutils literal notranslate"><span class="pre">fdb_transaction_*()</span></code> functions represent temporary error conditions and which represent application errors that should be handled by the application. It also implements an exponential backoff strategy to avoid swamping the database cluster with excessive retries when there is a high level of conflict between transactions.</p>
<p>On receiving any type of error from an <code class="docutils literal notranslate"><span class="pre">fdb_transaction_*()</span></code> function, the application should:</p>
<ol class="arabic simple">
<li><p>Call <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_on_error()</span></code></a> with the returned <a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">fdb_error_t</span></code></a> code.</p></li>
<li><p>Wait for the resulting future to be ready.</p></li>
<li><p>If the resulting future is itself an error, destroy the future and FDBTransaction and report the error in an appropriate way.</p></li>
<li><p>If the resulting future is not an error, destroy the future and restart the application code that performs the transaction. The transaction itself will have already been reset to its initial state, but should not be destroyed and re-created because state used by <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_on_error()</span></code></a> to implement its backoff strategy and state related to timeouts and retry limits is stored there.</p></li>
</ol>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> representing an empty value. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_reset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_reset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Reset <code class="docutils literal notranslate"><span class="pre">transaction</span></code> to its initial state. This is similar to calling <a class="reference internal" href="#c.fdb_transaction_destroy" title="fdb_transaction_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_destroy()</span></code></a> followed by <a class="reference internal" href="#c.fdb_database_create_transaction" title="fdb_database_create_transaction"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_database_create_transaction()</span></code></a>. It is not necessary to call <a class="reference internal" href="#c.fdb_transaction_reset" title="fdb_transaction_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_reset()</span></code></a> when handling an error with <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_on_error()</span></code></a> since the transaction has already been reset.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_cancel">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_cancel</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Cancels the transaction. All pending or future uses of the transaction will return a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">transaction_cancelled</span></a> error. The transaction can be used again after it is <a class="reference internal" href="#c.fdb_transaction_reset" title="fdb_transaction_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">reset</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Be careful if you are using <a class="reference internal" href="#c.fdb_transaction_reset" title="fdb_transaction_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_reset()</span></code></a> and <a class="reference internal" href="#c.fdb_transaction_cancel" title="fdb_transaction_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_cancel()</span></code></a> concurrently with the same transaction. Since they negate each other’s effects, a race condition between these calls will leave the transaction in an unknown state.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If your program attempts to cancel a transaction after <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_commit()</span></code></a> has been called but before it returns, unpredictable behavior will result. While it is guaranteed that the transaction will eventually end up in a cancelled state, the commit may or may not occur. Moreover, even if the call to <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_commit()</span></code></a> appears to return a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">transaction_cancelled</span></a> error,  the commit may have occurred or may occur in the future. This can make it more difficult to reason about the order in which transactions occur.</p>
</div>
</dd></dl>

<span class="target" id="conflictranges"></span><dl class="c function">
<dt class="sig sig-object c" id="c.fdb_transaction_add_conflict_range">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_transaction_add_conflict_range</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><span class="n"><span class="pre">FDBTransaction</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transaction</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">begin_key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">begin_key_name_length</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">end_key_name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">end_key_name_length</span></span>, <a class="reference internal" href="#c.FDBConflictRangeType" title="FDBConflictRangeType"><span class="n"><span class="pre">FDBConflictRangeType</span></span></a><span class="w"> </span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Adds a <a class="reference internal" href="developer-guide.html#conflict-ranges"><span class="std std-ref">conflict range</span></a> to a transaction without performing the associated read or write.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Most applications will use the strictly serializable isolation that transactions provide by default and will not need to manipulate conflict ranges.</p>
</div>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">begin_key_name</span></code></dt><dd><p>A pointer to the name of the key specifying the beginning of the conflict range. The value does not need to be NULL-terminated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">begin_key_name_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">begin_key_name</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end_key_name</span></code></dt><dd><p>A pointer to the name of the key specifying the end of the conflict range. The value does not need to be NULL-terminated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end_key_name_length</span></code></dt><dd><p>The length of the parameter specified by <code class="docutils literal notranslate"><span class="pre">end_key_name_length</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>One of the <a class="reference internal" href="#c.FDBConflictRangeType" title="FDBConflictRangeType"><code class="xref c c-type docutils literal notranslate"><span class="pre">FDBConflictRangeType</span></code></a> values indicating what type of conflict range is being set.</p>
</dd>
</dl>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.FDBConflictRangeType">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDBConflictRangeType</span></span></span><br /></dt>
<dd><p>An enumeration of available conflict range types to be passed to <a class="reference internal" href="#c.fdb_transaction_add_conflict_range" title="fdb_transaction_add_conflict_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_add_conflict_range()</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_CONFLICT_RANGE_TYPE_READ</span></code></p>
<p>Adds a range of keys to the transaction’s read conflict ranges as if you had read the range. As a result, other transactions that write a key in this range could cause the transaction to fail with a conflict.</p>
<p><code class="docutils literal notranslate"><span class="pre">FDB_CONFLICT_RANGE_TYPE_WRITE</span></code></p>
<p>Adds a range of keys to the transaction’s write conflict ranges as if you had cleared the range. As a result, other transactions that concurrently read a key in this range could fail with a conflict.</p>
</dd></dl>

<section id="snapshot-reads">
<span id="snapshots"></span><h3>Snapshot reads</h3>
<p>Snapshot reads selectively relax FoundationDB’s isolation property, reducing <a class="reference internal" href="developer-guide.html#developer-guide-transaction-conflicts"><span class="std std-ref">conflicts</span></a> but making it harder to reason about concurrency.</p>
<p>By default, FoundationDB transactions guarantee <a class="reference internal" href="developer-guide.html#acid"><span class="std std-ref">strictly serializable isolation</span></a>, resulting in a state that is <em>as if</em> transactions were executed one at a time, even if they were executed concurrently. Serializability has little performance cost when there are few <a class="reference internal" href="developer-guide.html#developer-guide-transaction-conflicts"><span class="std std-ref">conflicts</span></a> but can be expensive when there are many. FoundationDB therefore also permits individual reads within a transaction to be done as snapshot reads.</p>
<p>Snapshot reads differ from ordinary (strictly serializable) reads by permitting the values they read to be modified by concurrent transactions, whereas strictly serializable reads cause conflicts in that case. Like strictly serializable reads, snapshot reads see the effects of prior writes in the same transaction. For more information on the use of snapshot reads, see <a class="reference internal" href="developer-guide.html#snapshot-isolation"><span class="std std-ref">Snapshot reads</span></a>.</p>
<p>In the C API, snapshot reads are performed by passing a non-zero value to the <code class="docutils literal notranslate"><span class="pre">snapshot</span></code> parameter of any of <code class="docutils literal notranslate"><span class="pre">fdb_transaction_get_*</span></code> (see for example <a class="reference internal" href="#c.fdb_transaction_get" title="fdb_transaction_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_get()</span></code></a>).  Snapshot reads also interact with transaction commit a little differently than normal reads. If a snapshot read is outstanding when transaction commit is called that read will immediately return an error. (Normally, transaction commit will wait until outstanding reads return before committing.)</p>
</section>
</section>
<section id="key-selectors">
<span id="id1"></span><h2>Key selectors</h2>
<p>FoundationDB’s lexicographically ordered data model permits finding keys based on their order (for example, finding the first key in the database greater than a given key). Key selectors represent a description of a key in the database that could be resolved to an actual key by <a class="reference internal" href="#c.fdb_transaction_get_key" title="fdb_transaction_get_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_get_key()</span></code></a> or used directly as the beginning or end of a range in <a class="reference internal" href="#c.fdb_transaction_get_range" title="fdb_transaction_get_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_get_range()</span></code></a>.</p>
<p>For more about how key selectors work, see <a class="reference internal" href="developer-guide.html#key-selectors"><span class="std std-ref">Key selectors</span></a>.</p>
<p>In the FoundationDB C API, key selectors are not represented by a structure of any kind, but are instead expressed as sequential parameters to <a class="reference internal" href="#c.fdb_transaction_get_key" title="fdb_transaction_get_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_get_key()</span></code></a> and <a class="reference internal" href="#c.fdb_transaction_get_range" title="fdb_transaction_get_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">fdb_transaction_get_range()</span></code></a>. For convenience, the most common key selectors are available as C macros that expand to the appropriate parameters.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.FDB_KEYSEL_LAST_LESS_THAN">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDB_KEYSEL_LAST_LESS_THAN</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">key_name</span></span>, <span class="n"><span class="pre">key_name_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.FDB_KEYSEL_LAST_LESS_OR_EQUAL">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDB_KEYSEL_LAST_LESS_OR_EQUAL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">key_name</span></span>, <span class="n"><span class="pre">key_name_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.FDB_KEYSEL_FIRST_GREATER_THAN">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDB_KEYSEL_FIRST_GREATER_THAN</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">key_name</span></span>, <span class="n"><span class="pre">key_name_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.FDB_KEYSEL_FIRST_GREATER_OR_EQUAL">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FDB_KEYSEL_FIRST_GREATER_OR_EQUAL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">key_name</span></span>, <span class="n"><span class="pre">key_name_length</span></span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<p>To use one of these macros, simply replace the four parameters in the function with one of <code class="docutils literal notranslate"><span class="pre">FDB_KEYSEL_*</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdb_transaction_get_key</span><span class="p">(</span><span class="n">transaction</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;key&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>could instead be written as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdb_transaction_get_key</span><span class="p">(</span><span class="n">transaction</span><span class="p">,</span><span class="w"> </span><span class="n">FDB_KEYSEL_FIRST_GREATER_THAN</span><span class="p">(</span><span class="s">&quot;key&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="miscellaneous">
<h2>Miscellaneous</h2>
<dl class="c type">
<dt class="sig sig-object c" id="c.fdb_bool_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_bool_t</span></span></span><br /></dt>
<dd><p>An integer type representing a boolean. A value of 0 is false and non-zero is true.</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.fdb_error_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_error_t</span></span></span><br /></dt>
<dd><p>An integer type representing an error. A value of 0 is success and non-zero is an error.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_get_error">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fdb_get_error</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">code</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Returns a (somewhat) human-readable English message from an error code. The return value is a statically allocated null-terminated string that <em>must not</em> be freed by the caller.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fdb_error_predicate">
<a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t"><span class="n"><span class="pre">fdb_bool_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fdb_error_predicate</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">predicate_test</span></span>, <a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><span class="n"><span class="pre">fdb_error_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">code</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Evaluates a predicate against an error code. The predicate to run should be one of the codes listed by the <code class="docutils literal notranslate"><span class="pre">FDBErrorPredicate</span></code> enum defined within <code class="docutils literal notranslate"><span class="pre">fdb_c_options.g.h</span></code>. Sample predicates include <code class="docutils literal notranslate"><span class="pre">FDB_ERROR_PREDICATE_RETRYABLE</span></code>, which can be used to determine whether the error with the given code is a retryable error or not.</p>
</dd></dl>

</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/api-c.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2013-2022 Apple, Inc and the FoundationDB project authors.<br/>
      Last updated on Jun 12, 2025.<br/>
    </p>
  </div>
</footer>
  </body>
</html>