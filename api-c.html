<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>C API &#8212; FoundationDB 7.1</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.3.4/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.3.4/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '7.1.25',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Error Codes" href="api-error-codes.html" />
    <link rel="prev" title="Ruby API" href="api-ruby.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          FoundationDB</a>
        <span class="navbar-text navbar-version pull-left"><b>7.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="contents.html">Site Map</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">C API</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#linking">Linking</a><ul>
<li><a class="reference internal" href="#linux">Linux</a></li>
<li><a class="reference internal" href="#macos">macOS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api-versioning">API versioning</a></li>
<li><a class="reference internal" href="#network">Network</a></li>
<li><a class="reference internal" href="#future">Future</a></li>
<li><a class="reference internal" href="#database">Database</a></li>
<li><a class="reference internal" href="#tenant">Tenant</a></li>
<li><a class="reference internal" href="#transaction">Transaction</a><ul>
<li><a class="reference internal" href="#snapshot-reads">Snapshot reads</a></li>
</ul>
</li>
<li><a class="reference internal" href="#key-selectors">Key selectors</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="api-ruby.html" title="Previous Chapter: Ruby API"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Ruby API</span>
    </a>
  </li>
  <li>
    <a href="api-error-codes.html" title="Next Chapter: Error Codes"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Error Codes &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">C API</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#linking">Linking</a><ul>
<li><a class="reference internal" href="#linux">Linux</a></li>
<li><a class="reference internal" href="#macos">macOS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api-versioning">API versioning</a></li>
<li><a class="reference internal" href="#network">Network</a></li>
<li><a class="reference internal" href="#future">Future</a></li>
<li><a class="reference internal" href="#database">Database</a></li>
<li><a class="reference internal" href="#tenant">Tenant</a></li>
<li><a class="reference internal" href="#transaction">Transaction</a><ul>
<li><a class="reference internal" href="#snapshot-reads">Snapshot reads</a></li>
</ul>
</li>
<li><a class="reference internal" href="#key-selectors">Key selectors</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="col-md-9 content">
      
  <div class="section" id="c-api">
<h1>C API</h1>
<p>This API provides a very low-level interface to FoundationDB. It is primarily intended for use in implementing higher level APIs, rather than for direct use. If you are new to FoundationDB, you are probably better served by reading one of the other APIs first.</p>
<div class="section" id="installation">
<h2>Installation</h2>
<p>FoundationDB&#8217;s C bindings are installed with the FoundationDB client binaries (see <a class="reference internal" href="api-general.html#installing-client-binaries"><span class="std std-ref">Installing FoundationDB client binaries</span></a>).</p>
<dl class="docutils">
<dt>On Linux,</dt>
<dd><div class="first last line-block">
<div class="line"><code class="docutils literal"><span class="pre">fdb_c.h</span></code> is installed into <code class="docutils literal"><span class="pre">/usr/include/foundationdb/</span></code></div>
<div class="line"><code class="docutils literal"><span class="pre">libfdb_c.so</span></code> is installed into <code class="docutils literal"><span class="pre">/usr/lib/</span></code></div>
</div>
</dd>
<dt>On macOS,</dt>
<dd><div class="first last line-block">
<div class="line"><code class="docutils literal"><span class="pre">fdb_c.h</span></code> is installed into <code class="docutils literal"><span class="pre">/usr/local/include/foundationdb/</span></code></div>
<div class="line"><code class="docutils literal"><span class="pre">libfdb_c.dylib</span></code> is installed into <code class="docutils literal"><span class="pre">/usr/local/lib/</span></code></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="linking">
<h2>Linking</h2>
<p>The FoundationDB C bindings are provided as a shared object which may be linked against at build time, or dynamically loaded at runtime. Any program that uses this API must be able to find a platform-appropriate shared library at runtime. Generally, this condition is best met by installing the FoundationDB client binaries (see <a class="reference internal" href="api-general.html#installing-client-binaries"><span class="std std-ref">Installing FoundationDB client binaries</span></a>) on any machine where the program will be run.</p>
<div class="section" id="linux">
<h3>Linux</h3>
<p>When linking against <code class="docutils literal"><span class="pre">libfdb_c.so</span></code>, you must also link against <code class="docutils literal"><span class="pre">libm</span></code>, <code class="docutils literal"><span class="pre">libpthread</span></code> and <code class="docutils literal"><span class="pre">librt</span></code>. These dependencies will be resolved by the dynamic linker when using this API via <code class="docutils literal"><span class="pre">dlopen()</span></code> or an FFI.</p>
</div>
<div class="section" id="macos">
<h3>macOS</h3>
<p>When linking against <code class="docutils literal"><span class="pre">libfdb_c.dylib</span></code>, no additional libraries are required.</p>
</div>
</div>
<div class="section" id="api-versioning">
<h2>API versioning</h2>
<p>Prior to including <code class="docutils literal"><span class="pre">fdb_c.h</span></code>, you must define the <code class="docutils literal"><span class="pre">FDB_API_VERSION</span></code> macro. This, together with the <a class="reference internal" href="#c.fdb_select_api_version" title="fdb_select_api_version"><code class="xref c c-func docutils literal"><span class="pre">fdb_select_api_version()</span></code></a> function, allows programs written against an older version of the API to compile and run with newer versions of the C library. The current version of the FoundationDB C API is 710.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define FDB_API_VERSION 710</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;foundationdb/fdb_c.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<dl class="function">
<dt id="c.fdb_select_api_version">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_select_api_version</code><span class="sig-paren">(</span>int<em>&nbsp;version</em><span class="sig-paren">)</span></dt>
<dd><p>Must be called before any other API functions. <code class="docutils literal"><span class="pre">version</span></code> must be less than or equal to <code class="docutils literal"><span class="pre">FDB_API_VERSION</span></code> (and should almost always be equal).</p>
<p>Language bindings implemented in C which themselves expose API versioning will usually pass the version requested by the application, instead of always passing <code class="docutils literal"><span class="pre">FDB_API_VERSION</span></code>.</p>
<p>Passing a version less than <code class="docutils literal"><span class="pre">FDB_API_VERSION</span></code> will cause the API to behave as it did in the older version.</p>
<p>It is an error to call this function after it has returned successfully. It is not thread safe, and if called from more than one thread simultaneously its behavior is undefined.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is actually implemented as a macro. If you are accessing this API via <code class="docutils literal"><span class="pre">dlopen()</span></code> or an FFI, you will need to use <a class="reference internal" href="#c.fdb_select_api_version_impl" title="fdb_select_api_version_impl"><code class="xref c c-func docutils literal"><span class="pre">fdb_select_api_version_impl()</span></code></a>.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When using the <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">multi-version client API</span></a>, setting an API version that is not supported by a particular client library will prevent that client from being used to connect to the cluster. In particular, you should not advance the API version of your application after upgrading your client until the cluster has also been upgraded.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.fdb_select_api_version_impl">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_select_api_version_impl</code><span class="sig-paren">(</span>int<em>&nbsp;runtime_version</em>, int<em>&nbsp;header_version</em><span class="sig-paren">)</span></dt>
<dd><p>This is the actual entry point called by the <a class="reference internal" href="#c.fdb_select_api_version" title="fdb_select_api_version"><code class="xref c c-func docutils literal"><span class="pre">fdb_select_api_version()</span></code></a> macro. It should never be called directly from C, but if you are accessing this API via <code class="docutils literal"><span class="pre">dlopen()</span></code> or an FFI, you will need to use it. <code class="docutils literal"><span class="pre">fdb_select_api_version(v)</span></code> is equivalent to <code class="docutils literal"><span class="pre">fdb_select_api_version_impl(v,</span> <span class="pre">FDB_API_VERSION)</span></code>.</p>
<p>It is an error to call this function after it has returned successfully. It is not thread safe, and if called from more than one thread simultaneously its behavior is undefined.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">runtime_version</span></code></dt>
<dd><p class="first">The version of run-time behavior the API is requested to provide. Must be less than or equal to <code class="docutils literal"><span class="pre">header_version</span></code>, and should almost always be equal.</p>
<p class="last">Language bindings which themselves expose API versioning will usually pass the version requested by the application.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">header_version</span></code></dt>
<dd>The version of the ABI (application binary interface) that the calling code expects to find in the shared library. If you are using an FFI, this <em>must</em> correspond to the version of the API you are using as a reference (currently 710). For example, the number of arguments that a function takes may be affected by this value, and an incorrect value is unlikely to yield success.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When using the <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">multi-version client API</span></a>, setting an API version that is not supported by a particular client library will prevent that client from being used to connect to the cluster. In particular, you should not advance the API version of your application after upgrading your client until the cluster has also been upgraded.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.fdb_get_max_api_version">
int <code class="descname">fdb_get_max_api_version</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">FDB_API_VERSION</span></code>, the current version of the FoundationDB C API.  This is the maximum version that may be passed to <a class="reference internal" href="#c.fdb_select_api_version" title="fdb_select_api_version"><code class="xref c c-func docutils literal"><span class="pre">fdb_select_api_version()</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="network">
<h2>Network</h2>
<p>The FoundationDB client library performs most tasks on a singleton thread (which usually will be a different thread than your application runs on). These functions are used to configure, start and stop the FoundationDB event loop on this thread.</p>
<dl class="function">
<dt id="c.fdb_network_set_option">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_network_set_option</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBNetworkOption" title="FDBNetworkOption">FDBNetworkOption</a><em>&nbsp;option</em>, uint8_t const*<em>&nbsp;value</em>, int<em>&nbsp;value_length</em><span class="sig-paren">)</span></dt>
<dd><p>Called to set network options. If the given option is documented as taking a parameter, you must also pass a pointer to the parameter value and the parameter value&#8217;s length. If the option is documented as taking an <code class="docutils literal"><span class="pre">Int</span></code> parameter, <code class="docutils literal"><span class="pre">value</span></code> must point to a signed 64-bit integer (little-endian), and <code class="docutils literal"><span class="pre">value_length</span></code> must be 8. This memory only needs to be valid until <a class="reference internal" href="#c.fdb_network_set_option" title="fdb_network_set_option"><code class="xref c c-func docutils literal"><span class="pre">fdb_network_set_option()</span></code></a> returns.</p>
</dd></dl>

<dl class="type">
<dt id="c.FDBNetworkOption">
<code class="descname">FDBNetworkOption</code></dt>
<dd><p>Please see <code class="docutils literal"><span class="pre">fdb_c_options.g.h</span></code> for a definition of this type, along with documentation of its allowed values.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_setup_network">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_setup_network</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Must be called after <a class="reference internal" href="#c.fdb_select_api_version" title="fdb_select_api_version"><code class="xref c c-func docutils literal"><span class="pre">fdb_select_api_version()</span></code></a> (and zero or more calls to <a class="reference internal" href="#c.fdb_network_set_option" title="fdb_network_set_option"><code class="xref c c-func docutils literal"><span class="pre">fdb_network_set_option()</span></code></a>) and before any other function in this API. <a class="reference internal" href="#c.fdb_setup_network" title="fdb_setup_network"><code class="xref c c-func docutils literal"><span class="pre">fdb_setup_network()</span></code></a> can only be called once.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_add_network_thread_completion_hook">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_add_network_thread_completion_hook</code><span class="sig-paren">(</span>void (<em>*hook</em>)(void*), void<em>&nbsp;*hook_parameter</em><span class="sig-paren">)</span></dt>
<dd><p>Must be called after <a class="reference internal" href="#c.fdb_setup_network" title="fdb_setup_network"><code class="xref c c-func docutils literal"><span class="pre">fdb_setup_network()</span></code></a> and prior to <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal"><span class="pre">fdb_run_network()</span></code></a> if called at all. This will register the given callback to run at the completion of the network thread. If there are multiple network threads running (which might occur if one is running multiple versions of the client, for example), then the callback is invoked once on each thread. When the supplied function is called, the supplied parameter is passed to it.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_run_network">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_run_network</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Must be called after <a class="reference internal" href="#c.fdb_setup_network" title="fdb_setup_network"><code class="xref c c-func docutils literal"><span class="pre">fdb_setup_network()</span></code></a> before any asynchronous functions in this API can be expected to complete. Unless your program is entirely event-driven based on results of asynchronous functions in this API and has no event loop of its own, you will want to invoke this function on an auxiliary thread (which it is your responsibility to create).</p>
<p>This function will not return until <a class="reference internal" href="#c.fdb_stop_network" title="fdb_stop_network"><code class="xref c c-func docutils literal"><span class="pre">fdb_stop_network()</span></code></a> is called by you or a serious error occurs. It is not possible to run more than one network thread, and the network thread cannot be restarted once it has been stopped. This means that once <code class="docutils literal"><span class="pre">fdb_run_network</span></code> has been called, it is not legal to call it again for the lifetime of the running program.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_stop_network">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_stop_network</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Signals the event loop invoked by <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal"><span class="pre">fdb_run_network()</span></code></a> to terminate. You must call this function <strong>and wait for</strong> <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal"><span class="pre">fdb_run_network()</span></code></a> <strong>to return</strong> before allowing your program to exit, or else the behavior is undefined. For example, when running <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal"><span class="pre">fdb_run_network()</span></code></a> on a thread (using pthread), this will look like:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">pthread_t</span><span class="w"> </span><span class="n">network_thread</span><span class="p">;</span><span class="w"> </span><span class="cm">/* handle for thread which invoked fdb_run_network() */</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>

<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdb_stop_network</span><span class="p">();</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* An error occurred (probably network not running) */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pthread_join</span><span class="p">(</span><span class="w"> </span><span class="n">network_thread</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* Unknown error */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This function may be called from any thread. Once the network is stopped it cannot be restarted during the lifetime of the running program.</p>
</dd></dl>

</div>
<div class="section" id="future">
<h2>Future</h2>
<p>Most functions in the FoundationDB API are asynchronous, meaning that they may return to the caller before actually delivering their result. These functions always return <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture*</span></code></a>. An <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> object represents a result value or error to be delivered at some future time. You can wait for a Future to be &#8220;ready&#8221; &#8211; to have a value or error delivered &#8211; by setting a callback function, or by blocking a thread, or by polling. Once a Future is ready, you can extract either an error code or a value of the appropriate type (the documentation for the original function will tell you which <code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_*()</span></code> function you should call).</p>
<p>To use the API in a synchronous way, you would typically do something like this for each asynchronous call:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// Call an API that returns FDBFuture*, documented as returning type foo in the future</span>
<span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdb_something</span><span class="p">();</span><span class="w"></span>

<span class="c1">// Wait for the Future to be *ready*</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">fdb_future_block_until_ready</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Exceptional error (e.g. out of memory)</span>
<span class="p">}</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdb_future_get_foo</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Use result</span>
<span class="w">    </span><span class="c1">// In some cases, you must be finished with result before calling</span>
<span class="w">    </span><span class="c1">// fdb_future_destroy() (see the documentation for the specific</span>
<span class="w">    </span><span class="c1">// fdb_future_get_*() method)</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Handle the error. If this is an error in a transaction, see</span>
<span class="w">    </span><span class="c1">// fdb_transaction_on_error()</span>
<span class="p">}</span><span class="w"></span>

<span class="n">fdb_future_destroy</span><span class="p">(</span><span class="n">f</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Futures make it easy to do multiple operations in parallel, by calling several asynchronous functions before waiting for any of the results. This can be important for reducing the latency of transactions.</p>
<p>See <a class="reference internal" href="developer-guide.html#developer-guide-programming-with-futures"><span class="std std-ref">Programming with futures</span></a> for further (language-independent) discussion.</p>
<dl class="type">
<dt id="c.FDBFuture">
<code class="descname">FDBFuture</code></dt>
<dd><p>An opaque type that represents a Future in the FoundationDB C API.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_cancel">
void <code class="descname">fdb_future_cancel</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em><span class="sig-paren">)</span></dt>
<dd><p>Cancels an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> object and its associated asynchronous operation. If called before the future is ready, attempts to access its value will return an <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">operation_cancelled</span></a> error. Cancelling a future which is already ready has no effect. Note that even if a future is not ready, its associated asynchronous operation may have succesfully completed and be unable to be cancelled.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_destroy">
void <code class="descname">fdb_future_destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em><span class="sig-paren">)</span></dt>
<dd><p>Destroys an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> object. It must be called exactly once for each FDBFuture* returned by an API function. It may be called before or after the future is ready. It will also cancel the future (and its associated operation if the latter is still outstanding).</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_block_until_ready">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_future_block_until_ready</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em><span class="sig-paren">)</span></dt>
<dd><p>Blocks the calling thread until the given Future is ready. It will return success even if the Future is set to an error &#8211; you must call <a class="reference internal" href="#c.fdb_future_get_error" title="fdb_future_get_error"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_error()</span></code></a> to determine that. <a class="reference internal" href="#c.fdb_future_block_until_ready" title="fdb_future_block_until_ready"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_block_until_ready()</span></code></a> will return an error only in exceptional conditions (e.g. deadlock detected, out of memory or other operating system resources).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Never call this function from a callback passed to <a class="reference internal" href="#c.fdb_future_set_callback" title="fdb_future_set_callback"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_set_callback()</span></code></a>. This may block the thread on which <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal"><span class="pre">fdb_run_network()</span></code></a> was invoked, resulting in a deadlock. In some cases the client can detect the deadlock and throw a <code class="docutils literal"><span class="pre">blocked_from_network_thread</span></code> error.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_is_ready">
<a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a> <code class="descname">fdb_future_is_ready</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em><span class="sig-paren">)</span></dt>
<dd><p>Returns non-zero if the Future is ready. A Future is ready if it has been set to a value or an error.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_set_callback">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_future_set_callback</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em>, <a class="reference internal" href="#c.FDBCallback" title="FDBCallback">FDBCallback</a><em>&nbsp;callback</em>, void*<em>&nbsp;callback_parameter</em><span class="sig-paren">)</span></dt>
<dd><p>Causes the <a class="reference internal" href="#c.FDBCallback" title="FDBCallback"><code class="xref c c-type docutils literal"><span class="pre">FDBCallback</span></code></a> function to be invoked as <code class="docutils literal"><span class="pre">callback(future,</span> <span class="pre">callback_parameter)</span></code> when the given Future is ready. If the Future is already ready, the call may occur in the current thread before this function returns (but this behavior is not guaranteed). Alternatively, the call may be delayed indefinitely and take place on the thread on which <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal"><span class="pre">fdb_run_network()</span></code></a> was invoked, and the callback is responsible for any necessary thread synchronization (and/or for posting work back to your application event loop, thread pool, etc. if your application&#8217;s architecture calls for that).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function guarantees the callback will be executed <strong>at most once</strong>.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Never call <a class="reference internal" href="#c.fdb_future_block_until_ready" title="fdb_future_block_until_ready"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_block_until_ready()</span></code></a> from a callback passed to this function. This may block the thread on which <a class="reference internal" href="#c.fdb_run_network" title="fdb_run_network"><code class="xref c c-func docutils literal"><span class="pre">fdb_run_network()</span></code></a> was invoked, resulting in a deadlock.</p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.FDBCallback">
<code class="descname">FDBCallback</code></dt>
<dd><p>A pointer to a function which takes <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture*</span></code></a> and <code class="docutils literal"><span class="pre">void*</span></code> and returns <code class="docutils literal"><span class="pre">void</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_release_memory">
void <code class="descname">fdb_future_release_memory</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em><span class="sig-paren">)</span></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function provides no benefit to most application code. It is designed for use in writing generic, thread-safe language bindings. Applications should normally call <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a> only.</p>
</div>
<p>This function may only be called after a successful (zero return value) call to <a class="reference internal" href="#c.fdb_future_get_key" title="fdb_future_get_key"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_key()</span></code></a>, <a class="reference internal" href="#c.fdb_future_get_value" title="fdb_future_get_value"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_value()</span></code></a>, or <a class="reference internal" href="#c.fdb_future_get_keyvalue_array" title="fdb_future_get_keyvalue_array"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_keyvalue_array()</span></code></a>. It indicates that the memory returned by the prior get call is no longer needed by the application. After this function has been called the same number of times as <code class="docutils literal"><span class="pre">fdb_future_get_*()</span></code>, further calls to <code class="docutils literal"><span class="pre">fdb_future_get_*()</span></code> will return a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">future_released</span></a> error. It is still necessary to later destroy the future with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>Calling this function is optional, since <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a> will also release the memory returned by get functions. However, <a class="reference internal" href="#c.fdb_future_release_memory" title="fdb_future_release_memory"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_release_memory()</span></code></a> leaves the future object itself intact and provides a specific error code which can be used for coordination by multiple threads racing to do something with the results of a specific future. This has proven helpful in writing binding code.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_get_error">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_future_get_error</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em><span class="sig-paren">)</span></dt>
<dd><p>Returns zero if <code class="docutils literal"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_get_int64">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_future_get_int64</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em>, int64_t*<em>&nbsp;out</em><span class="sig-paren">)</span></dt>
<dd><p>Extracts a 64-bit integer from an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture*</span></code></a> into a caller-provided variable of type <code class="docutils literal"><span class="pre">int64_t</span></code>. <code class="docutils literal"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_get_key_array">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_future_get_key_array</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;f</em>, FDBKey const**<em>&nbsp;out_key_array</em>, int*<em>&nbsp;out_count</em><span class="sig-paren">)</span></dt>
<dd><p>Extracts an array of <code class="xref c c-type docutils literal"><span class="pre">FDBKey</span></code> from an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture*</span></code></a> into a caller-provided variable of type <code class="docutils literal"><span class="pre">FDBKey*</span></code>. The size of the array will also be extracted and passed back by a caller-provided variable of type <code class="docutils literal"><span class="pre">int</span></code> <code class="docutils literal"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_get_key">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_future_get_key</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em>, uint8_t const**<em>&nbsp;out_key</em>, int*<em>&nbsp;out_key_length</em><span class="sig-paren">)</span></dt>
<dd><p>Extracts a key from an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> into caller-provided variables of type <code class="docutils literal"><span class="pre">uint8_t*</span></code> (a pointer to the beginning of the key) and <code class="docutils literal"><span class="pre">int</span></code> (the length of the key). <code class="docutils literal"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
<p>The memory referenced by the result is owned by the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> object and will be valid until either <code class="docutils literal"><span class="pre">fdb_future_destroy(future)</span></code> or <code class="docutils literal"><span class="pre">fdb_future_release_memory(future)</span></code> is called.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_get_value">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_future_get_value</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a>*<em>&nbsp;out_present</em>, uint8_t const**<em>&nbsp;out_value</em>, int*<em>&nbsp;out_value_length</em><span class="sig-paren">)</span></dt>
<dd><p>Extracts a database value from an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> into caller-provided variables. <code class="docutils literal"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">*out_present</span></code></dt>
<dd>Set to non-zero if (and only if) the requested value was present in the database. (If zero, the other outputs are meaningless.)</dd>
<dt><code class="docutils literal"><span class="pre">*out_value</span></code></dt>
<dd>Set to point to the first byte of the value.</dd>
<dt><code class="docutils literal"><span class="pre">*out_value_length</span></code></dt>
<dd>Set to the length of the value (in bytes).</dd>
</dl>
<p>The memory referenced by the result is owned by the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> object and will be valid until either <code class="docutils literal"><span class="pre">fdb_future_destroy(future)</span></code> or <code class="docutils literal"><span class="pre">fdb_future_release_memory(future)</span></code> is called.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_get_string_array">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_future_get_string_array</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em>, const char***<em>&nbsp;out_strings</em>, int*<em>&nbsp;out_count</em><span class="sig-paren">)</span></dt>
<dd><p>Extracts an array of null-terminated C strings from an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> into caller-provided variables. <code class="docutils literal"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">*out_strings</span></code></dt>
<dd>Set to point to the first string in the array.</dd>
<dt><code class="docutils literal"><span class="pre">*out_count</span></code></dt>
<dd>Set to the number of strings in the array.</dd>
</dl>
<p>The memory referenced by the result is owned by the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> object and will be valid until either <code class="docutils literal"><span class="pre">fdb_future_destroy(future)</span></code> or <code class="docutils literal"><span class="pre">fdb_future_release_memory(future)</span></code> is called.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_future_get_keyvalue_array">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_future_get_keyvalue_array</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>*<em>&nbsp;future</em>, <a class="reference internal" href="#c.FDBKeyValue" title="FDBKeyValue">FDBKeyValue</a> const**<em>&nbsp;out_kv</em>, int*<em>&nbsp;out_count</em>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a>*<em>&nbsp;out_more</em><span class="sig-paren">)</span></dt>
<dd><p>Extracts an array of <a class="reference internal" href="#c.FDBKeyValue" title="FDBKeyValue"><code class="xref c c-type docutils literal"><span class="pre">FDBKeyValue</span></code></a> objects from an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> into caller-provided variables. <code class="docutils literal"><span class="pre">future</span></code> must represent a result of the appropriate type (i.e. must have been returned by a function documented as returning this type), or the results are undefined.</p>
<p>Returns zero if <code class="docutils literal"><span class="pre">future</span></code> is ready and not in an error state, and a non-zero <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">error code</span></a> otherwise (in which case the value of any out parameter is undefined).</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">*out_kv</span></code></dt>
<dd>Set to point to the first <a class="reference internal" href="#c.FDBKeyValue" title="FDBKeyValue"><code class="xref c c-type docutils literal"><span class="pre">FDBKeyValue</span></code></a> object in the array.</dd>
<dt><code class="docutils literal"><span class="pre">*out_count</span></code></dt>
<dd>Set to the number of <a class="reference internal" href="#c.FDBKeyValue" title="FDBKeyValue"><code class="xref c c-type docutils literal"><span class="pre">FDBKeyValue</span></code></a> objects in the array.</dd>
<dt><code class="docutils literal"><span class="pre">*out_more</span></code></dt>
<dd>Set to true if (but not necessarily only if) values remain in the <em>key</em> range requested (possibly beyond the limits requested).</dd>
</dl>
<p>The memory referenced by the result is owned by the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> object and will be valid until either <code class="docutils literal"><span class="pre">fdb_future_destroy(future)</span></code> or <code class="docutils literal"><span class="pre">fdb_future_release_memory(future)</span></code> is called.</p>
</dd></dl>

<dl class="type">
<dt id="c.FDBKeyValue">
<code class="descname">FDBKeyValue</code></dt>
<dd><p>Represents a single key-value pair in the output of <a class="reference internal" href="#c.fdb_future_get_keyvalue_array" title="fdb_future_get_keyvalue_array"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_keyvalue_array()</span></code></a>.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">key_length</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">value_length</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">FDBKeyValue</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">key</span></code></dt>
<dd>A pointer to a key.</dd>
<dt><code class="docutils literal"><span class="pre">key_length</span></code></dt>
<dd>The length of the key pointed to by <code class="docutils literal"><span class="pre">key</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">value</span></code></dt>
<dd>A pointer to a value.</dd>
<dt><code class="docutils literal"><span class="pre">value_length</span></code></dt>
<dd>The length of the value pointed to by <code class="docutils literal"><span class="pre">value</span></code>.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="database">
<h2>Database</h2>
<p>An <code class="docutils literal"><span class="pre">FDBDatabase</span></code> represents a FoundationDB database &#8212; a mutable, lexicographically ordered mapping from binary keys to binary values. Modifications to a database are performed via transactions.</p>
<dl class="type">
<dt id="c.FDBDatabase">
<code class="descname">FDBDatabase</code></dt>
<dd><p>An opaque type that represents a database in the FoundationDB C API.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_create_database">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_create_database</code><span class="sig-paren">(</span>const char*<em>&nbsp;cluster_file_path</em>, <a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase">FDBDatabase</a>**<em>&nbsp;out_database</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new database connected the specified cluster. The caller assumes ownership of the <a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><code class="xref c c-type docutils literal"><span class="pre">FDBDatabase</span></code></a> object and must destroy it with <a class="reference internal" href="#c.fdb_database_destroy" title="fdb_database_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_database_destroy()</span></code></a>.</p>
<p>A single client can use this function multiple times to connect to different clusters simultaneously, with each invocation requiring its own cluster file. To connect to multiple clusters running at different, incompatible versions, the <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">multi-version client API</span></a> must be used.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cluster_file_path</span></code></dt>
<dd>A NULL-terminated string giving a local path of a <a class="reference internal" href="administration.html#foundationdb-cluster-file"><span class="std std-ref">cluster file</span></a> (often called &#8216;fdb.cluster&#8217;) which contains connection information for the FoundationDB cluster. If cluster_file_path is NULL or an empty string, then a <a class="reference internal" href="administration.html#default-cluster-file"><span class="std std-ref">default cluster file</span></a> will be used.</dd>
<dt><code class="docutils literal"><span class="pre">*out_database</span></code></dt>
<dd>Set to point to the newly created <a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><code class="xref c c-type docutils literal"><span class="pre">FDBDatabase</span></code></a>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.fdb_database_destroy">
void <code class="descname">fdb_database_destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase">FDBDatabase</a>*<em>&nbsp;database</em><span class="sig-paren">)</span></dt>
<dd><p>Destroys an <a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><code class="xref c c-type docutils literal"><span class="pre">FDBDatabase</span></code></a> object. It must be called exactly once for each successful call to <a class="reference internal" href="#c.fdb_create_database" title="fdb_create_database"><code class="xref c c-func docutils literal"><span class="pre">fdb_create_database()</span></code></a>. This function only destroys a handle to the database &#8211; your database will be fine!</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_database_set_option">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_database_set_option</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase">FDBDatabase</a>*<em>&nbsp;database</em>, <a class="reference internal" href="#c.FDBDatabaseOption" title="FDBDatabaseOption">FDBDatabaseOption</a><em>&nbsp;option</em>, uint8_t const*<em>&nbsp;value</em>, int<em>&nbsp;value_length</em><span class="sig-paren">)</span></dt>
<dd><p>Called to set an option an on <a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase"><code class="xref c c-type docutils literal"><span class="pre">FDBDatabase</span></code></a>. If the given option is documented as taking a parameter, you must also pass a pointer to the parameter value and the parameter value&#8217;s length. If the option is documented as taking an <code class="docutils literal"><span class="pre">Int</span></code> parameter, <code class="docutils literal"><span class="pre">value</span></code> must point to a signed 64-bit integer (little-endian), and <code class="docutils literal"><span class="pre">value_length</span></code> must be 8. This memory only needs to be valid until <a class="reference internal" href="#c.fdb_database_set_option" title="fdb_database_set_option"><code class="xref c c-func docutils literal"><span class="pre">fdb_database_set_option()</span></code></a> returns.</p>
</dd></dl>

<dl class="type">
<dt id="c.FDBDatabaseOption">
<code class="descname">FDBDatabaseOption</code></dt>
<dd><p>Please see <code class="docutils literal"><span class="pre">fdb_c_options.g.h</span></code> for a definition of this type, along with documentation of its allowed values.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_database_open_tenant">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_database_open_tenant</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase">FDBDatabase</a>*<em>&nbsp;database</em>, uint8_t const*<em>&nbsp;tenant_name</em>, int<em>&nbsp;tenant_name_length</em>, <a class="reference internal" href="#c.FDBTenant" title="FDBTenant">FDBTenant</a>**<em>&nbsp;out_tenant</em><span class="sig-paren">)</span></dt>
<dd><p>Opens a tenant on the given database. All transactions created by this tenant will operate on the tenant&#8217;s key-space. The caller assumes ownership of the <a class="reference internal" href="#c.FDBTenant" title="FDBTenant"><code class="xref c c-type docutils literal"><span class="pre">FDBTenant</span></code></a> object and must destroy it with <a class="reference internal" href="#c.fdb_tenant_destroy" title="fdb_tenant_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_tenant_destroy()</span></code></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">tenant_name</span></code></dt>
<dd>The name of the tenant being accessed, as a byte string.</dd>
<dt><code class="docutils literal"><span class="pre">tenant_name_length</span></code></dt>
<dd>The length of the tenant name byte string.</dd>
<dt><code class="docutils literal"><span class="pre">*out_tenant</span></code></dt>
<dd>Set to point to the newly created <a class="reference internal" href="#c.FDBTenant" title="FDBTenant"><code class="xref c c-type docutils literal"><span class="pre">FDBTenant</span></code></a>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.fdb_database_create_transaction">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_database_create_transaction</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase">FDBDatabase</a>*<em>&nbsp;database</em>, <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>**<em>&nbsp;out_transaction</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new transaction on the given database without using a tenant, meaning that it will operate on the entire database key-space. The caller assumes ownership of the <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal"><span class="pre">FDBTransaction</span></code></a> object and must destroy it with <a class="reference internal" href="#c.fdb_transaction_destroy" title="fdb_transaction_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_destroy()</span></code></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">*out_transaction</span></code></dt>
<dd>Set to point to the newly created <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal"><span class="pre">FDBTransaction</span></code></a>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.fdb_database_reboot_worker">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_database_reboot_worker</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase">FDBDatabase</a>*<em>&nbsp;database</em>, uint8_t const*<em>&nbsp;address</em>, int<em>&nbsp;address_length</em>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a><em>&nbsp;check</em>, int<em>&nbsp;duration</em><span class="sig-paren">)</span></dt>
<dd><p>Reboot the specified process in the database.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> which will be set to a <code class="xref c c-type docutils literal"><span class="pre">int64_t</span></code> which represents whether the reboot request is sent or not. In particular, 1 means request sent and 0 means failure (e.g. the process with the specified address does not exist). You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_int64" title="fdb_future_get_int64"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_int64()</span></code></a> to extract the result, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">address</span></code></dt>
<dd>A pointer to the network address of the process.</dd>
<dt><code class="docutils literal"><span class="pre">address_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">address</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">check</span></code></dt>
<dd>whether to perform a storage engine integrity check. In particular, the check-on-reboot is implemented by writing a check/validation file on disk as breadcrumb for the process to find after reboot, at which point it will eat the breadcrumb file and pass true to the integrityCheck parameter of the openKVStore() factory method.</dd>
<dt><code class="docutils literal"><span class="pre">duration</span></code></dt>
<dd>If positive, the process will be first suspended for <code class="docutils literal"><span class="pre">duration</span></code> seconds before being rebooted.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.fdb_database_force_recovery_with_data_loss">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_database_force_recovery_with_data_loss</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase">FDBDatabase</a>*<em>&nbsp;database</em>, uint8_t const*<em>&nbsp;dcId</em>, int<em>&nbsp;dcId_length</em><span class="sig-paren">)</span></dt>
<dd><p>Force the database to recover into the given datacenter.</p>
<p>This function is only useful in a fearless configuration where you want to recover your database even with losing recently committed mutations.</p>
<p>In particular, the function will set usable_regions to 1 and the amount of mutations that will be lost depends on how far behind the remote datacenter is.</p>
<p>The function will change the region configuration to have a positive priority for the chosen dcId, and a negative priority for all other dcIds.</p>
<p>In particular, no error will be thrown if the given dcId does not exist. It will just not attempt to force a recovery.</p>
<p>If the database has already recovered, the function does nothing. Thus it&#8217;s safe to call it multiple times.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> representing an empty value. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_database_create_snapshot">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_database_create_snapshot</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase">FDBDatabase</a>*<em>&nbsp;database</em>, uint8_t const*<em>&nbsp;snapshot_command</em>, int<em>&nbsp;snapshot_command_length</em><span class="sig-paren">)</span></dt>
<dd><p>Create a snapshot of the database.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uid</span></code></dt>
<dd><p class="first">A UID used to create snapshot. A valid uid is a 32-length hex string, otherwise, it will fail with error_code_snap_invalid_uid_string.</p>
<p class="last">It is the user&#8217;s responsibility to make sure the given <code class="docutils literal"><span class="pre">uid</span></code> is unique.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">uid_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">uid</span></code></dd>
<dt><code class="docutils literal"><span class="pre">snapshot_command</span></code></dt>
<dd><p class="first">A pointer to all the snapshot command arguments.</p>
<p class="last">In particular, if the original <code class="docutils literal"><span class="pre">fdbcli</span></code> command is <code class="docutils literal"><span class="pre">snapshot</span> <span class="pre">&lt;arg1&gt;</span> <span class="pre">&lt;arg2&gt;</span> <span class="pre">&lt;argN&gt;</span></code>, then the string <code class="docutils literal"><span class="pre">snapshot_command</span></code> points to is <code class="docutils literal"><span class="pre">&lt;arg1&gt;</span> <span class="pre">&lt;arg2&gt;</span> <span class="pre">&lt;argN&gt;</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">snapshot_command_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">snapshot_command</span></code></dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The function is exposing the functionality of the fdbcli command <code class="docutils literal"><span class="pre">snapshot</span></code>. Please take a look at the documentation before using (see <a class="reference internal" href="disk-snapshot-backup.html#disk-snapshot-backups"><span class="std std-ref">Disk snapshot backup and Restore</span></a>).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.fdb_database_get_main_thread_busyness">
double <code class="descname">fdb_database_get_main_thread_busyness</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBDatabase" title="FDBDatabase">FDBDatabase</a>*<em>&nbsp;database</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a value where 0 indicates that the client is idle and 1 (or larger) indicates that the client is saturated. By default, this value is updated every second.</p>
</dd></dl>

</div>
<div class="section" id="tenant">
<h2>Tenant</h2>
<p><code class="docutils literal"><span class="pre">FDBTenant</span></code> represents a FoundationDB tenant. Tenants are optional named transaction domains that can be used to provide multiple disjoint key-spaces to client applications. A transaction created in a tenant will be limited to the keys contained within that tenant, and transactions operating on different tenants can use the same key names without interfering with each other.</p>
<dl class="type">
<dt id="c.FDBTenant">
<code class="descname">FDBTenant</code></dt>
<dd><p>An opaque type that represents a tenant in the FoundationDB C API.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_tenant_destroy">
void <code class="descname">fdb_tenant_destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTenant" title="FDBTenant">FDBTenant</a>*<em>&nbsp;tenant</em><span class="sig-paren">)</span></dt>
<dd><p>Destroys an <a class="reference internal" href="#c.FDBTenant" title="FDBTenant"><code class="xref c c-type docutils literal"><span class="pre">FDBTenant</span></code></a> object. It must be called exactly once for each successful call to <code class="xref c c-func docutils literal"><span class="pre">fdb_database_create_tenant()</span></code>. This function only destroys a handle to the tenant &#8211; the tenant and its data will be fine!</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_tenant_create_transaction">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_tenant_create_transaction</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTenant" title="FDBTenant">FDBTenant</a>*<em>&nbsp;tenant</em>, FDBTronsaction<em>&nbsp;**out_transaction</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new transaction on the given tenant. This transaction will operate within the tenant&#8217;s key-space and cannot access data outside the tenant. The caller assumes ownership of the <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal"><span class="pre">FDBTransaction</span></code></a> object and must destroy it with <a class="reference internal" href="#c.fdb_transaction_destroy" title="fdb_transaction_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_destroy()</span></code></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">*out_transaction</span></code></dt>
<dd>Set to point to the newly created <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal"><span class="pre">FDBTransaction</span></code></a>.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="transaction">
<h2>Transaction</h2>
<p>In FoundationDB, a transaction is a mutable snapshot of a database. All read and write operations on a transaction see and modify an otherwise-unchanging version of the database and only change the underlying database if and when the transaction is committed. Read operations do see the effects of previous write operations on the same transaction. Committing a transaction usually succeeds in the absence of <a class="reference internal" href="developer-guide.html#conflict-ranges"><span class="std std-ref">conflicts</span></a>.</p>
<p>Applications must provide error handling and an appropriate retry loop around the application code for a transaction. See the documentation for <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_on_error()</span></code></a>.</p>
<p>Transactions group operations into a unit with the properties of <em>atomicity</em>, <em>isolation</em>, and <em>durability</em>. Transactions also provide the ability to maintain an application&#8217;s invariants or integrity constraints, supporting the property of <em>consistency</em>. Together these properties are known as <a class="reference internal" href="developer-guide.html#acid"><span class="std std-ref">ACID</span></a>.</p>
<p>Transactions are also causally consistent: once a transaction has been successfully committed, all subsequently created transactions will see the modifications made by it.</p>
<dl class="type">
<dt id="c.FDBTransaction">
<code class="descname">FDBTransaction</code></dt>
<dd><p>An opaque type that represents a transaction in the FoundationDB C API.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_destroy">
void <code class="descname">fdb_transaction_destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em><span class="sig-paren">)</span></dt>
<dd><p>Destroys an <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal"><span class="pre">FDBTransaction</span></code></a> object. It must be called exactly once for each successful call to <a class="reference internal" href="#c.fdb_database_create_transaction" title="fdb_database_create_transaction"><code class="xref c c-func docutils literal"><span class="pre">fdb_database_create_transaction()</span></code></a>. Destroying a transaction which has not had <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_commit()</span></code></a> called implicitly &#8220;rolls back&#8221; the transaction (sets and clears do not take effect on the database).</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_set_option">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_transaction_set_option</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, <a class="reference internal" href="#c.FDBTransactionOption" title="FDBTransactionOption">FDBTransactionOption</a><em>&nbsp;option</em>, uint8_t const*<em>&nbsp;value</em>, int<em>&nbsp;value_length</em><span class="sig-paren">)</span></dt>
<dd><p>Called to set an option on an <a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction"><code class="xref c c-type docutils literal"><span class="pre">FDBTransaction</span></code></a>. If the given option is documented as taking a parameter, you must also pass a pointer to the parameter value and the parameter value&#8217;s length. If the option is documented as taking an <code class="docutils literal"><span class="pre">Int</span></code> parameter, <code class="docutils literal"><span class="pre">value</span></code> must point to a signed 64-bit integer (little-endian), and <code class="docutils literal"><span class="pre">value_length</span></code> must be 8. This memory only needs to be valid until <a class="reference internal" href="#c.fdb_transaction_set_option" title="fdb_transaction_set_option"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_set_option()</span></code></a> returns.</p>
</dd></dl>

<dl class="type">
<dt id="c.FDBTransactionOption">
<code class="descname">FDBTransactionOption</code></dt>
<dd><p>Please see <code class="docutils literal"><span class="pre">fdb_c_options.g.h</span></code> for a definition of this type, along with documentation of its allowed values.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_set_read_version">
void <code class="descname">fdb_transaction_set_read_version</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, int64_t<em>&nbsp;version</em><span class="sig-paren">)</span></dt>
<dd><p>Sets the snapshot read version used by a transaction. This is not needed in simple cases. If the given version is too old, subsequent reads will fail with error_code_transaction_too_old; if it is too new, subsequent reads may be delayed indefinitely and/or fail with error_code_future_version. If any of <code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_get_*()</span></code> have been called on this transaction already, the result is undefined.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_get_read_version">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_get_read_version</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em><span class="sig-paren">)</span></dt>
<dd><p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> which will be set to the transaction snapshot read version. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_int64" title="fdb_future_get_int64"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_int64()</span></code></a> to extract the version into an int64_t that you provide, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>The transaction obtains a snapshot read version automatically at the time of the first call to <code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_get_*()</span></code> (including this one) and (unless causal consistency has been deliberately compromised by transaction options) is guaranteed to represent all transactions which were reported committed before that call.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_get">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_get</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, uint8_t const*<em>&nbsp;key_name</em>, int<em>&nbsp;key_name_length</em>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a><em>&nbsp;snapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Reads a value from the database snapshot represented by <code class="docutils literal"><span class="pre">transaction</span></code>.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> which will be set to the value of <code class="docutils literal"><span class="pre">key_name</span></code> in the database. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_value" title="fdb_future_get_value"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_value()</span></code></a> to extract the value, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>See <a class="reference internal" href="#c.fdb_future_get_value" title="fdb_future_get_value"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_value()</span></code></a> to see exactly how results are unpacked. If <code class="docutils literal"><span class="pre">key_name</span></code> is not present in the database, the result is not an error, but a zero for <code class="docutils literal"><span class="pre">*out_present</span></code> returned from that function.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">key_name</span></code></dt>
<dd>A pointer to the name of the key to be looked up in the database. The value does not need to be NULL-terminated.</dd>
<dt><code class="docutils literal"><span class="pre">key_name_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">key_name</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">snapshot</span></code></dt>
<dd>Non-zero if this is a <a class="reference internal" href="#snapshots"><span class="std std-ref">snapshot read</span></a>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_get_estimated_range_size_bytes">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_get_estimated_range_size_bytes</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;tr</em>, uint8_t const*<em>&nbsp;begin_key_name</em>, int<em>&nbsp;begin_key_name_length</em>, uint8_t const*<em>&nbsp;end_key_name</em>, int<em>&nbsp;end_key_name_length</em><span class="sig-paren">)</span></dt>
<dd><p>Returns an estimated byte size of the key range.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The estimated size is calculated based on the sampling done by FDB server. The sampling algorithm works roughly in this way: the larger the key-value pair is, the more likely it would be sampled and the more accurate its sampled size would be. And due to that reason it is recommended to use this API to query against large ranges for accuracy considerations. For a rough reference, if the returned size is larger than 3MB, one can consider the size to be accurate.</p>
</div>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> which will be set to the estimated size of the key range given. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_int64" title="fdb_future_get_int64"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_int64()</span></code></a> to extract the size, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_get_range_split_points">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_get_range_split_points</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;tr</em>, uint8_t const*<em>&nbsp;begin_key_name</em>, int<em>&nbsp;begin_key_name_length</em>, uint8_t const*<em>&nbsp;end_key_name</em>, int<em>&nbsp;end_key_name_length</em>, int64_t<em>&nbsp;chunk_size</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a list of keys that can split the given range into (roughly) equally sized chunks based on <code class="docutils literal"><span class="pre">chunk_size</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned split points contain the start key and end key of the given range</p>
</div>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> which will be set to the list of split points. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_key_array" title="fdb_future_get_key_array"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_key_array()</span></code></a> to extract the array, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_get_key">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_get_key</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, uint8_t const*<em>&nbsp;key_name</em>, int<em>&nbsp;key_name_length</em>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a><em>&nbsp;or_equal</em>, int<em>&nbsp;offset</em>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a><em>&nbsp;snapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Resolves a <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a> against the keys in the database snapshot represented by <code class="docutils literal"><span class="pre">transaction</span></code>.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> which will be set to the key in the database matching the <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a>. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_key" title="fdb_future_get_key"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_key()</span></code></a> to extract the key, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">key_name</span></code>, <code class="docutils literal"><span class="pre">key_name_length</span></code>, <code class="docutils literal"><span class="pre">or_equal</span></code>, <code class="docutils literal"><span class="pre">offset</span></code></dt>
<dd>The four components of a <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a>.</dd>
<dt><code class="docutils literal"><span class="pre">snapshot</span></code></dt>
<dd>Non-zero if this is a <a class="reference internal" href="#snapshots"><span class="std std-ref">snapshot read</span></a>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_get_addresses_for_key">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_get_addresses_for_key</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, uint8_t const*<em>&nbsp;key_name</em>, int<em>&nbsp;key_name_length</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a list of public network addresses as strings, one for each of the storage servers responsible for storing <code class="docutils literal"><span class="pre">key_name</span></code> and its associated value.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> which will be set to an array of strings. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_string_array" title="fdb_future_get_string_array"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_string_array()</span></code></a> to extract the string array, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">key_name</span></code></dt>
<dd>A pointer to the name of the key whose location is to be queried.</dd>
<dt><code class="docutils literal"><span class="pre">key_name_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">key_name</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_get_range">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_get_range</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, uint8_t const*<em>&nbsp;begin_key_name</em>, int<em>&nbsp;begin_key_name_length</em>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a><em>&nbsp;begin_or_equal</em>, int<em>&nbsp;begin_offset</em>, uint8_t const*<em>&nbsp;end_key_name</em>, int<em>&nbsp;end_key_name_length</em>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a><em>&nbsp;end_or_equal</em>, int<em>&nbsp;end_offset</em>, int<em>&nbsp;limit</em>, int<em>&nbsp;target_bytes</em>, <a class="reference internal" href="#c.FDBStreamingMode" title="FDBStreamingMode">FDBStreamingMode</a><em>&nbsp;mode</em>, int<em>&nbsp;iteration</em>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a><em>&nbsp;snapshot</em>, <a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a><em>&nbsp;reverse</em><span class="sig-paren">)</span></dt>
<dd><p>Reads all key-value pairs in the database snapshot represented by <code class="docutils literal"><span class="pre">transaction</span></code> (potentially limited by <code class="xref c c-data docutils literal"><span class="pre">limit</span></code>, <code class="xref c c-data docutils literal"><span class="pre">target_bytes</span></code>, or <code class="xref c c-data docutils literal"><span class="pre">mode</span></code>) which have a key lexicographically greater than or equal to the key resolved by the begin <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a> and lexicographically less than the key resolved by the end <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a>.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> which will be set to an <a class="reference internal" href="#c.FDBKeyValue" title="FDBKeyValue"><code class="xref c c-type docutils literal"><span class="pre">FDBKeyValue</span></code></a> array. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_keyvalue_array" title="fdb_future_get_keyvalue_array"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_keyvalue_array()</span></code></a> to extract the key-value array, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">begin_key_name</span></code>, <code class="xref c c-data docutils literal"><span class="pre">begin_key_name_length</span></code>, <code class="xref c c-data docutils literal"><span class="pre">begin_or_equal</span></code>, <code class="xref c c-data docutils literal"><span class="pre">begin_offset</span></code></dt>
<dd>The four components of a <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a> describing the beginning of the range.</dd>
<dt><code class="docutils literal"><span class="pre">end_key_name</span></code>, <code class="xref c c-data docutils literal"><span class="pre">end_key_name_length</span></code>, <code class="xref c c-data docutils literal"><span class="pre">end_or_equal</span></code>, <code class="xref c c-data docutils literal"><span class="pre">end_offset</span></code></dt>
<dd>The four components of a <a class="reference internal" href="#key-selectors"><span class="std std-ref">key selector</span></a> describing the end of the range.</dd>
<dt><code class="docutils literal"><span class="pre">limit</span></code></dt>
<dd>If non-zero, indicates the maximum number of key-value pairs to return. If this limit was reached before the end of the specified range, then the <code class="docutils literal"><span class="pre">*more</span></code> return of <a class="reference internal" href="#c.fdb_future_get_keyvalue_array" title="fdb_future_get_keyvalue_array"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_keyvalue_array()</span></code></a> will be set to a non-zero value.</dd>
<dt><code class="docutils literal"><span class="pre">target_bytes</span></code></dt>
<dd>If non-zero, indicates a (soft) cap on the combined number of bytes of keys and values to return. If this limit was reached before the end of the specified range, then the <code class="docutils literal"><span class="pre">*more</span></code> return of <a class="reference internal" href="#c.fdb_future_get_keyvalue_array" title="fdb_future_get_keyvalue_array"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_keyvalue_array()</span></code></a> will be set to a non-zero value.</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>One of the <a class="reference internal" href="#c.FDBStreamingMode" title="FDBStreamingMode"><code class="xref c c-type docutils literal"><span class="pre">FDBStreamingMode</span></code></a> values indicating how the caller would like the data in the range returned.</dd>
<dt><code class="docutils literal"><span class="pre">iteration</span></code></dt>
<dd>If <code class="docutils literal"><span class="pre">mode</span></code> is <code class="xref c c-data docutils literal"><span class="pre">FDB_STREAMING_MODE_ITERATOR</span></code>, this parameter should start at 1 and be incremented by 1 for each successive call while reading this range. In all other cases it is ignored.</dd>
<dt><code class="docutils literal"><span class="pre">snapshot</span></code></dt>
<dd>Non-zero if this is a <a class="reference internal" href="#snapshots"><span class="std std-ref">snapshot read</span></a>.</dd>
<dt><code class="docutils literal"><span class="pre">reverse</span></code></dt>
<dd>If non-zero, key-value pairs will be returned in reverse lexicographical order beginning at the end of the range. Reading ranges in reverse is supported natively by the database and should have minimal extra cost.</dd>
</dl>
</dd></dl>

<dl class="type">
<dt id="c.FDBStreamingMode">
<code class="descname">FDBStreamingMode</code></dt>
<dd><p>An enumeration of available streaming modes to be passed to <a class="reference internal" href="#c.fdb_transaction_get_range" title="fdb_transaction_get_range"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_get_range()</span></code></a>.</p>
<p><code class="docutils literal"><span class="pre">FDB_STREAMING_MODE_ITERATOR</span></code></p>
<p>The caller is implementing an iterator (most likely in a binding to a higher level language). The amount of data returned depends on the value of the <code class="docutils literal"><span class="pre">iteration</span></code> parameter to <a class="reference internal" href="#c.fdb_transaction_get_range" title="fdb_transaction_get_range"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_get_range()</span></code></a>.</p>
<p><code class="docutils literal"><span class="pre">FDB_STREAMING_MODE_SMALL</span></code></p>
<p>Data is returned in small batches (not much more expensive than reading individual key-value pairs).</p>
<p><code class="docutils literal"><span class="pre">FDB_STREAMING_MODE_MEDIUM</span></code></p>
<p>Data is returned in batches between _SMALL and _LARGE.</p>
<p><code class="docutils literal"><span class="pre">FDB_STREAMING_MODE_LARGE</span></code></p>
<p>Data is returned in batches large enough to be, in a high-concurrency environment, nearly as efficient as possible. If the caller does not need the entire range, some disk and network bandwidth may be wasted. The batch size may be still be too small to allow a single client to get high throughput from the database.</p>
<p><code class="docutils literal"><span class="pre">FDB_STREAMING_MODE_SERIAL</span></code></p>
<p>Data is returned in batches large enough that an individual client can get reasonable read bandwidth from the database. If the caller does not need the entire range, considerable disk and network bandwidth may be wasted.</p>
<p><code class="docutils literal"><span class="pre">FDB_STREAMING_MODE_WANT_ALL</span></code></p>
<p>The caller intends to consume the entire range and would like it all transferred as early as possible.</p>
<p><code class="docutils literal"><span class="pre">FDB_STREAMING_MODE_EXACT</span></code></p>
<p>The caller has passed a specific row limit and wants that many rows delivered in a single batch.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_set">
void <code class="descname">fdb_transaction_set</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, uint8_t const*<em>&nbsp;key_name</em>, int<em>&nbsp;key_name_length</em>, uint8_t const*<em>&nbsp;value</em>, int<em>&nbsp;value_length</em><span class="sig-paren">)</span></dt>
<dd><p>Modify the database snapshot represented by <code class="docutils literal"><span class="pre">transaction</span></code> to change the given key to have the given value. If the given key was not previously present in the database it is inserted.</p>
<p>The modification affects the actual database only if <code class="docutils literal"><span class="pre">transaction</span></code> is later committed with <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_commit()</span></code></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">key_name</span></code></dt>
<dd>A pointer to the name of the key to be inserted into the database. The value does not need to be NULL-terminated.</dd>
<dt><code class="docutils literal"><span class="pre">key_name_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">key_name</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">value</span></code></dt>
<dd>A pointer to the value to be inserted into the database. The value does not need to be NULL-terminated.</dd>
<dt><code class="docutils literal"><span class="pre">value_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">value</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_clear">
void <code class="descname">fdb_transaction_clear</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, uint8_t const*<em>&nbsp;key_name</em>, int<em>&nbsp;key_name_length</em><span class="sig-paren">)</span></dt>
<dd><p>Modify the database snapshot represented by <code class="docutils literal"><span class="pre">transaction</span></code> to remove the given key from the database. If the key was not previously present in the database, there is no effect.</p>
<p>The modification affects the actual database only if <code class="docutils literal"><span class="pre">transaction</span></code> is later committed with <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_commit()</span></code></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">key_name</span></code></dt>
<dd>A pointer to the name of the key to be removed from the database. The value does not need to be NULL-terminated.</dd>
<dt><code class="docutils literal"><span class="pre">key_name_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">key_name</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_clear_range">
void <code class="descname">fdb_transaction_clear_range</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, uint8_t const*<em>&nbsp;begin_key_name</em>, int<em>&nbsp;begin_key_name_length</em>, uint8_t const*<em>&nbsp;end_key_name</em>, int<em>&nbsp;end_key_name_length</em><span class="sig-paren">)</span></dt>
<dd><p>Modify the database snapshot represented by <code class="docutils literal"><span class="pre">transaction</span></code> to remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.</p>
<p>The modification affects the actual database only if <code class="docutils literal"><span class="pre">transaction</span></code> is later committed with <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_commit()</span></code></a>.</p>
<p>Range clears are efficient with FoundationDB &#8211; clearing large amounts of data will be fast. However, this will not immediately free up disk - data for the deleted range is cleaned up in the background. For purposes of computing the transaction size, only the begin and end keys of a clear range are counted. The size of the data stored in the range does not count against the transaction size limit.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">begin_key_name</span></code></dt>
<dd>A pointer to the name of the key specifying the beginning of the range to clear. The value does not need to be NULL-terminated.</dd>
<dt><code class="docutils literal"><span class="pre">begin_key_name_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">begin_key_name</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">end_key_name</span></code></dt>
<dd>A pointer to the name of the key specifying the end of the range to clear. The value does not need to be NULL-terminated.</dd>
<dt><code class="docutils literal"><span class="pre">end_key_name_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">end_key_name_length</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_atomic_op">
void <code class="descname">fdb_transaction_atomic_op</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, uint8_t const*<em>&nbsp;key_name</em>, int<em>&nbsp;key_name_length</em>, uint8_t const*<em>&nbsp;param</em>, int<em>&nbsp;param_length</em>, <a class="reference internal" href="#c.FDBMutationType" title="FDBMutationType">FDBMutationType</a><em>&nbsp;operationType</em><span class="sig-paren">)</span></dt>
<dd><p>Modify the database snapshot represented by <code class="docutils literal"><span class="pre">transaction</span></code> to perform the operation indicated by <code class="docutils literal"><span class="pre">operationType</span></code> with operand <code class="docutils literal"><span class="pre">param</span></code> to the value stored by the given key.</p>
<p>An atomic operation is a single database command that carries out several logical steps: reading the value of a key, performing a transformation on that value, and writing the result. Different atomic operations perform different transformations. Like other database operations, an atomic operation is used within a transaction; however, its use within a transaction will not cause the transaction to conflict.</p>
<p>Atomic operations do not expose the current value of the key to the client but simply send the database the transformation to apply. In regard to conflict checking, an atomic operation is equivalent to a write without a read. It can only cause <em>other</em> transactions performing reads of the key to conflict.</p>
<p>By combining these logical steps into a single, read-free operation, FoundationDB can guarantee that the transaction will not conflict due to the operation. This makes atomic operations ideal for operating on keys that are frequently modified. A common example is the use of a key-value pair as a counter.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If a transaction uses both an atomic operation and a strictly serializable read on the same key, the benefits of using the atomic operation (for both conflict checking and performance) are lost.</p>
</div>
<p>The modification affects the actual database only if <code class="docutils literal"><span class="pre">transaction</span></code> is later committed with <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_commit()</span></code></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">key_name</span></code></dt>
<dd>A pointer to the name of the key whose value is to be mutated.</dd>
<dt><code class="docutils literal"><span class="pre">key_name_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">key_name</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">param</span></code></dt>
<dd>A pointer to the parameter with which the atomic operation will mutate the value associated with <code class="docutils literal"><span class="pre">key_name</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">param_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">param</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">operation_type</span></code></dt>
<dd>One of the <a class="reference internal" href="#c.FDBMutationType" title="FDBMutationType"><code class="xref c c-type docutils literal"><span class="pre">FDBMutationType</span></code></a> values indicating which operation should be performed.</dd>
</dl>
</dd></dl>

<dl class="type">
<dt id="c.FDBMutationType">
<code class="descname">FDBMutationType</code></dt>
<dd><p>An enumeration of available opcodes to be passed to <a class="reference internal" href="#c.fdb_transaction_atomic_op" title="fdb_transaction_atomic_op"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_atomic_op()</span></code></a></p>
<p><code class="docutils literal"><span class="pre">FDB_MUTATION_TYPE_ADD</span></code></p>
<p>Performs an addition of little-endian integers. If the existing value in the database is not present or shorter than <code class="docutils literal"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal"><span class="pre">param</span></code> with zero bytes.  If <code class="docutils literal"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal"><span class="pre">param</span></code>. In case of overflow, the result is truncated to the width of <code class="docutils literal"><span class="pre">param</span></code>.</p>
<p>The integers to be added must be stored in a little-endian representation. They can be signed in two&#8217;s complement representation or unsigned. You can add to an integer at a known offset in the value by prepending the appropriate number of zero bytes to <code class="docutils literal"><span class="pre">param</span></code> and padding with zero bytes to match the length of the value. However, this offset technique requires that you know the addition will not cause the integer field within the value to overflow.</p>
<p><code class="docutils literal"><span class="pre">FDB_MUTATION_TYPE_AND</span></code></p>
<p>Performs a bitwise &#8220;and&#8221; operation. If the existing value in the database is not present, then <code class="docutils literal"><span class="pre">param</span></code> is stored in the database. If the existing value in the database is  shorter than <code class="docutils literal"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal"><span class="pre">param</span></code>.</p>
<p><code class="docutils literal"><span class="pre">FDB_MUTATION_TYPE_OR</span></code></p>
<p>Performs a bitwise &#8220;or&#8221; operation. If the existing value in the database is not present or shorter than <code class="docutils literal"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal"><span class="pre">param</span></code>.</p>
<p><code class="docutils literal"><span class="pre">FDB_MUTATION_TYPE_XOR</span></code></p>
<p>Performs a bitwise &#8220;xor&#8221; operation. If the existing value in the database is not present or shorter than <code class="docutils literal"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal"><span class="pre">param</span></code>.</p>
<p><code class="docutils literal"><span class="pre">FDB_MUTATION_TYPE_COMPARE_AND_CLEAR</span></code></p>
<p>Performs an atomic <code class="docutils literal"><span class="pre">compare</span> <span class="pre">and</span> <span class="pre">clear</span></code> operation. If the existing value in the database is equal to the given value, then given key is cleared.</p>
<p><code class="docutils literal"><span class="pre">FDB_MUTATION_TYPE_MAX</span></code></p>
<p>Sets the value in the database to the larger of the existing value and <code class="docutils literal"><span class="pre">param</span></code>. If the existing value in the database is not present or shorter than <code class="docutils literal"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal"><span class="pre">param</span></code>.</p>
<p>Both the existing value and <code class="docutils literal"><span class="pre">param</span></code> are treated as unsigned integers. (This differs from the behavior of atomic addition.)</p>
<p><code class="docutils literal"><span class="pre">FDB_MUTATION_TYPE_BYTE_MAX</span></code></p>
<p>Performs lexicographic comparison of byte strings. If the existing value in the database is not present, then <code class="docutils literal"><span class="pre">param</span></code> is stored. Otherwise the larger of the two values is then stored in the database.</p>
<p><code class="docutils literal"><span class="pre">FDB_MUTATION_TYPE_MIN</span></code></p>
<p>Sets the value in the database to the smaller of the existing value and <code class="docutils literal"><span class="pre">param</span></code>. If the existing value in the database is not present, then <code class="docutils literal"><span class="pre">param</span></code> is stored in the database. If the existing value in the database is shorter than <code class="docutils literal"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal"><span class="pre">param</span></code>.</p>
<p>Both the existing value and <code class="docutils literal"><span class="pre">param</span></code> are treated as unsigned integers. (This differs from the behavior of atomic addition.)</p>
<p><code class="docutils literal"><span class="pre">FDB_MUTATION_TYPE_BYTE_MIN</span></code></p>
<p>Performs lexicographic comparison of byte strings. If the existing value in the database is not present, then <code class="docutils literal"><span class="pre">param</span></code> is stored. Otherwise the smaller of the two values is then stored in the database.</p>
<p><code class="docutils literal"><span class="pre">FDB_MUTATION_TYPE_SET_VERSIONSTAMPED_KEY</span></code></p>
<p>Transforms <code class="docutils literal"><span class="pre">key</span></code> using a versionstamp for the transaction. This key must be at least 14 bytes long. The final 4 bytes will be interpreted as a 32-bit little-endian integer denoting an index into the key at which to perform the transformation, and then trimmed off the key. The 10 bytes in the key beginning at the index will be overwritten with the versionstamp. If the index plus 10 bytes points past the end of the key, the result will be an error. Sets the transformed key in the database to <code class="docutils literal"><span class="pre">param</span></code>.</p>
<p>A versionstamp is a 10 byte, unique, monotonically (but not sequentially) increasing value for each committed transaction. The first 8 bytes are the committed version of the database (serialized in big-endian order). The last 2 bytes are monotonic in the serialization order for transactions (serialized in big-endian order).</p>
<p>A transaction is not permitted to read any transformed key or value previously set within that transaction, and an attempt to do so will result in an <code class="docutils literal"><span class="pre">accessed_unreadable</span></code> error.  The range of keys marked unreadable when setting a versionstamped key begins at the transactions&#8217;s read version if it is known, otherwise a versionstamp of all <code class="docutils literal"><span class="pre">0x00</span></code> bytes is conservatively assumed.  The upper bound of the unreadable range is a versionstamp of all <code class="docutils literal"><span class="pre">0xFF</span></code> bytes.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">At this time, versionstamped keys are not compatible with the Tuple layer except in Java, Python, and Go. Note that this implies versionstamped keys may not be used with the Subspace and Directory layers except in those languages.</p>
</div>
<p><code class="docutils literal"><span class="pre">FDB_MUTATION_TYPE_SET_VERSIONSTAMPED_VALUE</span></code></p>
<p>Transforms <code class="docutils literal"><span class="pre">param</span></code> using a versionstamp for the transaction. This parameter must be at least 14 bytes long. The final 4 bytes will be interpreted as a 32-bit little-endian integer denoting an index into the parameter at which to perform the transformation, and then trimmed off the key. The 10 bytes in the parameter beginning at the index will be overwritten with the versionstamp. If the index plus 10 bytes points past the end of the parameter, the result will be an error. Sets <code class="docutils literal"><span class="pre">key</span></code> in the database to the transformed parameter.</p>
<p>A versionstamp is a 10 byte, unique, monotonically (but not sequentially) increasing value for each committed transaction. The first 8 bytes are the committed version of the database (serialized in big-endian order). The last 2 bytes are monotonic in the serialization order for transactions (serialized in big-endian order).</p>
<p>A transaction is not permitted to read any transformed key or value previously set within that transaction, and an attempt to do so will result in an <code class="docutils literal"><span class="pre">accessed_unreadable</span></code> error.  The range of keys marked unreadable when setting a versionstamped key begins at the transactions&#8217;s read version if it is known, otherwise a versionstamp of all <code class="docutils literal"><span class="pre">0x00</span></code> bytes is conservatively assumed.  The upper bound of the unreadable range is a versionstamp of all <code class="docutils literal"><span class="pre">0xFF</span></code> bytes.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">At this time, versionstamped values are not compatible with the Tuple layer except in Java, Python, and Go. Note that this implies versionstamped values may not be used with the Subspace and Directory layers except in those languages.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_commit">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_commit</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em><span class="sig-paren">)</span></dt>
<dd><p>Attempts to commit the sets and clears previously applied to the database snapshot represented by <code class="docutils literal"><span class="pre">transaction</span></code> to the actual database. The commit may or may not succeed &#8211; in particular, if a conflicting transaction previously committed, then the commit must fail in order to preserve transactional isolation. If the commit does succeed, the transaction is durably committed to the database and all subsequently started transactions will observe its effects.</p>
<p>It is not necessary to commit a read-only transaction &#8211; you can simply call <a class="reference internal" href="#c.fdb_transaction_destroy" title="fdb_transaction_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_destroy()</span></code></a>.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> representing an empty value. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>Callers will usually want to retry a transaction if the commit or a prior <code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_get_*()</span></code> returns a retryable error (see <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_on_error()</span></code></a>).</p>
<p>As with other client/server databases, in some failure scenarios a client may be unable to determine whether a transaction succeeded. In these cases, <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_commit()</span></code></a> will return a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> error. The <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_on_error()</span></code></a> function treats this error as retryable, so retry loops that don&#8217;t check for <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> could execute the transaction twice. In these cases, you must consider the idempotence of the transaction. For more information, see <a class="reference internal" href="developer-guide.html#developer-guide-unknown-results"><span class="std std-ref">Transactions with unknown results</span></a>.</p>
<p>Normally, commit will wait for outstanding reads to return. However, if those reads were snapshot reads or the transaction option for disabling &#8220;read-your-writes&#8221; has been invoked, any outstanding reads will immediately return errors.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_get_committed_version">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_transaction_get_committed_version</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, int64_t*<em>&nbsp;out_version</em><span class="sig-paren">)</span></dt>
<dd><p>Retrieves the database version number at which a given transaction was committed. <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_commit()</span></code></a> must have been called on <code class="docutils literal"><span class="pre">transaction</span></code> and the resulting future must be ready and not an error before this function is called, or the behavior is undefined. Read-only transactions do not modify the database when committed and will have a committed version of -1. Keep in mind that a transaction which reads keys and then sets them to their current values may be optimized to a read-only transaction.</p>
<p>Note that database versions are not necessarily unique to a given transaction and so cannot be used to determine in what order two transactions completed. The only use for this function is to manually enforce causal consistency when calling <a class="reference internal" href="#c.fdb_transaction_set_read_version" title="fdb_transaction_set_read_version"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_set_read_version()</span></code></a> on another subsequent transaction.</p>
<p>Most applications will not call this function.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_get_approximate_size">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_get_approximate_size</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em><span class="sig-paren">)</span></dt>
<dd><p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> which will be set to the approximate transaction size so far in the returned future, which is the summation of the estimated size of mutations, read conflict ranges, and write conflict ranges. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_int64" title="fdb_future_get_int64"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_int64()</span></code></a> to extract the size, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>This can be called multiple times before the transaction is committed.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_get_versionstamp">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_get_versionstamp</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em><span class="sig-paren">)</span></dt>
<dd><p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> which will be set to the versionstamp which was used by any versionstamp operations in this transaction. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, call <a class="reference internal" href="#c.fdb_future_get_key" title="fdb_future_get_key"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_get_key()</span></code></a> to extract the key, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>The future will be ready only after the successful completion of a call to <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_commit()</span></code></a> on this Transaction. Read-only transactions do not modify the database when committed and will result in the future completing with an error. Keep in mind that a transaction which reads keys and then sets them to their current values may be optimized to a read-only transaction.</p>
<p>Most applications will not call this function.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_watch">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_watch</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, uint8_t const*<em>&nbsp;key_name</em>, int<em>&nbsp;key_name_length</em><span class="sig-paren">)</span></dt>
<dd><p>A watch&#8217;s behavior is relative to the transaction that created it. A watch will report a change in relation to the key&#8217;s value as readable by that transaction. The initial value used for comparison is either that of the transaction&#8217;s read version or the value as modified by the transaction itself prior to the creation of the watch. If the value changes and then changes back to its initial value, the watch might not report the change.</p>
<p>Until the transaction that created it has been committed, a watch will not report changes made by <em>other</em> transactions. In contrast, a watch will immediately report changes made by the transaction itself. Watches cannot be created if the transaction has set the READ_YOUR_WRITES_DISABLE <a class="reference internal" href="#c.fdb_transaction_set_option" title="fdb_transaction_set_option"><code class="xref c c-func docutils literal"><span class="pre">transaction</span> <span class="pre">option</span></code></a>, and an attempt to do so will return an <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">watches_disabled</span></a> error.</p>
<p>If the transaction used to create a watch encounters an error during commit, then the watch will be set with that error. A transaction whose <a class="reference internal" href="developer-guide.html#developer-guide-unknown-results"><span class="std std-ref">commit result is unknown</span></a> will set all of its watches with the <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> error. If an uncommitted transaction is reset or destroyed, then any watches it created will be set with the <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">transaction_cancelled</span></a> error.</p>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> representing an empty value that will be set once the watch has detected a change to the value at the specified key. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
<p>By default, each database connection can have no more than 10,000 watches that have not yet reported a change. When this number is exceeded, an attempt to create a watch will return a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">too_many_watches</span></a> error. This limit can be changed using the MAX_WATCHES <a class="reference internal" href="#c.fdb_database_set_option" title="fdb_database_set_option"><code class="xref c c-func docutils literal"><span class="pre">database</span> <span class="pre">option</span></code></a>. Because a watch outlives the transaction that creates it, any watch that is no longer needed should be cancelled by calling <a class="reference internal" href="#c.fdb_future_cancel" title="fdb_future_cancel"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_cancel()</span></code></a> on its returned future.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">key_name</span></code></dt>
<dd>A pointer to the name of the key to watch. The value does not need to be NULL-terminated.</dd>
<dt><code class="docutils literal"><span class="pre">key_name_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">key_name</span></code>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_on_error">
<a class="reference internal" href="#c.FDBFuture" title="FDBFuture">FDBFuture</a>* <code class="descname">fdb_transaction_on_error</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, <a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a><em>&nbsp;error</em><span class="sig-paren">)</span></dt>
<dd><p>Implements the recommended retry and backoff behavior for a transaction. This function knows which of the error codes generated by other <code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_*()</span></code> functions represent temporary error conditions and which represent application errors that should be handled by the application. It also implements an exponential backoff strategy to avoid swamping the database cluster with excessive retries when there is a high level of conflict between transactions.</p>
<p>On receiving any type of error from an <code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_*()</span></code> function, the application should:</p>
<ol class="arabic simple">
<li>Call <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_on_error()</span></code></a> with the returned <a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t"><code class="xref c c-type docutils literal"><span class="pre">fdb_error_t</span></code></a> code.</li>
<li>Wait for the resulting future to be ready.</li>
<li>If the resulting future is itself an error, destroy the future and FDBTransaction and report the error in an appropriate way.</li>
<li>If the resulting future is not an error, destroy the future and restart the application code that performs the transaction. The transaction itself will have already been reset to its initial state, but should not be destroyed and re-created because state used by <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_on_error()</span></code></a> to implement its backoff strategy and state related to timeouts and retry limits is stored there.</li>
</ol>
<p>Returns an <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> representing an empty value. You must first wait for the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> to be ready, check for errors, and then destroy the <a class="reference internal" href="#c.FDBFuture" title="FDBFuture"><code class="xref c c-type docutils literal"><span class="pre">FDBFuture</span></code></a> with <a class="reference internal" href="#c.fdb_future_destroy" title="fdb_future_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_future_destroy()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_reset">
void <code class="descname">fdb_transaction_reset</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em><span class="sig-paren">)</span></dt>
<dd><p>Reset <code class="docutils literal"><span class="pre">transaction</span></code> to its initial state. This is similar to calling <a class="reference internal" href="#c.fdb_transaction_destroy" title="fdb_transaction_destroy"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_destroy()</span></code></a> followed by <a class="reference internal" href="#c.fdb_database_create_transaction" title="fdb_database_create_transaction"><code class="xref c c-func docutils literal"><span class="pre">fdb_database_create_transaction()</span></code></a>. It is not necessary to call <a class="reference internal" href="#c.fdb_transaction_reset" title="fdb_transaction_reset"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_reset()</span></code></a> when handling an error with <a class="reference internal" href="#c.fdb_transaction_on_error" title="fdb_transaction_on_error"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_on_error()</span></code></a> since the transaction has already been reset.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_transaction_cancel">
void <code class="descname">fdb_transaction_cancel</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em><span class="sig-paren">)</span></dt>
<dd><p>Cancels the transaction. All pending or future uses of the transaction will return a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">transaction_cancelled</span></a> error. The transaction can be used again after it is <a class="reference internal" href="#c.fdb_transaction_reset" title="fdb_transaction_reset"><code class="xref c c-func docutils literal"><span class="pre">reset</span></code></a>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Be careful if you are using <a class="reference internal" href="#c.fdb_transaction_reset" title="fdb_transaction_reset"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_reset()</span></code></a> and <a class="reference internal" href="#c.fdb_transaction_cancel" title="fdb_transaction_cancel"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_cancel()</span></code></a> concurrently with the same transaction. Since they negate each other&#8217;s effects, a race condition between these calls will leave the transaction in an unknown state.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If your program attempts to cancel a transaction after <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_commit()</span></code></a> has been called but before it returns, unpredictable behavior will result. While it is guaranteed that the transaction will eventually end up in a cancelled state, the commit may or may not occur. Moreover, even if the call to <a class="reference internal" href="#c.fdb_transaction_commit" title="fdb_transaction_commit"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_commit()</span></code></a> appears to return a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">transaction_cancelled</span></a> error,  the commit may have occurred or may occur in the future. This can make it more difficult to reason about the order in which transactions occur.</p>
</div>
</dd></dl>

<span class="target" id="conflictranges"></span><dl class="function">
<dt id="c.fdb_transaction_add_conflict_range">
<a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a> <code class="descname">fdb_transaction_add_conflict_range</code><span class="sig-paren">(</span><a class="reference internal" href="#c.FDBTransaction" title="FDBTransaction">FDBTransaction</a>*<em>&nbsp;transaction</em>, uint8_t const*<em>&nbsp;begin_key_name</em>, int<em>&nbsp;begin_key_name_length</em>, uint8_t const*<em>&nbsp;end_key_name</em>, int<em>&nbsp;end_key_name_length</em>, <a class="reference internal" href="#c.FDBConflictRangeType" title="FDBConflictRangeType">FDBConflictRangeType</a><em>&nbsp;type</em><span class="sig-paren">)</span></dt>
<dd><p>Adds a <a class="reference internal" href="developer-guide.html#conflict-ranges"><span class="std std-ref">conflict range</span></a> to a transaction without performing the associated read or write.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Most applications will use the strictly serializable isolation that transactions provide by default and will not need to manipulate conflict ranges.</p>
</div>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">begin_key_name</span></code></dt>
<dd>A pointer to the name of the key specifying the beginning of the conflict range. The value does not need to be NULL-terminated.</dd>
<dt><code class="docutils literal"><span class="pre">begin_key_name_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">begin_key_name</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">end_key_name</span></code></dt>
<dd>A pointer to the name of the key specifying the end of the conflict range. The value does not need to be NULL-terminated.</dd>
<dt><code class="docutils literal"><span class="pre">end_key_name_length</span></code></dt>
<dd>The length of the parameter specified by <code class="docutils literal"><span class="pre">end_key_name_length</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>One of the <a class="reference internal" href="#c.FDBConflictRangeType" title="FDBConflictRangeType"><code class="xref c c-type docutils literal"><span class="pre">FDBConflictRangeType</span></code></a> values indicating what type of conflict range is being set.</dd>
</dl>
</dd></dl>

<dl class="type">
<dt id="c.FDBConflictRangeType">
<code class="descname">FDBConflictRangeType</code></dt>
<dd><p>An enumeration of available conflict range types to be passed to <a class="reference internal" href="#c.fdb_transaction_add_conflict_range" title="fdb_transaction_add_conflict_range"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_add_conflict_range()</span></code></a>.</p>
<p><code class="docutils literal"><span class="pre">FDB_CONFLICT_RANGE_TYPE_READ</span></code></p>
<p>Adds a range of keys to the transaction&#8217;s read conflict ranges as if you had read the range. As a result, other transactions that write a key in this range could cause the transaction to fail with a conflict.</p>
<p><code class="docutils literal"><span class="pre">FDB_CONFLICT_RANGE_TYPE_WRITE</span></code></p>
<p>Adds a range of keys to the transaction&#8217;s write conflict ranges as if you had cleared the range. As a result, other transactions that concurrently read a key in this range could fail with a conflict.</p>
</dd></dl>

<div class="section" id="snapshot-reads">
<span id="snapshots"></span><h3>Snapshot reads</h3>
<p>Snapshot reads selectively relax FoundationDB&#8217;s isolation property, reducing <a class="reference internal" href="developer-guide.html#developer-guide-transaction-conflicts"><span class="std std-ref">conflicts</span></a> but making it harder to reason about concurrency.</p>
<p>By default, FoundationDB transactions guarantee <a class="reference internal" href="developer-guide.html#acid"><span class="std std-ref">strictly serializable isolation</span></a>, resulting in a state that is <em>as if</em> transactions were executed one at a time, even if they were executed concurrently. Serializability has little performance cost when there are few <a class="reference internal" href="developer-guide.html#developer-guide-transaction-conflicts"><span class="std std-ref">conflicts</span></a> but can be expensive when there are many. FoundationDB therefore also permits individual reads within a transaction to be done as snapshot reads.</p>
<p>Snapshot reads differ from ordinary (strictly serializable) reads by permitting the values they read to be modified by concurrent transactions, whereas strictly serializable reads cause conflicts in that case. Like strictly serializable reads, snapshot reads see the effects of prior writes in the same transaction. For more information on the use of snapshot reads, see <a class="reference internal" href="developer-guide.html#snapshot-isolation"><span class="std std-ref">Snapshot reads</span></a>.</p>
<p>In the C API, snapshot reads are performed by passing a non-zero value to the <code class="docutils literal"><span class="pre">snapshot</span></code> parameter of any of <code class="docutils literal"><span class="pre">fdb_transaction_get_*</span></code> (see for example <a class="reference internal" href="#c.fdb_transaction_get" title="fdb_transaction_get"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_get()</span></code></a>).  Snapshot reads also interact with transaction commit a little differently than normal reads. If a snapshot read is outstanding when transaction commit is called that read will immediately return an error. (Normally, transaction commit will wait until outstanding reads return before committing.)</p>
</div>
</div>
<div class="section" id="key-selectors">
<span id="id1"></span><h2>Key selectors</h2>
<p>FoundationDB&#8217;s lexicographically ordered data model permits finding keys based on their order (for example, finding the first key in the database greater than a given key). Key selectors represent a description of a key in the database that could be resolved to an actual key by <a class="reference internal" href="#c.fdb_transaction_get_key" title="fdb_transaction_get_key"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_get_key()</span></code></a> or used directly as the beginning or end of a range in <a class="reference internal" href="#c.fdb_transaction_get_range" title="fdb_transaction_get_range"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_get_range()</span></code></a>.</p>
<p>For more about how key selectors work, see <a class="reference internal" href="developer-guide.html#key-selectors"><span class="std std-ref">Key selectors</span></a>.</p>
<p>In the FoundationDB C API, key selectors are not represented by a structure of any kind, but are instead expressed as sequential parameters to <a class="reference internal" href="#c.fdb_transaction_get_key" title="fdb_transaction_get_key"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_get_key()</span></code></a> and <a class="reference internal" href="#c.fdb_transaction_get_range" title="fdb_transaction_get_range"><code class="xref c c-func docutils literal"><span class="pre">fdb_transaction_get_range()</span></code></a>. For convenience, the most common key selectors are available as C macros that expand to the appropriate parameters.</p>
<dl class="function">
<dt id="c.FDB_KEYSEL_LAST_LESS_THAN">
<code class="descname">FDB_KEYSEL_LAST_LESS_THAN</code><span class="sig-paren">(</span>key_name, key_name_length<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.FDB_KEYSEL_LAST_LESS_OR_EQUAL">
<code class="descname">FDB_KEYSEL_LAST_LESS_OR_EQUAL</code><span class="sig-paren">(</span>key_name, key_name_length<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.FDB_KEYSEL_FIRST_GREATER_THAN">
<code class="descname">FDB_KEYSEL_FIRST_GREATER_THAN</code><span class="sig-paren">(</span>key_name, key_name_length<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.FDB_KEYSEL_FIRST_GREATER_OR_EQUAL">
<code class="descname">FDB_KEYSEL_FIRST_GREATER_OR_EQUAL</code><span class="sig-paren">(</span>key_name, key_name_length<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p>To use one of these macros, simply replace the four parameters in the function with one of <code class="xref c c-func docutils literal"><span class="pre">FDB_KEYSEL_*()</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdb_transaction_get_key</span><span class="p">(</span><span class="n">transaction</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;key&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>could instead be written as:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdb_transaction_get_key</span><span class="p">(</span><span class="n">transaction</span><span class="p">,</span><span class="w"> </span><span class="n">FDB_KEYSEL_FIRST_GREATER_THAN</span><span class="p">(</span><span class="s">&quot;key&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="miscellaneous">
<h2>Miscellaneous</h2>
<dl class="type">
<dt id="c.fdb_bool_t">
<code class="descname">fdb_bool_t</code></dt>
<dd><p>An integer type representing a boolean. A value of 0 is false and non-zero is true.</p>
</dd></dl>

<dl class="type">
<dt id="c.fdb_error_t">
<code class="descname">fdb_error_t</code></dt>
<dd><p>An integer type representing an error. A value of 0 is success and non-zero is an error.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_get_error">
const char* <code class="descname">fdb_get_error</code><span class="sig-paren">(</span><a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a><em>&nbsp;code</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a (somewhat) human-readable English message from an error code. The return value is a statically allocated null-terminated string that <em>must not</em> be freed by the caller.</p>
</dd></dl>

<dl class="function">
<dt id="c.fdb_error_predicate">
<a class="reference internal" href="#c.fdb_bool_t" title="fdb_bool_t">fdb_bool_t</a> <code class="descname">fdb_error_predicate</code><span class="sig-paren">(</span>int<em>&nbsp;predicate_test</em>, <a class="reference internal" href="#c.fdb_error_t" title="fdb_error_t">fdb_error_t</a><em>&nbsp;code</em><span class="sig-paren">)</span></dt>
<dd><p>Evaluates a predicate against an error code. The predicate to run should be one of the codes listed by the <code class="docutils literal"><span class="pre">FDBErrorPredicate</span></code> enum defined within <code class="docutils literal"><span class="pre">fdb_c_options.g.h</span></code>. Sample predicates include <code class="docutils literal"><span class="pre">FDB_ERROR_PREDICATE_RETRYABLE</span></code>, which can be used to determine whether the error with the given code is a retryable error or not.</p>
</dd></dl>

</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/api-c.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2013-2021 Apple, Inc and the FoundationDB project authors.<br/>
      Last updated on Nov 08, 2022.<br/>
    </p>
  </div>
</footer>
  </body>
</html>