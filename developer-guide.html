<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Developer Guide &#8212; FoundationDB 7.2</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-sphinx.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Data Modeling" href="data-modeling.html" />
    <link rel="prev" title="Downloads" href="downloads.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          FoundationDB</a>
        <span class="navbar-text navbar-version pull-left"><b>7.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="contents.html">Site Map</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="local-dev.html">Local Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="internal-dev-tools.html">Internal Dev Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="why-foundationdb.html">Why FoundationDB</a><ul>
<li class="toctree-l2"><a class="reference internal" href="transaction-manifesto.html">Transaction Manifesto</a></li>
<li class="toctree-l2"><a class="reference internal" href="cap-theorem.html">CAP Theorem</a></li>
<li class="toctree-l2"><a class="reference internal" href="consistency.html">Consistency</a></li>
<li class="toctree-l2"><a class="reference internal" href="scalability.html">Scalability</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="technical-overview.html">Technical Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="architecture.html">Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance.html">Performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="benchmarking.html">Benchmarking</a></li>
<li class="toctree-l2"><a class="reference internal" href="engineering.html">Engineering</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="layer-concept.html">Layer Concept</a></li>
<li class="toctree-l2"><a class="reference internal" href="anti-features.html">Anti-Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="transaction-processing.html">Transaction Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="fault-tolerance.html">Fault Tolerance</a></li>
<li class="toctree-l2"><a class="reference internal" href="flow.html">Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="testing.html">Simulation and Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="kv-architecture.html">FoundationDB Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="read-write-path.html">FDB Read and Write Path</a></li>
<li class="toctree-l2"><a class="reference internal" href="ha-write-path.html">FDB HA Write Path: How a mutation travels in FDB HA</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="client-design.html">Client Design</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="getting-started-mac.html">Getting Started on macOS</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting-started-linux.html">Getting Started on Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="downloads.html">Downloads</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Developer Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-modeling.html">Data Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="client-testing.html">Client Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="client-testing.html#testing-error-handling-with-buggify">Testing Error Handling with Buggify</a></li>
<li class="toctree-l2"><a class="reference internal" href="client-testing.html#simulation-and-cluster-workloads">Simulation and Cluster Workloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="client-testing.html#api-tester">API Tester</a></li>
<li class="toctree-l2"><a class="reference internal" href="api-general.html">Using FoundationDB Clients</a></li>
<li class="toctree-l2"><a class="reference internal" href="transaction-tagging.html">Transaction Tagging</a></li>
<li class="toctree-l2"><a class="reference internal" href="known-limitations.html">Known Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="transaction-profiler-analyzer.html">Transaction profiling and analyzing</a></li>
<li class="toctree-l2"><a class="reference internal" href="api-version-upgrade-guide.html">API Version Upgrade Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenants.html">Tenants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="design-recipes.html">Design Recipes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="blob.html">Blob</a></li>
<li class="toctree-l2"><a class="reference internal" href="blob-java.html">Blob</a></li>
<li class="toctree-l2"><a class="reference internal" href="hierarchical-documents.html">Hierarchical Documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="hierarchical-documents-java.html">Hierarchical Documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="multimaps.html">Multimaps</a></li>
<li class="toctree-l2"><a class="reference internal" href="multimaps-java.html">Multimaps</a></li>
<li class="toctree-l2"><a class="reference internal" href="priority-queues.html">Priority Queues</a></li>
<li class="toctree-l2"><a class="reference internal" href="priority-queues-java.html">Priority Queues</a></li>
<li class="toctree-l2"><a class="reference internal" href="queues.html">Queues</a></li>
<li class="toctree-l2"><a class="reference internal" href="queues-java.html">Queues</a></li>
<li class="toctree-l2"><a class="reference internal" href="segmented-range-reads.html">Segmented Range Reads</a></li>
<li class="toctree-l2"><a class="reference internal" href="segmented-range-reads-java.html">Segmented Range Reads</a></li>
<li class="toctree-l2"><a class="reference internal" href="simple-indexes.html">Simple Indexes</a></li>
<li class="toctree-l2"><a class="reference internal" href="simple-indexes-java.html">Simple Indexes</a></li>
<li class="toctree-l2"><a class="reference internal" href="spatial-indexing.html">Spatial Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="spatial-indexing-java.html">Spatial Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="subspace-indirection.html">Subspace Indirection</a></li>
<li class="toctree-l2"><a class="reference internal" href="subspace-indirection-java.html">Subspace Indirection</a></li>
<li class="toctree-l2"><a class="reference internal" href="tables.html">Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="tables-java.html">Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="vector.html">Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="vector-java.html">Vector</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api-python.html">Python API</a></li>
<li class="toctree-l2"><a class="reference internal" href="api-ruby.html">Ruby API</a></li>
<li class="toctree-l2"><a class="reference external" href="relative://javadoc/index.html">Java API</a></li>
<li class="toctree-l2"><a class="reference external" href="https://godoc.org/github.com/apple/foundationdb/bindings/go/src/fdb">Go API</a></li>
<li class="toctree-l2"><a class="reference internal" href="api-c.html">C API</a></li>
<li class="toctree-l2"><a class="reference internal" href="api-error-codes.html">Error Codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="special-keys.html">Special Keys</a></li>
<li class="toctree-l2"><a class="reference internal" href="global-configuration.html">Global Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="class-scheduling.html">Class Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="largeval.html">Managing Large Values and Blobs</a></li>
<li class="toctree-l2"><a class="reference internal" href="time-series.html">Time-Series Data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="administration.html">Administration</a><ul>
<li class="toctree-l2"><a class="reference internal" href="configuration.html">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="moving-a-cluster.html">Moving a Cluster to New Machines</a></li>
<li class="toctree-l2"><a class="reference internal" href="tls.html">Transport Layer Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="authorization.html">Authorization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="monitored-metrics.html"><strong>Monitored Metrics</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="redwood.html">Redwood Storage Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="visibility.html">Visibility Documents</a><ul>
<li class="toctree-l2"><a class="reference internal" href="request-tracing.html">Request Tracing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="earlier-release-notes.html">Earlier Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-014.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-016.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-021.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-022.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-023.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-100.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-200.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-300.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-400.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-410.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-420.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-430.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-440.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-450.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-460.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-500.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-510.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-520.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-600.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-610.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-620.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-630.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-700.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-710.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="release-notes/release-notes-720.html">Release Notes</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Developer Guide</a><ul>
<li><a class="reference internal" href="#data-model">Data model</a></li>
<li><a class="reference internal" href="#namespace-management">Namespace management</a><ul>
<li><a class="reference internal" href="#subspaces">Subspaces</a></li>
<li><a class="reference internal" href="#directories">Directories</a><ul>
<li><a class="reference internal" href="#usage">Usage</a></li>
<li><a class="reference internal" href="#subdirectories-and-nested-subspaces">Subdirectories and nested subspaces</a></li>
<li><a class="reference internal" href="#directory-partitions">Directory partitions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tenants">Tenants</a><ul>
<li><a class="reference internal" href="#tenants-and-directories">Tenants and directories</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-the-apis">Working with the APIs</a><ul>
<li><a class="reference internal" href="#key-selectors">Key selectors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#transaction-basics">Transaction basics</a><ul>
<li><a class="reference internal" href="#transactions-in-foundationdb">Transactions in FoundationDB</a></li>
<li><a class="reference internal" href="#transaction-retry-loops">Transaction retry loops</a></li>
<li><a class="reference internal" href="#programming-with-futures">Programming with futures</a></li>
<li><a class="reference internal" href="#range-reads">Range reads</a></li>
<li><a class="reference internal" href="#long-running-transactions">Long-running transactions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-transactions">Working with transactions</a><ul>
<li><a class="reference internal" href="#atomic-operations">Atomic operations</a></li>
<li><a class="reference internal" href="#transactions-with-unknown-results">Transactions with unknown results</a></li>
<li><a class="reference internal" href="#conflict-ranges">Conflict ranges</a></li>
<li><a class="reference internal" href="#snapshot-reads">Snapshot reads</a></li>
<li><a class="reference internal" href="#transaction-cancellation">Transaction cancellation</a></li>
<li><a class="reference internal" href="#watches">Watches</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance-considerations">Performance considerations</a><ul>
<li><a class="reference internal" href="#latency">Latency</a></li>
<li><a class="reference internal" href="#throughput-requires-concurrency">Throughput requires concurrency</a></li>
<li><a class="reference internal" href="#minimizing-conflicts">Minimizing conflicts</a></li>
<li><a class="reference internal" href="#key-and-value-sizes">Key and value sizes</a></li>
<li><a class="reference internal" href="#loading-data">Loading data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-details">Implementation Details</a><ul>
<li><a class="reference internal" href="#how-foundationdb-detects-conflicts">How FoundationDB Detects Conflicts</a><ul>
<li><a class="reference internal" href="#how-versions-are-generated-and-assigned">How Versions are Generated and Assigned</a></li>
<li><a class="reference internal" href="#conflict-detection">Conflict Detection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#error-handling">Error Handling</a><ul>
<li><a class="reference internal" href="#errors-where-we-know-the-state-of-the-transaction">Errors where we know the State of the Transaction</a></li>
<li><a class="reference internal" href="#the-commit-unknown-result-error">The <code class="docutils literal notranslate"><span class="pre">commit_unknown_result</span></code> Error</a></li>
<li><a class="reference internal" href="#non-retryable-errors">Non-Retryable Errors</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="downloads.html" title="Previous Chapter: Downloads"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Downloads</span>
    </a>
  </li>
  <li>
    <a href="data-modeling.html" title="Next Chapter: Data Modeling"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Data Modeling &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">Developer Guide</a><ul>
<li><a class="reference internal" href="#data-model">Data model</a></li>
<li><a class="reference internal" href="#namespace-management">Namespace management</a><ul>
<li><a class="reference internal" href="#subspaces">Subspaces</a></li>
<li><a class="reference internal" href="#directories">Directories</a><ul>
<li><a class="reference internal" href="#usage">Usage</a></li>
<li><a class="reference internal" href="#subdirectories-and-nested-subspaces">Subdirectories and nested subspaces</a></li>
<li><a class="reference internal" href="#directory-partitions">Directory partitions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tenants">Tenants</a><ul>
<li><a class="reference internal" href="#tenants-and-directories">Tenants and directories</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-the-apis">Working with the APIs</a><ul>
<li><a class="reference internal" href="#key-selectors">Key selectors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#transaction-basics">Transaction basics</a><ul>
<li><a class="reference internal" href="#transactions-in-foundationdb">Transactions in FoundationDB</a></li>
<li><a class="reference internal" href="#transaction-retry-loops">Transaction retry loops</a></li>
<li><a class="reference internal" href="#programming-with-futures">Programming with futures</a></li>
<li><a class="reference internal" href="#range-reads">Range reads</a></li>
<li><a class="reference internal" href="#long-running-transactions">Long-running transactions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-transactions">Working with transactions</a><ul>
<li><a class="reference internal" href="#atomic-operations">Atomic operations</a></li>
<li><a class="reference internal" href="#transactions-with-unknown-results">Transactions with unknown results</a></li>
<li><a class="reference internal" href="#conflict-ranges">Conflict ranges</a></li>
<li><a class="reference internal" href="#snapshot-reads">Snapshot reads</a></li>
<li><a class="reference internal" href="#transaction-cancellation">Transaction cancellation</a></li>
<li><a class="reference internal" href="#watches">Watches</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance-considerations">Performance considerations</a><ul>
<li><a class="reference internal" href="#latency">Latency</a></li>
<li><a class="reference internal" href="#throughput-requires-concurrency">Throughput requires concurrency</a></li>
<li><a class="reference internal" href="#minimizing-conflicts">Minimizing conflicts</a></li>
<li><a class="reference internal" href="#key-and-value-sizes">Key and value sizes</a></li>
<li><a class="reference internal" href="#loading-data">Loading data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-details">Implementation Details</a><ul>
<li><a class="reference internal" href="#how-foundationdb-detects-conflicts">How FoundationDB Detects Conflicts</a><ul>
<li><a class="reference internal" href="#how-versions-are-generated-and-assigned">How Versions are Generated and Assigned</a></li>
<li><a class="reference internal" href="#conflict-detection">Conflict Detection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#error-handling">Error Handling</a><ul>
<li><a class="reference internal" href="#errors-where-we-know-the-state-of-the-transaction">Errors where we know the State of the Transaction</a></li>
<li><a class="reference internal" href="#the-commit-unknown-result-error">The <code class="docutils literal notranslate"><span class="pre">commit_unknown_result</span></code> Error</a></li>
<li><a class="reference internal" href="#non-retryable-errors">Non-Retryable Errors</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <section id="developer-guide">
<h1>Developer Guide</h1>
<p>FoundationDB’s scalability and performance make it an ideal back end for supporting the operation of critical applications. FoundationDB provides a simple data model coupled with powerful transactional integrity. This document gives an overview of application development using FoundationDB, including use of the API, working with transactions, and performance considerations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For operational advice about how to setup and maintain a FoundationDB cluster, see <a class="reference internal" href="administration.html"><span class="doc">Administration</span></a>.</p>
</div>
<section id="data-model">
<h2>Data model</h2>
<p>FoundationDB’s core data model is an ordered key-value store. Also known as an ordered associative array, map, or dictionary, this is a data structure composed of a collection of key-value pairs in which all keys are unique and ordered. Both keys and values in FoundationDB are simple byte strings. Apart from storage and retrieval, the database does not interpret or depend on the content of values. In contrast, keys are treated as members of a total order, the lexicographic order over the underlying bytes, in which keys are sorted by each byte in order.</p>
<p>The combination of the core data model and multikey transactions allows an application to build richer data models and libraries that inherit FoundationDB’s scalability, performance, and integrity. Richer data models are designed by mapping the application’s data to keys and values in a way that yields an effective abstraction and enables efficient storage and retrieval.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For guidance on mapping richer data models to FoundationDB’s core, see <a class="reference internal" href="data-modeling.html"><span class="doc">Data Modeling</span></a>.</p>
</div>
</section>
<section id="namespace-management">
<span id="developer-guide-namespace-management"></span><h2>Namespace management</h2>
<p>The keys in FoundationDB’s key-value store can be viewed as elements of a single, global keyspace. Your application will probably have multiple kinds of data to store, and it’s a good idea to separate them into different <a class="reference external" href="http://en.wikipedia.org/wiki/Namespace_(computer_science)">namespaces</a>. The use of distinct namespaces will allow you to avoid conflicts among keys as your application grows.</p>
<p>Because of the ordering of keys, a namespace in FoundationDB is defined by any prefix prepended to keys. For example, if we use a prefix <code class="docutils literal notranslate"><span class="pre">'alpha'</span></code>, any key of the form <code class="docutils literal notranslate"><span class="pre">'alpha'</span> <span class="pre">+</span> <span class="pre">remainder</span></code> will be nested under <code class="docutils literal notranslate"><span class="pre">'alpha'</span></code>. Although you can manually manage prefixes, it is more convenient to use the <a class="reference internal" href="data-modeling.html#data-modeling-tuples"><span class="std std-ref">tuple layer</span></a>. To define a namespace with the tuple layer, just create a tuple <code class="docutils literal notranslate"><span class="pre">(namespace_id)</span></code> with an identifier for the namespace. You can add a new key <code class="docutils literal notranslate"><span class="pre">(foo,</span> <span class="pre">bar)</span></code> to the namespace by extending the tuple: <code class="docutils literal notranslate"><span class="pre">(namespace_id,</span> <span class="pre">foo,</span> <span class="pre">bar)</span></code>. You can also create nested namespaces by extending your tuple with another namespace identifier: <code class="docutils literal notranslate"><span class="pre">(namespace_id,</span> <span class="pre">nested_id)</span></code>. The tuple layer automatically encodes each of these tuple as a byte string that preserves its intended order.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#developer-guide-sub-keyspaces"><span class="std std-ref">Subspaces</span></a> employ the tuple layer to provide a convenient syntax for namespaces.</p>
</div>
<section id="subspaces">
<span id="developer-guide-sub-keyspaces"></span><h3>Subspaces</h3>
<p>Subspaces provide the recommended way to define <a class="reference internal" href="#developer-guide-namespace-management"><span class="std std-ref">namespaces</span></a> for different categories of data. As a best practice, you should always use at least one subspace as a namespace for your application data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While subspaces can be used directly, they are also returned when creating or opening a <a class="reference internal" href="#developer-guide-directories"><span class="std std-ref">directory</span></a>. Directories are designed to manage related subspaces.</p>
</div>
<p>Each FoundationDB language binding provides a <a class="reference internal" href="api-python.html#api-python-subspaces"><span class="std std-ref">Subspace class</span></a> to help use subspaces uniformly. An instance of the class stores a prefix used to identify the namespace and automatically prepends it when encoding tuples into keys. Likewise, it removes the prefix when decoding keys. A subspace can be initialized by supplying it with a prefix tuple:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_space</span> <span class="o">=</span> <span class="n">Subspace</span><span class="p">(</span><span class="n">prefix_tuple</span><span class="p">)</span>
</pre></div>
</div>
<p>It can also optionally take a byte string as a prefix element that will be prepended to all keys packed by the subspace:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_space</span> <span class="o">=</span> <span class="n">Subspace</span><span class="p">(</span><span class="n">prefix_tuple</span><span class="p">,</span> <span class="n">prefix_element</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A subspace formed with a byte string as a prefix element is not fully compatible with the tuple layer. Keys stored within it cannot be unpacked as tuples.</p>
</div>
<p>In many of the language bindings, index notation can be used on a subspace to create a nested subspace. The new subspace will have the same prefix extended by the index value:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_space</span> <span class="o">=</span> <span class="n">Subspace</span><span class="p">((</span><span class="s1">&#39;foo&#39;</span><span class="p">,))</span>

<span class="c1"># new_space will have prefix tuple (&#39;foo&#39;, &#39;bar&#39;)</span>
<span class="n">new_space</span> <span class="o">=</span> <span class="n">my_space</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Subspace</span></code> methods will then work as expected for <code class="docutils literal notranslate"><span class="pre">new_space</span></code>, with its prefix nested within that of <code class="docutils literal notranslate"><span class="pre">my_space</span></code>.</p>
<p>For example, suppose your application tracks profile data for your users. You could store the data in a <code class="docutils literal notranslate"><span class="pre">user_space</span></code> subspace that would make <code class="docutils literal notranslate"><span class="pre">'user'</span></code> the first element of each tuple. A back-end function might have the form:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">user_space</span> <span class="o">=</span> <span class="n">Subspace</span><span class="p">((</span><span class="s1">&#39;user&#39;</span><span class="p">,))</span>

<span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">set_user_data</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">tr</span><span class="p">[</span><span class="n">user_space</span><span class="o">.</span><span class="n">pack</span><span class="p">((</span><span class="n">key</span><span class="p">,))]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>Subspaces support the <a class="reference internal" href="api-python.html#api-python-keys"><span class="std std-ref">as_foundationdb_key</span></a> method to implicitly pack keys, so you could also write the <code class="docutils literal notranslate"><span class="pre">set_user_data</span></code> as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">set_user_data</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">tr</span><span class="p">[</span><span class="n">user_space</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, you may want to clear a subspace before working with it (as long as you’re sure it should be empty):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">clear_subspace</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">subspace</span><span class="p">):</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">clear_range_startswith</span><span class="p">(</span><span class="n">subspace</span><span class="o">.</span><span class="n">key</span><span class="p">())</span>
</pre></div>
</div>
</section>
<section id="directories">
<span id="developer-guide-directories"></span><h3>Directories</h3>
<p>FoundationDB provides <a class="reference internal" href="api-python.html#api-python-directories"><span class="std std-ref">directories</span></a> (available in each language binding) as a tool for managing related <a class="reference internal" href="#developer-guide-sub-keyspaces"><span class="std std-ref">subspaces</span></a>. Directories are a recommended approach for administering applications. Each application should create or open at least one directory to manage its subspaces.</p>
<p>Directories are identified by hierarchical paths analogous to the paths in a Unix-like file system. A path is represented as a tuple of strings. Each directory has an associated subspace used to store its content. The directory layer maps each path to a short prefix used for the corresponding subspace. In effect, directories provide a level of indirection for access to subspaces.</p>
<p>This design has significant benefits: while directories are logically hierarchical as represented by their paths, their subspaces are not physically nested in a corresponding way. For example, suppose we create a few directories with increasing paths, such as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;bravo&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;bravo&#39;</span><span class="p">,</span> <span class="s1">&#39;charlie&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>The prefixes of <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code> are allocated independently and will usually not increase in length. The indirection from paths to subspaces allows keys to be kept short and makes it fast to move directories (i.e., rename their paths).</p>
<p>Paths in the directory layer are always relative. In particular, paths are interpreted relative to the directory in which an operation is performed. For example, we could have created the directories <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code> as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;bravo&#39;</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;charlie&#39;</span><span class="p">,))</span>
</pre></div>
</div>
<p>We can easily check that the resulting paths are the same as before:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
<span class="go">(u&#39;alpha&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
<span class="go">(u&#39;alpha&#39;, u&#39;bravo&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
<span class="go">(u&#39;alpha&#39;, u&#39;bravo&#39;, u&#39;charlie&#39;)</span>
</pre></div>
</div>
<section id="usage">
<h4>Usage</h4>
<p>The directory layer exposes a <code class="docutils literal notranslate"><span class="pre">DirectoryLayer</span></code> class and a ready-to-use instance of it that you can access as <code class="docutils literal notranslate"><span class="pre">fdb.directory</span></code>. You can also create your own instance, which allows you to specify your own prefix for a subspace. For example, in Python, you could use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dir_layer</span> <span class="o">=</span> <span class="n">DirectoryLayer</span><span class="p">(</span><span class="n">content_subspace</span> <span class="o">=</span> <span class="n">Subspace</span><span class="p">(</span><span class="n">rawPrefix</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\x01</span><span class="s1">&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>You can use a <code class="docutils literal notranslate"><span class="pre">DirectoryLayer</span></code> instance to create a new directory, specifying its path as a tuple. The <code class="docutils literal notranslate"><span class="pre">create</span></code> method returns a newly created directory:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">users</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">users</span>
<span class="go">DirectorySubspace(path=(u&#39;users&#39;,), prefix=&#39;\x157&#39;)</span>
</pre></div>
</div>
<p>A directory returned by <code class="docutils literal notranslate"><span class="pre">create</span></code> is a <code class="docutils literal notranslate"><span class="pre">DirectorySubspace</span></code> that fulfills the interface of both a <code class="docutils literal notranslate"><span class="pre">DirectoryLayer</span></code> and a <code class="docutils literal notranslate"><span class="pre">Subspace</span></code>. Therefore, the directory can be used to access subdirectories recursively:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inactive</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;inactive&#39;</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inactive</span>
<span class="go">DirectorySubspace(path=(u&#39;users&#39;, u&#39;inactive&#39;), prefix=&#39;\x15&amp;&#39;)</span>
</pre></div>
</div>
<p>The directory can also be used as a subspace to store content:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">db</span><span class="p">[</span><span class="n">users</span><span class="p">[</span><span class="s1">&#39;Smith&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</pre></div>
</div>
<p>The directory layer uses a high-contention allocator to efficiently map the path to a short prefix for the directory’s subspace.</p>
<p>If the directory was created previously (e.g., in a prior session or by another client), you can open it via its path. Like <code class="docutils literal notranslate"><span class="pre">create</span></code>, the <code class="docutils literal notranslate"><span class="pre">open</span></code> method returns a directory:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">users</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,))</span>
</pre></div>
</div>
<p>It’s often convenient to use a combined <code class="docutils literal notranslate"><span class="pre">create_or_open</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">products</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">create_or_open</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;products&#39;</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orders</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">create_or_open</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;orders&#39;</span><span class="p">,))</span>
</pre></div>
</div>
<p>As noted above, all of the operations defined for a <code class="docutils literal notranslate"><span class="pre">DirectoryLayer</span></code> can also be called on a directory to operate on its subdirectories:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cancelled_orders</span> <span class="o">=</span> <span class="n">orders</span><span class="o">.</span><span class="n">create_or_open</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;cancelled&#39;</span><span class="p">,))</span>
</pre></div>
</div>
<p>Once created, directory paths can be changed using <code class="docutils literal notranslate"><span class="pre">move</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">store</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">create_or_open</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;store&#39;</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">users</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="s1">&#39;users&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">products</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;products&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="s1">&#39;products&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>A directory path can also be changed via its subspace using <code class="docutils literal notranslate"><span class="pre">move_to</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">orders</span> <span class="o">=</span> <span class="n">orders</span><span class="o">.</span><span class="n">move_to</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="s1">&#39;orders&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>You can list the subdirectories of a directory. <code class="docutils literal notranslate"><span class="pre">list</span></code> returns directory names (the unicode string for the last component of the path), not subspaces or their contents:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="go">[u&#39;store&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">store</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="c1"># or fdb.directory.list(db, (&#39;store&#39;,))</span>
<span class="go">[u&#39;orders&#39;, u&#39;products&#39;, u&#39;users&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">store</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;orders&#39;</span><span class="p">))</span>
<span class="go">[u&#39;cancelled&#39;]</span>
</pre></div>
</div>
<p>Directories can be removed, with or without a prior test for existence:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">remove_if_exists</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="s1">&#39;temp&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">users</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
</pre></div>
</div>
<p>Although <code class="docutils literal notranslate"><span class="pre">create_or_open</span></code> and <code class="docutils literal notranslate"><span class="pre">remove_if_exists</span></code> cover the most common cases, you can also explicitly test for the existence of a directory:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">users</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">store</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;products&#39;</span><span class="p">,))</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
<section id="subdirectories-and-nested-subspaces">
<h4>Subdirectories and nested subspaces</h4>
<p>It’s common to have a subset of data that we want to arrange hierarchically under a directory. We can do this in two ways: by creating a subdirectory or a nested subspace. Let’s return to our <code class="docutils literal notranslate"><span class="pre">users</span></code> directory for a closer look.</p>
<p>We may have data that is logically subordinate to our primary data but needs to be handled distinctly. For example, suppose we have inactive users that we want to store separately from our regular users. We could create a subdirectory for them:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inactive</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;inactive&#39;</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inactive</span>
<span class="go">DirectorySubspace(path=(u&#39;users&#39;, u&#39;inactive&#39;), prefix=&#39;\x15&amp;&#39;)</span>
</pre></div>
</div>
<p>A subdirectory’s data is stored under a prefix unrelated to that of its parent, which allows the prefix to be kept short and makes the subdirectory fast and easy to move. The managed prefix also makes it harder to jointly access data across subdirectories (e.g., you cannot usefully perform a range read across subdirectories).</p>
<p>Conversely, we often have data that we want to access as part of a single data set. For example, suppose we want <code class="docutils literal notranslate"><span class="pre">users</span></code> to store a <code class="docutils literal notranslate"><span class="pre">user_ID</span></code> and related attributes. We could nest a subspace for <code class="docutils literal notranslate"><span class="pre">'ID'</span></code> under <code class="docutils literal notranslate"><span class="pre">users</span></code> and store each attribute beneath it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">db</span><span class="p">[</span> <span class="n">users</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">][</span><span class="n">user_ID</span><span class="p">][</span><span class="n">lastname</span><span class="p">][</span><span class="n">firstname</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</pre></div>
</div>
<p>Here, we’re just employing <code class="docutils literal notranslate"><span class="pre">users</span></code> as a subspace, so all of the data modeling techniques using <a class="reference internal" href="#developer-guide-sub-keyspaces"><span class="std std-ref">subspaces</span></a> are available. Of course, data stored in a nested subspace cannot be moved as easily as a subdirectory.</p>
</section>
<section id="directory-partitions">
<h4>Directory partitions</h4>
<p>Under normal operation, a directory does not share a common key prefix with its subdirectories. As a result, related directories are not necessarily located together in key-space. This means that you cannot use a single range query to read all contents of a directory and its descendants simultaneously, for example.</p>
<p>For most applications this behavior is acceptable, but in some cases it may be useful to have a directory tree in your hierarchy where every directory shares a common prefix. For this purpose, the directory layer supports creating <em>partitions</em> within a directory. A partition is a directory whose prefix is prepended to all of its descendant directories’ prefixes.</p>
<p>A partition can be created by specifying the byte string ‘partition’ for the layer parameter:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">partition</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">directory</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;p1&#39;</span><span class="p">,),</span> <span class="n">layer</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;partition&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">users</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">create_or_open</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,))</span>
</pre></div>
</div>
<p>Directory partitions have the following drawbacks, and in general they should not be used unless specifically needed:</p>
<ul class="simple">
<li><p>Directories cannot be moved between different partitions.</p></li>
<li><p>Directories in a partition have longer prefixes than their counterparts outside of partitions, which reduces performance. Nesting partitions inside of other partitions results in even longer prefixes.</p></li>
<li><p>The root directory of a partition cannot be used to pack/unpack keys and therefore cannot be used to create subspaces. You must create at least one subdirectory of a partition in order to store content in it.</p></li>
</ul>
</section>
</section>
<section id="tenants">
<h3>Tenants</h3>
<p><a class="reference internal" href="tenants.html"><span class="doc">Tenants</span></a> in FoundationDB provide a way to divide the cluster key-space into named transaction domains. Each tenant has a byte-string name that can be used to open transactions on the tenant’s data, and tenant transactions are not permitted to access data outside of the tenant. Tenants can be useful for enforcing separation between unrelated use-cases.</p>
<section id="tenants-and-directories">
<h4>Tenants and directories</h4>
<p>Because tenants enforce that transactions operate within the tenant boundaries, it is not recommended to use a global directory layer shared between tenants. It is possible, however, to use the directory layer within each tenant. To do so, simply use the directory layer as normal with tenant transactions.</p>
</section>
</section>
</section>
<section id="working-with-the-apis">
<h2>Working with the APIs</h2>
<p>FoundationDB supports client APIs for Python, Ruby, Node.js, Java, Go, and C. At a high level, each of these APIs support transactions allowing a client to:</p>
<ul class="simple">
<li><p>Set a key-value pair</p></li>
<li><p>Get the value associated with a key</p></li>
<li><p>Resolve a <a class="reference internal" href="#system-keys"><span class="std std-ref">key selector</span></a> to a key</p></li>
<li><p>Get a range of key-value pairs (The range can be specified with keys or with key selectors)</p></li>
<li><p>Clear a key (and its associated value)</p></li>
<li><p>Clear a range of keys (and their values)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For details on the language-specific APIs, see the corresponding document under <a class="reference internal" href="api-reference.html"><span class="doc">API Reference</span></a>.</p>
</div>
<div class="admonition note" id="system-keys">
<p class="admonition-title">Note</p>
<p>All keys that start with the byte <code class="docutils literal notranslate"><span class="pre">0xFF</span></code> (255) are reserved for internal system use and should not be modified by the user. They cannot be read or written in a transaction unless it sets the <code class="docutils literal notranslate"><span class="pre">ACCESS_SYSTEM_KEYS</span></code> transaction option. Note that, among many other options, simply prepending a single zero-byte to all user-specified keys will avoid the reserved range and create a clean key space.</p>
</div>
<section id="key-selectors">
<span id="id1"></span><h3>Key selectors</h3>
<p>FoundationDB’s lexicographically ordered data model permits finding keys based on their order (for example, finding the first key in the database greater than a given key). Key selectors represent a description of a key in the database that could be resolved to an actual key by get_key() or used directly as the beginning or end of a range in get_range().</p>
<p>Each language API exposes constructors for four common forms of key selector. For example, in Python:</p>
<dl class="simple">
<dt>last_less_than(key)</dt><dd><p>The lexicographically greatest key present in the database which is lexicographically strictly less than the given byte string key.</p>
</dd>
<dt>last_less_or_equal(key)</dt><dd><p>The lexicographically greatest key present in the database which is lexicographically less than or equal to the given byte string key.</p>
</dd>
<dt>first_greater_than(key)</dt><dd><p>The lexicographically least key present in the database which is lexicographically strictly greater than the given byte string key.</p>
</dd>
<dt>first_greater_or_equal(key)</dt><dd><p>The lexicographically least key present in the database which is lexicographically greater than or equal to the given byte string key.</p>
</dd>
</dl>
<p>For example, suppose you want to read a range from a <code class="docutils literal notranslate"><span class="pre">begin</span></code> key to an <code class="docutils literal notranslate"><span class="pre">end</span></code> key <em>inclusive</em>. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.get_range()</span></code> method returns a range <em>exclusive</em> of its end key, so we can use a key selector to retrieve the desired range:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">get_range</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">fdb</span><span class="o">.</span><span class="n">KeySelector</span><span class="o">.</span><span class="n">first_greater_than</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
</pre></div>
</div>
<p>You can add or subtract an offset to or from a key selector. For example, in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fdb</span><span class="o">.</span><span class="n">KeySelector</span><span class="o">.</span><span class="n">first_greater_than</span><span class="p">(</span><span class="s1">&#39;apple&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>selects the second key following apple.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The current version of FoundationDB <em>does not</em> resolve key selectors with large offsets in O(1) time. See the <a class="reference internal" href="known-limitations.html#dont-use-key-selectors-for-paging"><span class="std std-ref">Key selectors with large offsets are slow</span></a> known limitation.</p>
</div>
<p>All possible key selectors can be constructed using one of the four “common form” constructors and a positive or negative offset.  Alternatively, general key selectors can be manually constructed by specifying:</p>
<ol class="arabic simple">
<li><p>A reference key</p></li>
<li><p>An equality flag (boolean)</p></li>
<li><p>An offset (integer)</p></li>
</ol>
<p>To “resolve” these key selectors FoundationDB first finds the last key less than the reference key (or equal to the reference key, if the equality flag is true), then moves forward a number of keys equal to the offset (or backwards, if the offset is negative). If a key selector would otherwise describe a key off the beginning of the database (before the first key), it instead resolves to the empty key <code class="docutils literal notranslate"><span class="pre">''</span></code>. If it would otherwise describe a key off the end of the database (after the last key), it instead resolves to the key <code class="docutils literal notranslate"><span class="pre">'\xFF'</span></code> (or <code class="docutils literal notranslate"><span class="pre">'\xFF\xFF'</span></code> if the transaction has been granted access to the system keys).</p>
</section>
</section>
<section id="transaction-basics">
<h2>Transaction basics</h2>
<section id="transactions-in-foundationdb">
<h3>Transactions in FoundationDB</h3>
<p>FoundationDB provides concurrency control via transactions, allowing multiple clients to concurrently read and write data in the database with strong guarantees about how they affect each other. Specifically, FoundationDB provides global, ACID transactions with strict serializability using optimistic concurrency.</p>
<p>All reads and modifications of key-value pairs in FoundationDB are done within the context of a transaction. A transaction is a small unit of work that is both reliably performed and logically independent of other transactions.</p>
<p>In Python, a simple transaction looks like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="n">tr</span><span class="p">):</span>
    <span class="c1"># Read two values from the database</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="c1"># Write two key-value pairs to the database</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>

<span class="n">example</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
</pre></div>
</div>
<p>Once a call to the <code class="docutils literal notranslate"><span class="pre">example()</span></code> function returns, it is as if all “gets” and “sets” inside it happened at a single instant (at some point after <code class="docutils literal notranslate"><span class="pre">example()</span></code> was called and before it returned). If it <em>never</em> returns (suffers a power failure, raises an exception, etc.) then it is either as if the “get” and “set” methods all happened at an instantaneous point in time, or as if none of them happened.</p>
<p id="acid">This ensures the following properties, known collectively as “ACID”:</p>
<ul class="simple">
<li><p><strong>Atomicity</strong>: Either all of the writes in the transaction happen, or none of them happen.</p></li>
<li><p><strong>Consistency</strong>: If each individual transaction maintains a database invariant (for example, from above, that the <code class="docutils literal notranslate"><span class="pre">'c'</span></code> and <code class="docutils literal notranslate"><span class="pre">'d'</span></code> keys  always have the same value), then the invariant is maintained even when multiple transactions are modifying the database concurrently.</p></li>
<li><p><strong>Isolation</strong>: It is as if transactions executed one at a time (serializability).</p></li>
<li><p><strong>Durability</strong>: Once a transaction succeeds, its writes will not be lost despite any failures or network partitions.</p></li>
</ul>
<p>An additional important property, though technically not part of ACID, is also guaranteed:</p>
<ul class="simple">
<li><p><strong>Causality</strong>: A transaction is guaranteed to see the effects of all other transactions that commit before it begins.</p></li>
</ul>
<p>FoundationDB implements these properties using multiversion concurrency control (MVCC) for reads and optimistic concurrency for writes. As a result, neither reads nor writes are blocked by other readers or writers. Instead, conflicting transactions will fail at commit time and will usually be retried by the client.</p>
<p>In particular, the reads in a transaction take place from an instantaneous snapshot of the database. From the perspective of the transaction this snapshot is not modified by the writes of other, concurrent transactions. When the read-write transaction is ready to be committed (read-only transactions don’t get committed and therefore never conflict), the FoundationDB cluster checks that it does not conflict with any previously committed transaction (i.e. that no value read by a transaction has been modified by another transaction since the read occurred) and, if it does conflict, rejects it. Rejected conflicting transactions are usually retried by the client. Accepted transactions are written to disk on multiple cluster nodes and then reported accepted to the client.</p>
<ul class="simple">
<li><p>For more background on transactions, see Wikipedia articles for <a class="reference external" href="http://en.wikipedia.org/wiki/Database_transaction">Database transaction</a>, <a class="reference external" href="http://en.wikipedia.org/wiki/Atomicity_(database_systems)">Atomicity (database systems)</a>, and <a class="reference external" href="http://en.wikipedia.org/wiki/Concurrency_control">Concurrency Control</a>.</p></li>
</ul>
</section>
<section id="transaction-retry-loops">
<h3>Transaction retry loops</h3>
<p>In most client APIs, there is a way of encapsulating a block of code as part of a transaction. For example, in Python, the <code class="docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code> decorator encapsulates retrying errors for the client. Here is a more detailed view of what the encapsulation does:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">example_encapsulated</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="c1"># make a new Transaction object on the database</span>
    <span class="n">tr</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">create_transaction</span><span class="p">()</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Read two values from the transaction snapshot</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
            <span class="c1"># Write two key-value pairs to the transaction snapshot</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>

            <span class="c1"># Try to commit the transaction, and wait for the result</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

            <span class="c1"># Success!</span>
            <span class="k">return</span>
        <span class="k">except</span> <span class="n">fdb</span><span class="o">.</span><span class="n">FDBError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="c1"># The transaction conflicted or there was a transient failure.</span>
            <span class="c1"># Ask the FDB API whether and when to retry the error</span>
            <span class="c1"># (Also resets the tr object to be ready to use again)</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">on_error</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that, while the <code class="docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code> decorator encapsulates an entire function, only the database operations it contains are part of the transaction and enjoy enforcement of ACID properties. Operations that mutate client memory (e.g., ordinary variable assignments or changes to data structures) are not “rolled back” when a transaction conflicts. You should place such operations outside of the retry loop unless it is acceptable for them to be executed when a transaction conflicts and is retried. See <a class="reference internal" href="#developer-guide-unknown-results"><span class="std std-ref">Transactions with unknown results</span></a> for an example.</p>
</section>
<section id="programming-with-futures">
<span id="developer-guide-programming-with-futures"></span><h3>Programming with futures</h3>
<p>Many of FoundationDB’s API functions are <em>asynchronous</em>: rather than blocking the calling thread until the result is available they immediately return a <em>future</em> object. A future represents a value (or error) to be available at some later time.</p>
<p>For languages in which it’s supported, the simplest approach to futures is implicit blocking. This involves using the future as if it were an object of the result type. For example, the following Python code uses futures to do multiple read operations in parallel, thereby reducing transaction latency. The reads of the ‘A’ and ‘B’ keys will be done in parallel because <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are futures:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># tr is a transaction</span>
<span class="c1"># Read two values from the database in parallel</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</pre></div>
</div>
<p>The addition of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> implicitly blocks. You can also explicitly block on a future
until it’s ready.</p>
<p>By default, FoundationDB supports read-your-writes, meaning that reads reflect the results of prior writes within a transaction. FoundationDB maximizes parallelism of database operations within a transaction, subject to enforcing the sequential semantics of those operations, such as when a key is written before it is read.</p>
<p>Another approach to programming with futures in FoundationDB is to set a callback function to be invoked asynchronously when the future is ready.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be very careful when mixing callbacks with explicit or implicit blocking. Blocking in a callback on a non-ready future will cause a deadlock. Blocking on anything else or performing CPU intensive tasks will block the FoundationDB <a class="reference internal" href="api-general.html#client-network-thread"><span class="std std-ref">client thread</span></a> and therefore all database access from that client.</p>
</div>
<p>For further details, see the <a class="reference internal" href="api-reference.html"><span class="doc">API reference</span></a> documentation for your language.</p>
</section>
<section id="range-reads">
<span id="developer-guide-range-reads"></span><h3>Range reads</h3>
<p>FoundationDB supports efficient range reads based on the lexicographic ordering of keys. Range reads are a powerful technique commonly used with FoundationDB. A recommended approach is to design your keys so that you can use range reads to retrieve your most frequently accessed data.</p>
<p>A range read within a transaction returns a container that issues asynchronous reads to the database. The client usually processes the data by iterating over the values returned by the container. Range reads can be specified explicitly by giving the <code class="docutils literal notranslate"><span class="pre">begin</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> of a range:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">get_range</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>To define ranges that extend from the beginning the database, you can use the empty string <code class="docutils literal notranslate"><span class="pre">''</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">get_range</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>Likewise, to define ranges that extend to the end of the database, you can use the key <code class="docutils literal notranslate"><span class="pre">'\xFF'</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">get_range</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\xFF</span><span class="s1">&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>A range read can also retrieve all keys starting with a given <code class="docutils literal notranslate"><span class="pre">prefix</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">get_range_startswith</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>The API balances latency and bandwidth by fetching data in batches as determined by the <a class="reference internal" href="api-python.html#streaming-mode-python"><span class="std std-ref">streaming mode</span></a> parameter. Streaming modes allow you to customize this balance based on how you intend to consume the data. The default streaming mode (<code class="docutils literal notranslate"><span class="pre">iterator</span></code>) is quite efficient. However, if you anticipate that your range read will retrieve a large amount of data, you should select a streaming mode to match your use case. For example, if you’re iterating through a large range and testing against a condition that may result in early termination, you may want to use the <code class="docutils literal notranslate"><span class="pre">small</span></code> streaming mode:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">get_range_startswith</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">streaming_mode</span><span class="o">=</span><span class="n">fdb</span><span class="o">.</span><span class="n">StreamingMode</span><span class="o">.</span><span class="n">small</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">halting_condition</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span> <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>In some situations, you may want to explicitly control the number of key-value pairs returned. You can use the <code class="docutils literal notranslate"><span class="pre">limit</span></code> parameter for this purpose. For example, suppose you want to iterate through a range while retrieving blocks of a predetermined size:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">LIMIT</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># adjust according to data characteristics</span>

<span class="k">def</span> <span class="nf">get_range_limited</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">keys_found</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">keys_found</span><span class="p">:</span>
        <span class="n">keys_found</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">get_range</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">LIMIT</span><span class="p">):</span>
            <span class="n">keys_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keys_found</span><span class="p">:</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">KeySelector</span><span class="o">.</span><span class="n">first_greater_than</span><span class="p">(</span><span class="n">keys_found</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">yield</span> <span class="n">keys_found</span>
</pre></div>
</div>
<p>For very large range reads, you can use multiple clients to perform reads concurrently. In this case, you’ll want to estimate sub-ranges of roughly equal size based on the distribution of your keys. The <a class="reference internal" href="api-python.html#api-python-locality"><span class="std std-ref">locality</span></a> functions can be used to derive estimates for the boundaries between sub-ranges.</p>
</section>
<section id="long-running-transactions">
<span id="developer-guide-long-transactions"></span><h3>Long-running transactions</h3>
<p>FoundationDB does not support long-running transactions, currently defined as
those lasting over five seconds. The reasons for this design limitation relate
to multiversion concurrency control and are discussed in <a class="reference internal" href="anti-features.html"><span class="doc">Anti-Features</span></a>.</p>
<p>You may have certain large operations that you’re accustomed to implementing as
long-running transactions with another database. How should you approach implementing
your operation in FoundationDB?</p>
<p>The key consideration is whether your operation requires global consistency over
all its data elements. In many cases, some smaller scope of consistency is acceptable.
For example, many analytic computations are defined over a set of entities, such
as users, and require consistency only for each entity, not globally across them.
In this case, you can decompose the operation into multiple transactions, one for
each entity. More generally, the strategy for operations requiring local consistency
is to decompose them into a set of short transactions.</p>
<p>If your operation really does require global consistency, you can often use
an indirection strategy. Here, you write a separate version of the data during
the course of the operation and switch to the new version when
the operation is done. The switch can be performed transactionally with a single
change of a reference.</p>
<p>For example, you can store the version reference using a <code class="docutils literal notranslate"><span class="pre">'mostRecentVersion'</span></code>
key:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">setMostRecentVersion</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">versionNumber</span><span class="p">):</span>
    <span class="n">tr</span><span class="p">[</span><span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">pack</span><span class="p">((</span><span class="s1">&#39;mostRecentVersion&#39;</span><span class="p">,))]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">versionNumber</span><span class="p">)</span>

<span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">getMostRecentVersion</span><span class="p">(</span><span class="n">tr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tr</span><span class="p">[</span><span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">pack</span><span class="p">((</span><span class="s1">&#39;mostRecentVersion&#39;</span><span class="p">,))]</span>
</pre></div>
</div>
<p>Your application would then store the relevant data using keys that encode the
version number. The application would read data with a transaction that reads the
most recent version number and uses it to reference the correct data. This
strategy has the advantage of allowing consistent access to the current version
of the data while concurrently writing the new version.</p>
</section>
</section>
<section id="working-with-transactions">
<h2>Working with transactions</h2>
<section id="atomic-operations">
<span id="developer-guide-atomic-operations"></span><h3>Atomic operations</h3>
<p>An atomic operation is a single database command that carries out several logical steps: reading the value of a key, performing a transformation on that value, and writing the result. Different atomic operations perform different transformations. Like other database operations, an atomic operation is used within a transaction; however, its use within a transaction will not cause the transaction to conflict.</p>
<p>Atomic operations are ideal for operating on keys that multiple clients modify frequently. For example, you can use a key as a counter and increment/decrement it with atomic <code class="xref py py-func docutils literal notranslate"><span class="pre">add()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">counter</span><span class="p">):</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">decrement</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">counter</span><span class="p">):</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>When the counter value is decremented down to 0, you may want to clear the key from database. An easy way to do that is to use <code class="xref py py-func docutils literal notranslate"><span class="pre">compare_and_clear()</span></code>, which atomically compares the value against given parameter and clears it without issuing a read from client:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">decrement</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">counter</span><span class="p">):</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">compare_and_clear</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>Similarly, you can use a key as a flag and toggle it with atomic <code class="xref py py-func docutils literal notranslate"><span class="pre">xor()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">toggle</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;=?&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Each atomic operation takes a packed string as an argument (as detailed in the <a class="reference internal" href="api-python.html#api-python-transaction-atomic-operations"><span class="std std-ref">API reference</span></a>).</p>
<p>Atomic operations do not expose the current value of the key to the client but simply send the database the transformation to apply. In regard to conflict checking, an atomic operation is equivalent to a write without a read. It can only cause <em>other</em> transactions performing reads of the key to conflict. By combining its logical steps into a single, read-free operation, FoundationDB can guarantee that the transaction performing the atomic operation will not conflict due to that operation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a transaction uses both an atomic operation and a strictly serializable read on the same key, the benefits of using the atomic operation (for both conflict checking and performance) are lost.</p>
</div>
</section>
<section id="transactions-with-unknown-results">
<span id="developer-guide-unknown-results"></span><h3>Transactions with unknown results</h3>
<p>As with other client/server databases, in some failure scenarios a client may be unable to determine whether a transaction succeeded. In these cases, <code class="docutils literal notranslate"><span class="pre">commit()</span></code> will raise a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> exception. The <code class="docutils literal notranslate"><span class="pre">on_error()</span></code> function treats this exception as retryable, so retry loops that don’t check for <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> could execute the transaction twice. In these cases, you must consider the idempotence of the transaction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Python <code class="docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code> decorator and its counterparts in the other language APIs do not check for <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a>.</p>
</div>
<p>An <em>idempotent</em> transaction is one that has the same effect when committed twice as when committed once. If your transaction is already idempotent, there is nothing more to worry about. Otherwise, you should consider whether it is acceptable for your transaction to be committed twice. The following suggestions are useful for making your transaction idempotent:</p>
<ul class="simple">
<li><p>Avoid generating IDs within the retry loop. Instead, create them prior to the loop and pass them in. For example, if your transaction records an account deposit with a deposit ID, generate the deposit ID outside of the loop.</p></li>
<li><p>Within the retry loop, check for the completion of one of the transaction’s unique side effects to determine if the whole transaction has previously completed. If the transaction doesn’t naturally have such a side effect, you can create one by setting a unique key.</p></li>
</ul>
<p>The following example illustrates both techniques. Together, they make a transaction idempotent that otherwise would not have been:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Increases account balance and stores a record of the deposit with a unique depositId</span>
<span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">acctId</span><span class="p">,</span> <span class="n">depositId</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>

    <span class="c1"># If the deposit record exists, the deposit already succeeded, and we can quit</span>
    <span class="n">depositKey</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">pack</span><span class="p">((</span><span class="s1">&#39;account&#39;</span><span class="p">,</span> <span class="n">acctId</span><span class="p">,</span> <span class="n">depositId</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">tr</span><span class="p">[</span><span class="n">depositKey</span><span class="p">]</span><span class="o">.</span><span class="n">present</span><span class="p">():</span> <span class="k">return</span>

    <span class="n">amount</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
    <span class="n">tr</span><span class="p">[</span><span class="n">depositKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">amount</span>

    <span class="c1"># The above check ensures that the balance update is executed only once</span>
    <span class="n">balanceKey</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">pack</span><span class="p">((</span><span class="s1">&#39;account&#39;</span><span class="p">,</span> <span class="n">acctId</span><span class="p">))</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">balanceKey</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="conflict-ranges">
<span id="id2"></span><h3>Conflict ranges</h3>
<p>By default, FoundationDB transactions guarantee <a class="reference internal" href="#acid"><span class="std std-ref">strict serializability</span></a>, which results in a state that <em>could</em> have been produced by executing transactions one at a time, even though they may actually have been executed concurrently. FoundationDB maintains strict serializability by detecting conflicts among concurrent transactions and allowing only a non-conflicting subset of them to succeed. Two concurrent transactions conflict if the first to commit writes a value that the second reads. In this case, the second transaction will fail. Clients will usually retry failed transactions.</p>
<p>To detect conflicts, FoundationDB tracks the ranges of keys each transaction reads and writes. While most applications will use the strictly serializable isolation that transactions provide by default, FoundationDB also provides several API features that manipulate conflict ranges to allow more precise control.</p>
<p>Conflicts can be <em>avoided</em>, reducing isolation, in two ways:</p>
<ul class="simple">
<li><p>Instead of ordinary (strictly serializable) reads, you can perform <a class="reference internal" href="#snapshot-isolation"><span class="std std-ref">snapshot reads</span></a>, which do not add read conflict ranges.</p></li>
<li><p>You can use <a class="reference internal" href="api-python.html#api-python-transaction-options"><span class="std std-ref">transaction options</span></a> to disable conflict ranges for writes.</p></li>
</ul>
<p>Conflicts can be <em>created</em>, increasing isolation, by <a class="reference internal" href="api-python.html#api-python-conflict-ranges"><span class="std std-ref">explicitly adding</span></a> read or write conflict ranges.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>add read conflict range</em> behaves as if the client is reading the range. This means <em>add read conflict range</em> will not add conflict ranges for keys that have been written earlier in the same transaction. This is the intended behavior, as it allows users to compose transactions together without introducing unnecessary conflicts.</p>
</div>
<p>For example, suppose you have a transactional function that increments a set of counters using atomic addition. <a class="reference internal" href="#developer-guide-atomic-operations"><span class="std std-ref">Atomic operations</span></a> do not add read conflict ranges and so cannot cause the transaction in which they occur to fail. More precisely, the read version for an atomic operation is the same as transaction’s commit version, and thus no conflicting write from other transactions could be serialized between the read and write of the key. Most of the time, this is exactly what we want. However, suppose there is another transaction that (infrequently) resets one or more counters, and our contract requires that we must advance all specified counters in unison. We want to guarantee that if a counter is reset during an incrementing transaction, then the incrementing transaction will conflict. We can selectively add read conflicts ranges for this purpose:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">guarded_increment</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">counters</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">counter</span> <span class="ow">in</span> <span class="n">counters</span><span class="p">:</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">reset</span><span class="p">(</span><span class="n">counter</span><span class="p">):</span> <span class="n">tr</span><span class="o">.</span><span class="n">add_read_conflict_key</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="snapshot-reads">
<span id="snapshot-isolation"></span><h3>Snapshot reads</h3>
<p>Snapshot reads selectively relax FoundationDB’s isolation property, reducing <a class="reference internal" href="#developer-guide-transaction-conflicts"><span class="std std-ref">conflicts</span></a> but making it harder to reason about concurrency.</p>
<p>The strictly serializable isolation that transactions maintain by default has little performance cost when there are few conflicts but can be expensive when there are many. FoundationDB therefore also permits individual reads within a transaction to be done as snapshot reads. Snapshot reads differ from ordinary (strictly serializable) reads by permitting the values they read to be modified by concurrent transactions, whereas strictly serializable reads cause conflicts in that case.</p>
<p>Consider a transaction which needs to remove and return an arbitrary value from a small range of keys.  The simplest implementation (using strictly serializable isolation) would be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">remove_one</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="nb">range</span><span class="p">):</span>
    <span class="n">all_kv</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="nb">range</span><span class="p">]</span>
    <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_kv</span><span class="p">))</span>
    <span class="k">del</span> <span class="n">tr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">value</span>
</pre></div>
</div>
<p>Unfortunately, if a concurrent transaction happens to insert a new key anywhere in the range, our transaction will conflict with it and fail (resulting in a retry) because seeing the other transaction’s write would change the result of the range read.  FoundationDB is enforcing a stronger contract than we actually need.  A snapshot read allows us to weaken the contract, but we don’t want to weaken it too far: it’s still important to us that the actual value we returned existed in the database at the time of our transaction. Adding a <a class="reference internal" href="#conflict-ranges"><span class="std std-ref">conflict range</span></a> for our key ensures that we will fail if someone else modifies the key simultaneously:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">remove_one</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="nb">range</span><span class="p">):</span>
    <span class="n">all_kv</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">snapshot</span><span class="p">[</span><span class="nb">range</span><span class="p">]</span>              <span class="c1"># Snapshot read</span>
    <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_kv</span><span class="p">))</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">add_read_conflict_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>            <span class="c1"># Add conflict range</span>
    <span class="k">del</span> <span class="n">tr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">value</span>
</pre></div>
</div>
<p>This transaction accomplishes the same task but won’t conflict with the insert of a key elsewhere in the range. It will only conflict with a modification to the key it actually returns.</p>
<p>By default, snapshot reads see the effects of prior writes in the same transaction. (This read-your-writes behavior is the same as for ordinary, strictly serializable reads.) Read-your-writes allows transactional functions (such as the above example) to be easily composed within a single transaction because each function will see the writes of previously invoked functions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<div class="line-block">
<div class="line">The default read-your-writes behavior of snapshot reads is well-suited to the large majority of use cases. In less frequent cases, you may want to read from only a single version of the database. This behavior can be achieved through the appropriate <a class="reference internal" href="api-python.html#api-python-snapshot-ryw"><span class="std std-ref">transaction options</span></a>. Transaction options are an advanced feature of the API and should be used with caution.</div>
<div class="line"><br /></div>
<div class="line">Read-your-writes can be disabled (and re-enabled) within a transaction by using the options:</div>
<div class="line"><br /></div>
<div class="line">* <code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.options.set_snapshot_ryw_disable()</span></code></div>
<div class="line">* <code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.options.set_snapshot_ryw_enable()</span></code>.</div>
<div class="line"><br /></div>
<div class="line">A given snapshot read gets read-your-writes behavior unless the disable option has been previously set more times than the enable option in that transaction.</div>
<div class="line"><br /></div>
</div>
</div>
<p>Using snapshot reads is appropriate when the following conditions all hold:</p>
<ul class="simple">
<li><p>A particular read of frequently written values causes too many conflicts.</p></li>
<li><p>There isn’t an easy way to reduce conflicts by splitting up data more granularly.</p></li>
<li><p>Any necessary invariants can be validated with added conflict ranges or more narrowly targeted strictly serializable reads.</p></li>
</ul>
</section>
<section id="transaction-cancellation">
<h3>Transaction cancellation</h3>
<p>The FoundationDB language bindings all provide a mechanism for cancelling an outstanding transaction. However there are also special transaction options for specifying the conditions under which a transaction should automatically be cancelled.</p>
<p>In the following example, a retry loop is combined with transaction options that ensure that the operation will not be attempted more than 6 times or for longer than 3 seconds:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span> <span class="nf">example_with_cancellation</span><span class="p">(</span><span class="n">tr</span><span class="p">):</span>
    <span class="c1"># Set maximum number of times that on_error() can be called (implicitly by the decorator).</span>
    <span class="c1"># On the 6th time, on_error() will throw retry_limit_exceeded rather than resetting and retrying.</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">set_retry_limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="c1"># Cancel transaction with transaction_timed_out after 3 seconds</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">set_timeout</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>

    <span class="c1"># Read two values from the transaction snapshot</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="c1"># Write two key-value pairs to the transaction snapshot</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">set_retry_limit()</span></code> option sets a maximum number of <em>retries</em>, not tries. So the transaction above will at most be attempted a total of six times.</p>
</div>
</section>
<section id="watches">
<h3>Watches</h3>
<p>Sometimes you want a client to monitor one or more keys for updates to their values by other clients. An obvious way to implement monitoring is by polling, i.e., periodically reading the key-values to check them for a change. FoundationDB provides watches to monitor keys more efficiently. Watches are created for a specified key and return a <a class="reference internal" href="#developer-guide-programming-with-futures"><span class="std std-ref">future</span></a> that becomes ready when there’s a change to the key’s value.</p>
<p>For example, suppose you have a polling loop that checks keys for changes once a second:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">polling_loop</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>

    <span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
    <span class="k">def</span> <span class="nf">read_keys</span><span class="p">(</span><span class="n">tr</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">tr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="nb">object</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">read_keys</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>You can use the loop to dispatch changes to a handler with something like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">polling_loop</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span><span class="s1">&#39;bat&#39;</span><span class="p">]):</span> <span class="n">handle</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>With watches, you can eliminate the sleep and perform new reads only after a change to one of the keys:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">watching_read_loop</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>

    <span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
    <span class="k">def</span> <span class="nf">watch_keys</span><span class="p">(</span><span class="n">tr</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">tr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">},</span> <span class="p">[</span><span class="n">tr</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="nb">object</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">watches</span> <span class="o">=</span> <span class="n">watch_keys</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">fdb</span><span class="o">.</span><span class="n">Future</span><span class="o">.</span><span class="n">wait_for_any</span><span class="p">(</span><span class="o">*</span><span class="n">watches</span><span class="p">)</span>
</pre></div>
</div>
<p>The version with watches will perform fewer unnecessary reads and detect changes with better resolution than by polling.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Watches guarantee only that a value was changed; they make no guarantee about values you may subsequently read. In particular, there is no guarantee that a value you read will correspond to the change that triggered the watch. Another client may have changed a key back to its original value or to some third value between a watch becoming ready and your subsequent read. For further details, see the discussion of watches in the language-specific document of your choice under <a class="reference internal" href="api-reference.html"><span class="doc">API Reference</span></a>.</p>
</div>
<p>If you only need to detect the <em>fact</em> of a change, and your response doesn’t depend on the new <em>value</em>, then you can eliminate the reads altogether:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">watching_loop</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>

    <span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
    <span class="k">def</span> <span class="nf">watch_keys</span><span class="p">(</span><span class="n">tr</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tr</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">fdb</span><span class="o">.</span><span class="n">Future</span><span class="o">.</span><span class="n">wait_for_any</span><span class="p">(</span><span class="o">*</span><span class="n">watch_keys</span><span class="p">(</span><span class="n">db</span><span class="p">))</span>
        <span class="k">yield</span>
</pre></div>
</div>
</section>
</section>
<section id="performance-considerations">
<span id="developer-guide-peformance-considerations"></span><h2>Performance considerations</h2>
<section id="latency">
<h3>Latency</h3>
<p>Like all systems, FoundationDB operates at a low latency while under low load and an increasing latency as the load approaches the saturation point. We have made efforts to allow FoundationDB to operate at a low latency even at moderate loads. However, if FoundationDB is being driven with a “saturating” load (e.g. batch processing), latencies can be become very high as a line forms for requests. In this case, the transactions generating the saturating load should be run with a lower priority, allowing other transactions to skip ahead in line.</p>
<ul class="simple">
<li><p>For more information on setting transaction priorities, see the discussion of Transaction Options in the language-specific document of your choice under <a class="reference internal" href="api-reference.html"><span class="doc">API Reference</span></a>.</p></li>
</ul>
<p>There are several places in a typical transaction that can experience database latency:</p>
<ul class="simple">
<li><p><strong>Starting the transaction</strong>. This delay will be experienced as part of your first read (or part of <code class="docutils literal notranslate"><span class="pre">getReadVersion()</span></code> if using that API call). It will typically be a few milliseconds under moderate load, but under high write loads FoundationDB tries to concentrate most transaction latency here. This latency does not increase transaction conflicts (see <a class="reference internal" href="#developer-guide-transaction-conflicts"><span class="std std-ref">Minimizing conflicts</span></a> below) since the transaction has not yet started.</p></li>
<li><p><strong>Individual reads</strong>. These should take about 1 ms under moderate load on appropriate hardware. If a transaction performs many reads by waiting for each to complete before starting the next, however, these small latencies can add up. You can thus reduce transaction latency (and potentially conflicts) by doing as many of your reads as possible in parallel (i.e. by starting several reads before waiting on their results). See the <a class="reference internal" href="#developer-guide-programming-with-futures"><span class="std std-ref">Programming with futures</span></a> section of this document for an elegant way to achieve this.</p></li>
<li><p><strong>Committing the transaction</strong>. Transactions that are not read-only must be committed, and the commit will not succeed until the transaction is fully (redundantly) durable. This takes time: averaging about 10 ms under normal loads with SSD hardware. This latency will be increased further in a geographically distributed system (in order to confirm that the transaction is durable in multiple datacenters). Only a small part of this latency impacts transaction conflicts.</p></li>
</ul>
</section>
<section id="throughput-requires-concurrency">
<h3>Throughput requires concurrency</h3>
<p>FoundationDB will only reach its maximum performance with a highly concurrent workload. This is a practical consideration that derives mathematically from the ratio of system throughput to system latency (known in queuing theory as <a class="reference external" href="http://en.wikipedia.org/wiki/Little%27s_law">Little’s Law</a>). For FoundationDB, a cluster might have a read latency of 1ms and be capable of millions of reads per second. To achieve such a rate, there must therefore be thousands of read requests happening concurrently. <em>Not having enough outstanding requests is the single biggest reason for low performance when using FoundationDB.</em></p>
<p>There are several important techniques for achieving high concurrency:</p>
<ul class="simple">
<li><p>Whether your application does FoundationDB transactions in response to requests (as in web applications) or simply does transactions as fast as it can (as in a batch workload), make sure to run it with enough concurrent threads or processes—perhaps more than you would expect to provide optimal performance from experience with other database systems.</p></li>
<li><p>In many environments, there are cheaper (and sometimes less dangerous) alternatives to operating system threads for workloads that are bound by network latency. For example, in Python, the <a class="reference external" href="http://gevent.org/">gevent library</a> provides “coroutines” that have a simple thread-like programming model but are scheduled asynchronously in a single thread. FoundationDB’s <a class="reference internal" href="api-python.html"><span class="doc">Python API</span></a> integrates with gevent and other language APIs have similar integrations. This can make it practical to run hundreds or thousands of concurrent transactions per core without much overhead. (If FoundationDB doesn’t integrate with your favorite asynchronous programming tool, please let us know about it.)</p></li>
<li><p>Whenever possible, do multiple reads within a single transaction in parallel rather than sequentially. This reduces latency, and consequently reduces the number of concurrent transactions required to sustain a given throughput. See the <a class="reference internal" href="#developer-guide-programming-with-futures"><span class="std std-ref">Programming with futures</span></a> section of this document for an elegant way to achieve this.</p></li>
</ul>
</section>
<section id="minimizing-conflicts">
<span id="developer-guide-transaction-conflicts"></span><h3>Minimizing conflicts</h3>
<p>Frequent conflicts make FoundationDB operate inefficiently and should be minimized. They result from multiple clients trying to update the same keys at a high rate. Developers need to avoid this condition by spreading frequently updated data over a large set of keys.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As a rule of thumb, if a key will be modified <em>more than 10-100 times per second</em>, a different data model should be considered.</p>
</div>
<p>In these situations:</p>
<ul class="simple">
<li><p>If the data stored in the key is large, consider <a class="reference internal" href="largeval.html#largeval-splitting"><span class="std std-ref">splitting it among multiple keys</span></a> that can each be modified separately.</p></li>
<li><p>For a data structure like a counter, consider using <a class="reference internal" href="#developer-guide-atomic-operations"><span class="std std-ref">atomic operations</span></a> so that the write-only transactions do not conflict with each other. FoundationDB supports atomic operations for <em>addition</em>, <em>min</em>, <em>max</em>, bitwise <em>and</em>, bitwise <em>or</em>, and bitwise <em>xor</em>.</p></li>
<li><p>Consider performing selected reads as <a class="reference internal" href="#snapshot-isolation"><span class="std std-ref">snapshot reads</span></a>, which eliminate conflicts with those reads but weaken transactional isolation.</p></li>
<li><p>For associative, commutative operations not supported as atomic operations, consider using adaptive sharding.</p></li>
<li><p>For operations that are order-dependent, consider inserting operations into a database queue prior to their execution by a subsequent transaction. The general pattern is to convert a read/modify/write operation on a logical value into an insertion into a list of changes to the value. Any client can then transactionally replace a portion of the list with its evaluated result. This pattern allows insertions to be decoupled from subsequent evaluations, which can take place in separate transactions. You can reach out on the <a class="reference external" href="https://forums.foundationdb.org">community forums</a> for help with finding the simplest solution to your actual use case.</p></li>
</ul>
</section>
<section id="key-and-value-sizes">
<span id="developer-guide-key-and-value-sizes"></span><h3>Key and value sizes</h3>
<p>Maintaining efficient key and value sizes is essential to getting maximum performance with FoundationDB. As a rule, smaller key sizes are better, as they can be more efficiently transmitted over the network and compared. In concrete terms, the highest performance applications will keep key sizes below 32 bytes. Key sizes above 10 kB are not allowed, and sizes above 1 kB should be avoided—store the data in the value if possible.</p>
<p>Value sizes are more flexible, with 0-10 kB normal. Value sizes cannot exceed 100 kB. Like any similar system, FoundationDB has a “characteristic value size” where the fixed costs of the random read roughly equal the marginal costs of the actual bytes. For FoundationDB running on SSD hardware, this characteristic size is roughly 1 kB for randomly accessed data and roughly 100 bytes for frequently accessed (cached) data.</p>
<p>If your keys or values are initially too large, try to revise your <a class="reference internal" href="data-modeling.html"><span class="doc">data model</span></a> to make them smaller.</p>
</section>
<section id="loading-data">
<h3>Loading data</h3>
<p>Loading data is a common task in any database. Loading data in FoundationDB will be most efficiently accomplished if a few guidelines are followed:</p>
<ul class="simple">
<li><p>Load small sequential chunks of the data set from random positions in the data set (to allow the system to efficiently distribute different data to different servers).</p></li>
<li><p>Do about 10KB of data in total writes per transaction.</p></li>
<li><p>Use about 50 concurrent transactions per loading process to allow efficient pipelining. You can increase the number of concurrent transactions as long as transaction latencies remain under about 1 second.</p></li>
<li><p>Use multiple processes loading in parallel if a single one is CPU-bound.</p></li>
</ul>
<p>Using these techniques, our cluster of 24 nodes and 48 SSDs loads about 3 billion (100 byte) key-value pairs per hour.</p>
</section>
</section>
<section id="implementation-details">
<h2>Implementation Details</h2>
<p>These following sections go into some of the gritty details of FoundationDB. Most users don’t need to read or understand this in order to use FoundationDB efficiently.</p>
<section id="how-foundationdb-detects-conflicts">
<h3>How FoundationDB Detects Conflicts</h3>
<p>As written above, FoundationDB implements serializable transactions with external consistency. The underlying algorithm uses multi-version concurrency control. At commit time, each transaction is checked for read-write conflicts.</p>
<p>Conceptually this algorithm is quite simple. Each transaction will get a read version assigned when it issues the first read or before it tries to commit. All reads that happen during that transaction will be read as of that version. Writes will go into a local cache and will be sent to FoundationDB during commit time. The transaction can successfully commit if it is conflict free; it will then get a commit-version assigned. A transaction is conflict free if and only if there have been no writes to any key that was read by that transaction between the time the transaction started and the commit time. This is true if there was no transaction with a commit version larger than our read version but smaller than our commit version that wrote to any of the keys that we read.</p>
<p>This form of conflict detection, while simple, can often be confusing for people who are familiar with databases that check for write-write conflicts.</p>
<p>Some interesting properties of FoundationDB transactions are:</p>
<ul class="simple">
<li><p>FoundationDB transactions are optimistic: we never block on reads or writes (there are no locks), instead we abort transactions at commit time.</p></li>
<li><p>Read-only transactions will never conflict and never cause conflicts with other transactions.</p></li>
<li><p>Write-only transactions will never conflict but might cause future transactions to conflict.</p></li>
<li><p>For read-write transactions: A read will never cause any other transaction to be aborted - but reading a key might result in the current transaction being aborted at commit time. A write will never cause a conflict in the current transaction but might cause conflicts in transactions that try to commit in the future.</p></li>
<li><p>FoundationDB only uses the read conflict set and the write conflict set to resolve transactions. A user can read from and write to FoundationDB without adding entries to these sets. If not done carefully, this can cause non-serializable executions (see <a class="reference internal" href="api-python.html#api-python-snapshot-reads"><span class="std std-ref">Snapshot Reads</span></a> and the <a class="reference internal" href="api-python.html#api-python-no-write-conflict-range"><span class="std std-ref">no-write-conflict-range option</span></a> option).</p></li>
</ul>
<section id="how-versions-are-generated-and-assigned">
<h4>How Versions are Generated and Assigned</h4>
<p>Versions are generated by the process that runs the <em>master</em> role. FoundationDB guarantees that no version will be generated twice and that the versions are monotonically increasing.</p>
<p>In order to assign read and commit versions to transactions, a client will never talk to the master. Instead it will get them from a GRV proxy and a commit proxy. Getting a read version is more complex than a commit version. Let’s first look at commit versions:</p>
<ol class="arabic simple">
<li><p>The client will send a commit message to a commit proxy.</p></li>
<li><p>The commit proxy will put this commit message in a queue in order to build a batch.</p></li>
<li><p>In parallel, the commit proxy will ask for a new version from the master (note that this means that only commit proxies will ever ask for new versions - which scales much better as it puts less stress on the network).</p></li>
<li><p>The commit proxy will then resolve all transactions within that batch (discussed later) and assign the version it got from the master to <em>all</em> transactions within that batch. It will then write the transactions to the transaction log system to make it durable.</p></li>
<li><p>If the transaction succeeded, it will send back the version as commit version to the client. Otherwise it will send back an error.</p></li>
</ol>
<p>As mentioned before, the algorithm to assign read versions is a bit more complex. At the start of a transaction, a client will ask a GRV proxy server for a read version. The GRV proxy will reply with the last committed version as of the time it received the request - this is important to guarantee external consistency. This is how this is achieved:</p>
<ol class="arabic simple">
<li><p>The client will send a GRV (get read version) request to a GRV proxy.</p></li>
<li><p>The GRV proxy will batch GRV requests for a short amount of time (it depends on load and configuartion how big these batches will be).</p></li>
<li><p>The proxy will do the following steps in parallel:
* Ask master for their most recent committed version (the largest version of proxies’ committed version for which the transactions are successfully written to the transaction log system).
* Send a message to the transaction log system to verify that it is still writable. This is to prevent that we fetch read versions from a GRV proxy that has been declared to be dead.</p></li>
</ol>
<p>Checking whether the log-system is still writeable can be especially expensive if a clusters runs in a multi-region configuration. If a user is fine to sacrifice strict serializability they can use <a class="reference internal" href="api-python.html#api-python-option-set-causal-read-risky"><span class="std std-ref">option-causal-read-risky</span></a>.</p>
</section>
<section id="conflict-detection">
<h4>Conflict Detection</h4>
<p>This section will only explain conceptually how transactions are resolved in FoundationDB. The implementation will use multiple servers running the <em>Resolver</em> role and the keyspace will be sharded across them. It will also only allow resolving transactions whose read versions are less than 5 million versions older than their commit version (around 5 seconds).</p>
<p>A resolver will keep a map in memory which stores the written keys of each commit version. A simpified resolver state could look like this:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Version</p></th>
<th class="head"><p>Keys</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1000</p></td>
<td><p>a, b</p></td>
</tr>
<tr class="row-odd"><td><p>1200</p></td>
<td><p>f, q, c</p></td>
</tr>
<tr class="row-even"><td><p>1210</p></td>
<td><p>a</p></td>
</tr>
<tr class="row-odd"><td><p>1340</p></td>
<td><p>t, u, x</p></td>
</tr>
</tbody>
</table>
<p>Now let’s assume we have a transaction with read version <em>1200</em> and the assigned commit version will be something larger than 1340 - let’s say it is <em>1450</em>. In that transaction we read keys <code class="docutils literal notranslate"><span class="pre">b,</span> <span class="pre">m,</span> <span class="pre">s</span></code> and we want to write to <code class="docutils literal notranslate"><span class="pre">a</span></code>. Note that we didn’t read <code class="docutils literal notranslate"><span class="pre">a</span></code> - so we will issue a blind write. The resolver will check whether any of the read keys (<code class="docutils literal notranslate"><span class="pre">b,</span> <span class="pre">m,</span> <span class="pre">or</span> <span class="pre">s</span></code>) appers in any line between version <em>1200</em> and the most recent version, <em>1450</em>. The last write to <code class="docutils literal notranslate"><span class="pre">b</span></code> was at version 1000 which was before the read version. This means that transaction read the most recent value. We don’t know about any recent writes to the other keys. Therefore the resolver will decide that this transaction does <em>NOT</em> conflict and it can be committed. It will then add this new write set to its internal state so that it can resolve future transactions. The new state will look like this:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Version</p></th>
<th class="head"><p>Keys</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1000</p></td>
<td><p>a, b</p></td>
</tr>
<tr class="row-odd"><td><p>1200</p></td>
<td><p>f, q, c</p></td>
</tr>
<tr class="row-even"><td><p>1210</p></td>
<td><p>a</p></td>
</tr>
<tr class="row-odd"><td><p>1340</p></td>
<td><p>t, u, x</p></td>
</tr>
<tr class="row-even"><td><p>1450</p></td>
<td><p>a</p></td>
</tr>
</tbody>
</table>
<p>Note that the resolver didn’t use the write set at all in order to make a decision whether the transaction can commit or not. This means that blind writes (writes to keys without reading them first) will never cause a conflict. But since the resolver will then remember these writes, blind writes can cause future transactions to conflict.</p>
</section>
</section>
<section id="error-handling">
<h3>Error Handling</h3>
<p>When using FoundationDB we strongly recommend users to use the retry-loop. In Python the retry loop would look this this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">create_transaction</span><span class="p">()</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># execute reads and writes on FDB using the tr object</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">break</span>
    <span class="k">except</span> <span class="n">FDBError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">on_error</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">code</span><span class="p">)</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>This is also what the transaction decoration in python does, if you pass a <code class="docutils literal notranslate"><span class="pre">Database</span></code> object to a decorated function. There are some interesting properties of this retry loop:</p>
<ul class="simple">
<li><p>We never create a new transaction within that loop. Instead <code class="docutils literal notranslate"><span class="pre">tr.on_error</span></code> will create a soft reset on the transaction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tr.on_error</span></code> returns a future. This is because <code class="docutils literal notranslate"><span class="pre">on_error</span></code> will do back off to make sure we don’t overwhelm the cluster.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">tr.on_error</span></code> throws an error, we exit the retry loop.</p></li>
</ul>
<p>If you use this retry loop, there are very few caveats. If you write your own and you are not careful, some things might behave differently than you would expect. The following sections will go over the most common errors you will see, the guarantees FoundationDB provides during failures, and common caveats. This retry loop will take care of most of these errors, but it might still be beneficial to understand those.</p>
<section id="errors-where-we-know-the-state-of-the-transaction">
<h4>Errors where we know the State of the Transaction</h4>
<p>The most common errors you will see are errors where we know that the transaction failed to commit. In this case, we’re guaranteed that nothing that we attempted to write was written to the database. The most common error codes for this are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">not_committed</span></code> is thrown whenever there was a conflict. This will only be thrown by a <code class="docutils literal notranslate"><span class="pre">commit</span></code>, read and write operations won’t generate this error.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">transaction_too_old</span></code> is thrown if your transaction runs for more than five seconds. If you see this error often, you should try to make your transactions shorter.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">future_version</span></code> is one of the slightly more complex errors. There are a couple ways this error could be generated: if you set the read version of your transaction manually to something larger than exists or if the storage servers are falling behind. The second case should be more common. This is usually caused by a write load that is too high for FoundationDB to handle or by faulty/slow disks.</p></li>
</ul>
<p>The good thing about these errors is that retrying is simple: you know that the transaction didn’t commit and therefore you can retry even without thinking much about weird corner cases.</p>
</section>
<section id="the-commit-unknown-result-error">
<h4>The <code class="docutils literal notranslate"><span class="pre">commit_unknown_result</span></code> Error</h4>
<p><code class="docutils literal notranslate"><span class="pre">commit_unknown_result</span></code> can be thrown during a commit. This error is difficult to handle as you won’t know whether your transaction was committed or not. There are mostly two reasons why you might see this error:</p>
<ol class="arabic simple">
<li><p>The client lost the connection to the commit proxy to which it did send the commit. So it never got a reply and therefore can’t know whether the commit was successful or not.</p></li>
<li><p>There was a FoundationDB failure - for example a commit proxy failed during the commit. In that case there is no way for the client know whether the transaction succeeded or not.</p></li>
</ol>
<p>However, there is one guarantee FoundationDB gives to the caller: at the point of time where you receive this error, the transaction either committed or not and if it didn’t commit, it will never commit in the future. Or: it is guaranteed that the transaction is not in-flight anymore. This is an important guarantee as it means that if your transaction is idempotent you can simply retry. For more explanations see <a class="reference internal" href="#developer-guide-unknown-results">developer-guide-unknown-results</a>.</p>
</section>
<section id="non-retryable-errors">
<h4>Non-Retryable Errors</h4>
<p>The trickiest errors are non-retryable errors. <code class="docutils literal notranslate"><span class="pre">Transaction.on_error</span></code> will rethrow these. Some examples of non-retryable errors are:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">transaction_timed_out</span></code>. If you set a timeout for a transaction, the transaction will throw this error as soon as that timeout occurs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operation_cancelled</span></code>. This error is thrown if you call <code class="docutils literal notranslate"><span class="pre">cancel()</span></code> on any future returned by a transaction. So if this future is shared by multiple threads or coroutines, all other waiters will see this error.</p></li>
</ol>
<p>If you see one of those errors, the best way of action is to fail the client.</p>
<p>At a first glance this looks very similar to an <code class="docutils literal notranslate"><span class="pre">commit_unknown_result</span></code>. However, these errors lack the one guarantee <code class="docutils literal notranslate"><span class="pre">commit_unknown_result</span></code> still gives to the user: if the commit has already been sent to the database, the transaction could get committed at a later point in time. This means that if you retry the transaction, your new transaction might race with the old transaction. While this technically doesn’t violate any consistency guarantees, abandoning a transaction means that there are no causality guaranatees.</p>
</section>
</section>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/developer-guide.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2013-2021 Apple, Inc and the FoundationDB project authors.<br/>
      Last updated on Jan 19, 2023.<br/>
    </p>
  </div>
</footer>
  </body>
</html>