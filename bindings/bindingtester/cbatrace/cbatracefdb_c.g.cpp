// ////////////////////////////////////////////////////////////////////////////////////// //
// DO NOT EDIT THIS FILE BY HAND.                                                         //
// THIS FILE IS GENERATED DURING COMPILATION USING SCRIPT CBATRACESYMBOLIFY.PY.           //
// To regenerate this file from the top level of a FoundationDB repository checkout, run: //
// $ python3 bindings/bindingtester/cbatrace/cbatraceSymbolify.py                         //
//          -o bindings/bindingtester/cbatrace/cbatracefdb_c.g.cpp                        //
//             bindings//c/foundationdb/fdb_c.h                                           //
//             bindings/c/fdb_c.cpp                                                       //
// ////////////////////////////////////////////////////////////////////////////////////// //

/*
 * This file defines a set of heper C functions and (mostly) macros used 
 * as a source to generate a wrapper shared library called libcbatracefdb_c.so.
 * The resulting library is used along with LD_PRELOAD to override the functions 
 * of shared library libfdb_c.so in order to trace their calls. 
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2013-2018 Apple Inc. and the FoundationDB project authors
 *f
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <foundationdb/fdb_c_options.g.h> 
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <atomic>
#include <mutex>
#include <dlfcn.h>
#include <sys/types.h>

/* 
 * SHARED_OBJECT_PUBLIC: 
 *   A macro defining the visibility attribute to use with symbols, the shared 
 *   library have to expose for dynamic linkage.
 */
#define SHARED_OBJECT_PUBLIC __attribute__ ((visibility ("default")))

/*
 * REPORT_USAGE: 
 *   Macro used to generate code that traces calls for the specified function.
 *   it peforms the following actions:
 *     - increments the usage count of the specified function 
 *     - (if requested) writes en entry into the output (tracing) file   
 */
#define REPORT_USAGE(fctName)                                               \
  ++_count_##fctName;                                                       \
  if (traceFlags & CBATRACE_FLAGS_FCTCOUNT)  {                              \
    xmlWriteEvent(outputFile, 1, "api", #fctName, _count_##fctName.load()); \
  }

/* 
 * CALL_FUNCTION_RET:
 *   Macro used to generate a call to a function with a return type.
 *   It generates code that: 
 *     - calls the specified function
 *     - reports/traces the function call by using the REPORT_USAGE macro 
 *     - returns the resulting value 
 */
#define CALL_FUNCTION_RET(fctName, actualArgs)  \
    auto ret = real_##fctName actualArgs;       \
    REPORT_USAGE(fctName)                       \
    return ret

/*
 * CALL_FUNCTION_VOID:
 *   Macro used to generate a call of a functionswithout a retruning type.
 *   it generates code that: 
 *     - calls the specified function
 *     - reports/traces the function call using the REPORT_USAGE macro 
 */
#define CALL_FUNCTION_VOID(fctName, actualArgs) \
    real_##fctName actualArgs;                  \
    REPORT_USAGE(fctName)

/*
 * MAKE_FUNCTION_COMMON: 
 *   A helper macro used to generate function definition code that exploits 
 *   the LD_PRELOAD trick to override functions calls from library libfdb_c.so.     
 *   This macro is shared by all symbols/functions from fdb_c.cpp. It generates  
 *   code for functions with and without a returning type. 
 */
#define MAKE_FUNCTION_COMMON(retType, fctName, formalArgs, actualArgs, callType)\
typedef retType (*fctName##_t)formalArgs;                                       \
static std::atomic<int64_t> _count_##fctName(0);                                \
extern "C" SHARED_OBJECT_PUBLIC                                                 \
retType fctName formalArgs {                                                    \
    static fctName##_t real_##fctName =                                         \
      reinterpret_cast<fctName##_t>(dlsym(libHandle, #fctName));                \
    if (!real_##fctName) {                                                      \
        printf("Couldn't find %s!\\n", #fctName);                               \
        std::abort();                                                           \
    }                                                                           \
    CALL_FUNCTION_##callType(fctName, actualArgs);                              \
}

/* 
 * MAKE_FUNCTION_RET:
 *   Helper macro that generates definition code for a function WITH a return type. 
 *   It simply uses macro MAKE_FUNCTION_COMMON with RET as a function defintion type.
 */
#define MAKE_FUNCTION_RET(retType, fctName, formalArgs, actualArgs)\
MAKE_FUNCTION_COMMON(retType, fctName, formalArgs, actualArgs, RET)

/*
 * MAKE_FUNCTION_VOID: 
 *    Helper macro that generates code for a function WITHOUT a return type. 
 *   It simply uses macro MAKE_FUNCTION_COMMON with VOID as a function defintion type
 *   (the original function is defined with VOID as a return type).   
 */
#define MAKE_FUNCTION_VOID(retType, fctName, formalArgs, actualArgs)\
MAKE_FUNCTION_COMMON(retType, fctName, formalArgs, actualArgs, VOID)

/*
 * MAKE_FUNCTION_IGNORE:
 *   Helper macro to generate code that ignores a function as it does 
 *   not have implementation in the orignal library. 
 */
 #define MAKE_FUNCTION_IGNORE(retType, fctName, formalArgs, actualArgs)

/*
 * Constructor and descructor to be called before the library is resp. 
 * loaded and unloaded
 */
static void init(void) __attribute__ ((constructor));
static void end(void) __attribute__ ((destructor));

/*
 * Constants 
 *   Mainly environment variables.
 *   The underscore prefix is there because the variable are for internal 
 *   use only and therefore they should not be documented. 
 */
static const char CBATRACE_ENV_TRACE_FLAGS[] = "_CBATRACE_FLAGS";
static const char CBATRACE_ENV_OUTPUT_FILE[] = "_CBATRACE_OUTPUT_FILE";

/*
 * Variables 
 *   Global variables 
 */
static void* libHandle  = NULL;    // handle on the original shared library
static FILE *outputFile = NULL;    // file to write the tracing result
static std::mutex outputFileMutex; // mutex to protect writing into the file

static uint8_t traceFlags  = 0x00; // tracing flags 
#define CBATRACE_FLAGS_SUMMARY  0x00  // (default) always display tracing summary. 
#define CBATRACE_FLAGS_FCTCOUNT 0x01  // trace and display every call with counters  

/*
 * xmlWriteEvent: 
 *   Function used to generate an XML tag string called Event  
 *   with the input parameters and then write the resulting tag into 
 *   the provided output file. 
 *   The event tag has the following (XML) attributes:
 *     - Type : type of the event. A string specified by the caller  
 *     - Name : the name (fctName) of FDB function being traced 
 *     - Count: the number of time the specified function was called   
 *
 *   Exmaple:  
 *     Consider this function call: 
 *     xmlWriteEven(outputFile, 3,  "api", "db_create_database", 1)
 *
 *     The call generages a tag named "Event" for function fdb_create_database()
 *     with a call count of 1. The tag is of type "api" and when displayed
 *     it has an indent of 3, which is the number of spaces before the tag. 
 *     
 *     <Trace>
 *     ...
 *        <Event Type="api" Name="fdb_create_database" Count="1" \>
 *     ...
 *     </Trace> 
 */
static void xmlWriteEvent(FILE *file,                     // output file  
                          const u_int8_t indent,          // indent    
                          const char *type,               // type of the tag    
                          const char *fctName,            // name of the fdb function to report on  
                          const std::int64_t callCount) { // number of times the function was called
  // exclusive access to the output file 
  std::lock_guard<std::mutex> ofmg (outputFileMutex);
  if (file != NULL) {
    fprintf(file, 
            "%*s<Event Type=\"%s\" Name=\"%s\" Count=\"%jd\" \\>\n",
            (indent), "", type, fctName, callCount);
  }
}

/*
 * init - constructor 
 * Init() function used by the constructor  
 * The init() function is called when the library is loaded. 
 * It perfoms the following actins:
 * - load the libfdbc_c.so shared library
 * - checeks whether environment variable "_CTRACE_FLAGS" is set and accordingly 
 *   set the global variable traceFlags.   
 * - checeks whether environment variable "_CTRACE_OUTPUT_FILE"
 *   has been set, then uses it to prepare tracing output into a file.
 *   if not STDOUT will be used.
 */
static void init (void) {
  // load library or abort if not found 
  libHandle = dlopen("libfdb_c.so", RTLD_LAZY);
  if (!libHandle) {                                        
      printf("Couldn't find lib %s!\\n", "libfdb_c.so");
      std::abort();                                     
  }      

  // get the tracing flags env parameter 
  if (getenv(CBATRACE_ENV_TRACE_FLAGS)) {
    traceFlags = atoi(getenv(CBATRACE_ENV_TRACE_FLAGS));
  }

  // check whether an output file (path) has been specified 
  // using environment variable CBATRACE_OUTPUT_FILE. 
  // otherwise use stdout 
  if (getenv(CBATRACE_ENV_OUTPUT_FILE)) {
    const char *outputFileName = getenv(CBATRACE_ENV_OUTPUT_FILE);
    const char *outputMode = "w";

    // open the file 
    outputFile = fopen(outputFileName, outputMode);

    // error out and stop if there is a problem opening the file 
    if (outputFile == NULL) {
      fprintf(stderr, "cbatracefdb_c.g.cpp: Error: Unable to open output file \"%s\"\n", outputFileName);

      exit(1);
    }
  }
  else {		
    // default to stdout 
    outputFile = stdout;
  }

  // the tracing output file content is in XML. It is similar to the XML format used by TraceEvent
  // used by FDB client and server event logging  
  // prepare the output for and write the root xml node
  fprintf(outputFile, "<?xml version=\"1.0\"?>\n");
  fprintf(outputFile, "<Trace>\n");

}


/* --------------------------------------------------------------------- */
/*                    TYPES FORWARD DECLARATIONS                         */
/* --------------------------------------------------------------------- */
struct FDBCluster;
struct FDBDatabase;
struct FDBFuture;
struct FDBKey;
struct FDBKeyValue;
struct FDBTransaction;
typedef int fdb_bool_t;
typedef int fdb_error_t;


/* --------------------------------------------------------------------- */
/*            FDB CLIENT INJECT/WRAPPER APIs DEFINITIONS                 */
/* --------------------------------------------------------------------- */
/* fdb_add_network_thread_completion_hook() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_add_network_thread_completion_hook
, (void (*hook)(void*), void *hook_parameter)
, ( hook, hook_parameter )
)

/* fdb_create_database() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_create_database
, ( const char* cluster_file_path, FDBDatabase** out_database )
, ( cluster_file_path, out_database )
)

/* fdb_database_create_transaction() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_database_create_transaction
, ( FDBDatabase* d, FDBTransaction** out_transaction )
, ( d, out_transaction )
)

/* fdb_database_destroy() */
MAKE_FUNCTION_VOID(
void 
, fdb_database_destroy
, ( FDBDatabase* d )
, ( d )
)

/* fdb_database_set_option() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_database_set_option
, ( FDBDatabase* d, FDBDatabaseOption option, uint8_t const* value, int value_length )
, ( d, option, value, value_length )
)

/* fdb_error_predicate() */
MAKE_FUNCTION_RET(
fdb_bool_t 
, fdb_error_predicate
, ( int predicate_test, fdb_error_t code )
, ( predicate_test, code )
)

/* fdb_future_block_until_ready() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_future_block_until_ready
, ( FDBFuture* f )
, ( f )
)

/* fdb_future_cancel() */
MAKE_FUNCTION_VOID(
void 
, fdb_future_cancel
, ( FDBFuture* f )
, ( f )
)

/* fdb_future_destroy() */
MAKE_FUNCTION_VOID(
void 
, fdb_future_destroy
, ( FDBFuture* f )
, ( f )
)

/* fdb_future_get_int64() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_future_get_int64
, ( FDBFuture* f, int64_t* out_value )
, ( f, out_value )
)

/* fdb_future_get_key() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_future_get_key
, ( FDBFuture* f, uint8_t const** out_key, int* out_key_length )
, ( f, out_key, out_key_length )
)

/* fdb_future_get_key_array() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_future_get_key_array
, ( FDBFuture* f, FDBKey const** out_key_array, int* out_count)
, ( f, out_key_array, out_count )
)

/* fdb_future_get_string_array() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_future_get_string_array
, ( FDBFuture* f, const char*** out_strings, int* out_count)
, ( f, out_strings, out_count )
)

/* fdb_future_get_value() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_future_get_value
, ( FDBFuture* f, fdb_bool_t* out_present, uint8_t const** out_value, int* out_value_length )
, ( f, out_present, out_value, out_value_length )
)

/* fdb_future_is_ready() */
MAKE_FUNCTION_RET(
fdb_bool_t 
, fdb_future_is_ready
, ( FDBFuture* f )
, ( f )
)

/* fdb_future_release_memory() */
MAKE_FUNCTION_VOID(
void 
, fdb_future_release_memory
, ( FDBFuture* f )
, ( f )
)

/* fdb_future_set_callback() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_future_set_callback
, ( FDBFuture* f, void (*callbackf)(FDBFuture*, void*), void* userdata )
, ( f, callbackf, userdata )
)

/* fdb_get_client_version() */
MAKE_FUNCTION_RET(
const char* 
, fdb_get_client_version
, ()
, (  )
)

/* fdb_get_error() */
MAKE_FUNCTION_RET(
const char *
, fdb_get_error
, ( fdb_error_t code )
, ( code )
)

/* fdb_get_max_api_version() */
MAKE_FUNCTION_RET(
int 
, fdb_get_max_api_version
, ()
, (  )
)

/* fdb_network_set_option() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_network_set_option
, ( FDBNetworkOption option, uint8_t const* value, int value_length )
, ( option, value, value_length )
)

/* fdb_run_network() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_run_network
, ()
, (  )
)

/* fdb_select_api_version_impl() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_select_api_version_impl
, ( int runtime_version, int header_version )
, ( runtime_version, header_version )
)

/* fdb_stop_network() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_stop_network
, ()
, (  )
)

/* fdb_transaction_add_conflict_range() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_transaction_add_conflict_range
, ( FDBTransaction*tr, uint8_t const* begin_key_name, int begin_key_name_length, uint8_t const* end_key_name, int end_key_name_length, FDBConflictRangeType type)
, ( tr, begin_key_name, begin_key_name_length, end_key_name, end_key_name_length, type )
)

/* fdb_transaction_atomic_op() */
MAKE_FUNCTION_VOID(
void 
, fdb_transaction_atomic_op
, ( FDBTransaction* tr, uint8_t const* key_name, int key_name_length, uint8_t const* param, int param_length, FDBMutationType operation_type )
, ( tr, key_name, key_name_length, param, param_length, operation_type )
)

/* fdb_transaction_cancel() */
MAKE_FUNCTION_VOID(
void 
, fdb_transaction_cancel
, ( FDBTransaction* tr )
, ( tr )
)

/* fdb_transaction_clear() */
MAKE_FUNCTION_VOID(
void 
, fdb_transaction_clear
, ( FDBTransaction* tr, uint8_t const* key_name, int key_name_length )
, ( tr, key_name, key_name_length )
)

/* fdb_transaction_clear_range() */
MAKE_FUNCTION_VOID(
void 
, fdb_transaction_clear_range
, ( FDBTransaction* tr, uint8_t const* begin_key_name, int begin_key_name_length, uint8_t const* end_key_name, int end_key_name_length )
, ( tr, begin_key_name, begin_key_name_length, end_key_name, end_key_name_length )
)

/* fdb_transaction_commit() */
MAKE_FUNCTION_RET(
FDBFuture* 
, fdb_transaction_commit
, ( FDBTransaction* tr )
, ( tr )
)

/* fdb_transaction_destroy() */
MAKE_FUNCTION_VOID(
void 
, fdb_transaction_destroy
, ( FDBTransaction* tr )
, ( tr )
)

/* fdb_transaction_get_addresses_for_key() */
MAKE_FUNCTION_RET(
FDBFuture* 
, fdb_transaction_get_addresses_for_key
, ( FDBTransaction* tr, uint8_t const* key_name, int key_name_length )
, ( tr, key_name, key_name_length )
)

/* fdb_transaction_get_approximate_size() */
MAKE_FUNCTION_RET(
FDBFuture* 
, fdb_transaction_get_approximate_size
, (FDBTransaction* tr)
, ( tr )
)

/* fdb_transaction_get_committed_version() */
MAKE_FUNCTION_RET(
fdb_error_t 
, fdb_transaction_get_committed_version
, ( FDBTransaction* tr, int64_t* out_version )
, ( tr, out_version )
)

/* fdb_transaction_get_estimated_range_size_bytes() */
MAKE_FUNCTION_RET(
FDBFuture* 
, fdb_transaction_get_estimated_range_size_bytes
, ( FDBTransaction* tr, uint8_t const* begin_key_name, int begin_key_name_length, uint8_t const* end_key_name, int end_key_name_length )
, ( tr, begin_key_name, begin_key_name_length, end_key_name, end_key_name_length )
)

/* fdb_transaction_get_range_split_points() */
MAKE_FUNCTION_RET(
FDBFuture* 
, fdb_transaction_get_range_split_points
, ( FDBTransaction* tr, uint8_t const* begin_key_name, int begin_key_name_length, uint8_t const* end_key_name, int end_key_name_length, int64_t chunk_size)
, ( tr, begin_key_name, begin_key_name_length, end_key_name, end_key_name_length, chunk_size )
)

/* fdb_transaction_get_read_version() */
MAKE_FUNCTION_RET(
FDBFuture* 
, fdb_transaction_get_read_version
, ( FDBTransaction* tr )
, ( tr )
)

/* fdb_transaction_get_versionstamp() */
MAKE_FUNCTION_RET(
FDBFuture* 
, fdb_transaction_get_versionstamp
, ( FDBTransaction* tr )
, ( tr )
)

/* fdb_transaction_on_error() */
MAKE_FUNCTION_RET(
FDBFuture* 
, fdb_transaction_on_error
, ( FDBTransaction* tr, fdb_error_t error )
, ( tr, error )
)

/* fdb_transaction_reset() */
MAKE_FUNCTION_VOID(
void 
, fdb_transaction_reset
, ( FDBTransaction* tr )
, ( tr )
)

/* fdb_transaction_set() */
MAKE_FUNCTION_VOID(
void 
, fdb_transaction_set
, ( FDBTransaction* tr, uint8_t const* key_name, int key_name_length, uint8_t const* value, int value_length )
, ( tr, key_name, key_name_length, value, value_length )
)

/* fdb_transaction_set_read_version() */
MAKE_FUNCTION_VOID(
void 
, fdb_transaction_set_read_version
, ( FDBTransaction* tr, int64_t version )
, ( tr, version )
)

/* fdb_transaction_watch() */
MAKE_FUNCTION_RET(
FDBFuture* 
, fdb_transaction_watch
, ( FDBTransaction *tr, uint8_t const* key_name, int key_name_length)
, ( tr, key_name, key_name_length )
)

/* 
 * end():
 *   This function is called when the dynamic library is un-loading.
 *   It is primarily called to report and show a summary of the API calls.
 */
static void end (void) {
  // just for tracing. Uncomment if needed   
  // printf("libctracefdb_c: shutting down File=%p 0\n", outputFile);  
  // display the summary for API calls counters 
  fprintf(outputFile, " <Event Type=\"summary\" Name=\"totals\">\n");
  
  xmlWriteEvent(outputFile, 2, "api", "fdb_add_network_thread_completion_hook", _count_fdb_add_network_thread_completion_hook.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_stop_network", _count_fdb_stop_network.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_database_destroy", _count_fdb_database_destroy.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_get_read_version", _count_fdb_transaction_get_read_version.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_on_error", _count_fdb_transaction_on_error.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_future_get_string_array", _count_fdb_future_get_string_array.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_get_versionstamp", _count_fdb_transaction_get_versionstamp.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_future_cancel", _count_fdb_future_cancel.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_commit", _count_fdb_transaction_commit.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_database_create_transaction", _count_fdb_database_create_transaction.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_get_committed_version", _count_fdb_transaction_get_committed_version.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_get_error", _count_fdb_get_error.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_set", _count_fdb_transaction_set.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_future_get_int64", _count_fdb_future_get_int64.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_get_addresses_for_key", _count_fdb_transaction_get_addresses_for_key.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_future_destroy", _count_fdb_future_destroy.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_error_predicate", _count_fdb_error_predicate.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_create_database", _count_fdb_create_database.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_future_is_ready", _count_fdb_future_is_ready.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_run_network", _count_fdb_run_network.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_future_block_until_ready", _count_fdb_future_block_until_ready.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_get_range_split_points", _count_fdb_transaction_get_range_split_points.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_future_get_key", _count_fdb_future_get_key.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_watch", _count_fdb_transaction_watch.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_destroy", _count_fdb_transaction_destroy.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_add_conflict_range", _count_fdb_transaction_add_conflict_range.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_future_set_callback", _count_fdb_future_set_callback.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_get_client_version", _count_fdb_get_client_version.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_database_set_option", _count_fdb_database_set_option.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_clear", _count_fdb_transaction_clear.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_atomic_op", _count_fdb_transaction_atomic_op.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_clear_range", _count_fdb_transaction_clear_range.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_future_get_key_array", _count_fdb_future_get_key_array.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_set_read_version", _count_fdb_transaction_set_read_version.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_future_release_memory", _count_fdb_future_release_memory.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_get_approximate_size", _count_fdb_transaction_get_approximate_size.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_future_get_value", _count_fdb_future_get_value.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_network_set_option", _count_fdb_network_set_option.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_cancel", _count_fdb_transaction_cancel.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_transaction_reset", _count_fdb_transaction_reset.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_select_api_version_impl", _count_fdb_select_api_version_impl.load());
  xmlWriteEvent(outputFile, 2, "api", "fdb_get_max_api_version", _count_fdb_get_max_api_version.load());

  // generate closing xml tags 
  fprintf(outputFile, " </Event>\n");
  fprintf(outputFile, "</Trace>\n");

  // flush and close the file 
  fclose(outputFile);  
}

