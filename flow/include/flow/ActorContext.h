/*
 * ActorContext.h
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2013-2024 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef FLOW_ACTOR_CONTEXT_H
#define FLOW_ACTOR_CONTEXT_H

#define ACTOR_MONITORING_DISABLED 0
#define ACTOR_MONITORING_MINIMAL 1
#define ACTOR_MONITORING_FULL 2

#if ACTOR_MONITORING != ACTOR_MONITORING_DISABLED

#include <cstdint>
#include <memory>
#include <string_view>
#include <type_traits>
#include <vector>

#include "flow/GUID.h"

namespace ActorMonitoring {

// The unique identifier for the given actor
// It should be a UID. Yet we use a string_view to hint. Generated by ActorCompiler.cs
using ActorIdentifier = GUID;

// The unique identifier for each part of the ACTOR. Generated by ActorCompiler.cs
using ActorBlockIdentifier = GUID;

// The identifier for a running actor, analogus to PID/ThreadID. It is used in the runtime.
using ActorID = uint64_t;

static constexpr ActorID INVALID_ACTOR_ID = std::numeric_limits<ActorID>::max();
static constexpr ActorID INIT_ACTOR_ID = 0;

namespace {

struct ActorInfoMinimal {
	// The identifier of the type of the ACTOR
	ActorIdentifier identifier;

	// The identifier of the ACTOR
	ActorID id;

	// The identifier of the ACTOR that spawns this ACTOR
	ActorID spawner;

	ActorInfoMinimal();
	ActorInfoMinimal(const ActorIdentifier& identifier_, const ActorID id_, const ActorID spawner_);

	template <typename Ar>
	void serialize(Ar& ar) {
		serializer(ar, identifier, id, spawner);
	}
};

struct ActorInfoFull : ActorInfoMinimal {
	// The time the actor spawns
	double spawnTime;

	// The time the actor being resumed lastly
	double lastResumeTime;

	// The place the actor yields
	ActorBlockIdentifier yieldBlockID;

	// The time actor yielded lastly
	double lastYieldTime;

	// Number of times the actor being resumed
	uint64_t numResumes;

	ActorInfoFull();
	ActorInfoFull(const ActorIdentifier& identifier_, const ActorID id_, const ActorID spawner_);

	template <typename Ar>
	void serialize(Ar& ar) {
		ActorInfoMinimal::serialize(ar);
		serializer(ar, spawnTime, lastResumeTime, yieldBlockID, lastYieldTime, numResumes);
	}
};

} // namespace

#if ACTOR_MONITORING == ACTOR_MONITORING_MINIMAL
using ActorInfo = ActorInfoMinimal;
#elif ACTOR_MONITORING == ACTOR_MONITORING_FULL
using ActorInfo = ActorInfoFull;
#endif

using ActiveActor = ActorInfo;

struct ActorExecutionContext {
	ActorID actorID;

	ActorBlockIdentifier blockIdentifier;

	ActorExecutionContext(const ActorID actorID_, const ActorBlockIdentifier blockIdentifier_)
	  : actorID(actorID_), blockIdentifier(blockIdentifier_) {}
};

// Dumps the current ACTORs to a given stream
extern void dumpActors(std::ostream& stream);

// A helper class that register/unregister the Actor
class ActiveActorHelper {
public:
	ActorID actorID;

	explicit ActiveActorHelper(const ActorIdentifier& actorIdentifier);
	~ActiveActorHelper();
};

class ActorExecutionContextHelper {
public:
	ActorExecutionContextHelper(const ActorID& actorID_, const ActorBlockIdentifier& blockIdentifier_);
	~ActorExecutionContextHelper();
};

class ActorYieldHelper {
public:
	ActorYieldHelper(const ActorID& actorID_, const ActorBlockIdentifier& blockIdentifier_);
};

enum class ActorContextDumpType : uint8_t {
	FULL_CONTEXT,
	CURRENT_STACK,
	CURRENT_CALL_BACKTRACE,
};

// Encode the current actor context into a base64 string
extern std::string encodeActorContext(const ActorContextDumpType dumpType = ActorContextDumpType::FULL_CONTEXT);

// Encode the current actor call backtrace
extern void dumpActorCallBacktrace();

struct DecodedActorContext {
	ActorID currentRunningActor;
	std::vector<ActorInfo> context;
	uint64_t dumpFields;
	ActorContextDumpType dumpType;
};

// Decode the serialized actor context to DecodedActorContext
DecodedActorContext decodeActorContext(const std::string& caller);

} // namespace ActorMonitoring

#else // ACTOR_MONITORING != ACTOR_MONITORING_DISABLED

#include "flow/GUID.h"

namespace ActorMonitoring {
using ActorID = uint64_t;
using ActorIdentifier = GUID;
using ActorBlockIdentifier = GUID;

struct ActorExecutionContext {};
struct ActorInfo {};
struct ActiveActor {};
struct ActiveActorHelper {
	ActiveActorHelper(const ActorIdentifier&) {}
};
struct ActorExecutionContextHelper {
	ActorExecutionContextHelper(const ActorID&, const ActorBlockIdentifier&) {}
};
struct ActorYieldHelper {
	ActorYieldHelper(const ActorID&, const ActorBlockIdentifier&) {}
};

inline void dumpActorCallBacktrace() {}

} // namespace ActorMonitoring

#endif // ACTOR_MONITORING != ACTOR_MONITORING_DISABLED

#endif // FLOW_ACTOR_CONTEXT_H
