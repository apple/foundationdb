<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Python API &#8212; FoundationDB 7.4.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-sphinx.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Ruby API" href="api-ruby.html" />
    <link rel="prev" title="API Reference" href="api-reference.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          FoundationDB</a>
        <span class="navbar-text navbar-version pull-left"><b>7.4.5</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="contents.html">Site Map</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Python API</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#api-versioning">API versioning</a></li>
<li><a class="reference internal" href="#opening-a-database">Opening a database</a></li>
<li><a class="reference internal" href="#keys-and-values">Keys and values</a><ul>
<li><a class="reference internal" href="#as-foundationdb-key-and-as-foundationdb-value"><code class="docutils literal notranslate"><span class="pre">as_foundationdb_key</span></code> and <code class="docutils literal notranslate"><span class="pre">as_foundationdb_value</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#keyvalue-objects">KeyValue objects</a><ul>
<li><a class="reference internal" href="#attributes">Attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#key-selectors">Key selectors</a></li>
<li><a class="reference internal" href="#database-objects">Database objects</a><ul>
<li><a class="reference internal" href="#database-options">Database options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tenant-objects">Tenant objects</a></li>
<li><a class="reference internal" href="#transactional-decoration">Transactional decoration</a></li>
<li><a class="reference internal" href="#transaction-objects">Transaction objects</a><ul>
<li><a class="reference internal" href="#id1">Attributes</a></li>
<li><a class="reference internal" href="#reading-data">Reading data</a></li>
<li><a class="reference internal" href="#snapshot-reads">Snapshot reads</a></li>
<li><a class="reference internal" href="#writing-data">Writing data</a></li>
<li><a class="reference internal" href="#atomic-operations">Atomic operations</a></li>
<li><a class="reference internal" href="#committing">Committing</a></li>
<li><a class="reference internal" href="#watches">Watches</a></li>
<li><a class="reference internal" href="#conflict-ranges">Conflict ranges</a></li>
<li><a class="reference internal" href="#versions">Versions</a></li>
<li><a class="reference internal" href="#transaction-misc-functions">Transaction misc functions</a></li>
<li><a class="reference internal" href="#transaction-options">Transaction options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#future-objects">Future objects</a></li>
<li><a class="reference internal" href="#streaming-modes">Streaming modes</a></li>
<li><a class="reference internal" href="#event-models">Event models</a></li>
<li><a class="reference internal" href="#errors">Errors</a></li>
<li><a class="reference internal" href="#module-fdb.tuple">Tuple layer</a></li>
<li><a class="reference internal" href="#subspaces">Subspaces</a></li>
<li><a class="reference internal" href="#directories">Directories</a><ul>
<li><a class="reference internal" href="#directorysubspace">DirectorySubspace</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-fdb.locality">Locality information</a></li>
<li><a class="reference internal" href="#module-fdb.tenant_management">Tenant management</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="api-reference.html" title="Previous Chapter: API Reference"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; API Reference</span>
    </a>
  </li>
  <li>
    <a href="api-ruby.html" title="Next Chapter: Ruby API"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Ruby API &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">Python API</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#api-versioning">API versioning</a></li>
<li><a class="reference internal" href="#opening-a-database">Opening a database</a></li>
<li><a class="reference internal" href="#keys-and-values">Keys and values</a><ul>
<li><a class="reference internal" href="#as-foundationdb-key-and-as-foundationdb-value"><code class="docutils literal notranslate"><span class="pre">as_foundationdb_key</span></code> and <code class="docutils literal notranslate"><span class="pre">as_foundationdb_value</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#keyvalue-objects">KeyValue objects</a><ul>
<li><a class="reference internal" href="#attributes">Attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#key-selectors">Key selectors</a></li>
<li><a class="reference internal" href="#database-objects">Database objects</a><ul>
<li><a class="reference internal" href="#database-options">Database options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tenant-objects">Tenant objects</a></li>
<li><a class="reference internal" href="#transactional-decoration">Transactional decoration</a></li>
<li><a class="reference internal" href="#transaction-objects">Transaction objects</a><ul>
<li><a class="reference internal" href="#id1">Attributes</a></li>
<li><a class="reference internal" href="#reading-data">Reading data</a></li>
<li><a class="reference internal" href="#snapshot-reads">Snapshot reads</a></li>
<li><a class="reference internal" href="#writing-data">Writing data</a></li>
<li><a class="reference internal" href="#atomic-operations">Atomic operations</a></li>
<li><a class="reference internal" href="#committing">Committing</a></li>
<li><a class="reference internal" href="#watches">Watches</a></li>
<li><a class="reference internal" href="#conflict-ranges">Conflict ranges</a></li>
<li><a class="reference internal" href="#versions">Versions</a></li>
<li><a class="reference internal" href="#transaction-misc-functions">Transaction misc functions</a></li>
<li><a class="reference internal" href="#transaction-options">Transaction options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#future-objects">Future objects</a></li>
<li><a class="reference internal" href="#streaming-modes">Streaming modes</a></li>
<li><a class="reference internal" href="#event-models">Event models</a></li>
<li><a class="reference internal" href="#errors">Errors</a></li>
<li><a class="reference internal" href="#module-fdb.tuple">Tuple layer</a></li>
<li><a class="reference internal" href="#subspaces">Subspaces</a></li>
<li><a class="reference internal" href="#directories">Directories</a><ul>
<li><a class="reference internal" href="#directorysubspace">DirectorySubspace</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-fdb.locality">Locality information</a></li>
<li><a class="reference internal" href="#module-fdb.tenant_management">Tenant management</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <span class="target" id="module-fdb"></span><section id="python-api">
<h1>Python API</h1>
<section id="installation">
<h2>Installation</h2>
<p>The FoundationDB Python API is compatible with 3.8 and newer versions.</p>
<p>On macOS, the FoundationDB Python API is installed as part of the FoundationDB installation (see <a class="reference internal" href="api-general.html#installing-client-binaries"><span class="std std-ref">Installing FoundationDB client binaries</span></a>). On Ubuntu or RHEL/CentOS, you will need to install the FoundationDB Python API manually via Python’s package manager <code class="docutils literal notranslate"><span class="pre">pip</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>user@host$ pip install foundationdb
</pre></div>
</div>
<p>You can also download the FoundationDB Python API source directly from <a class="reference internal" href="downloads.html"><span class="doc">Downloads</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Python language binding is compatible with FoundationDB client binaries of version 2.0 or higher. When used with version 2.0.x client binaries, the API version must be set to 200 or lower.</p>
</div>
<p>After installation, the module <code class="docutils literal notranslate"><span class="pre">fdb</span></code> should be usable from your Python installation or path. (The system default python is always used by the client installer on macOS.)</p>
</section>
<section id="api-versioning">
<span id="api-python-versioning"></span><h2>API versioning</h2>
<p>When you import the <code class="docutils literal notranslate"><span class="pre">fdb</span></code> module, it exposes only one useful symbol:</p>
<dl class="py function">
<dt class="sig sig-object py" id="fdb.api_version">
<span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">api_version</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">version</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Specifies the version of the API that the application uses. This allows future versions of FoundationDB to make API changes without breaking existing programs.  The current version of the API is 740.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You must call <code class="docutils literal notranslate"><span class="pre">fdb.api_version(...)</span></code> before using any other part of the API.  Once you have done so, the rest of the API will become available in the <code class="docutils literal notranslate"><span class="pre">fdb</span></code> module. This requirement includes use of the <code class="docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code> decorator, which is called when your module is imported.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>FoundationDB encapsulates multiple versions of its interface by requiring the client to explicitly specify the version of the API it uses. The purpose of this design is to allow you to upgrade the server, client libraries, or bindings without having to modify client code. The client libraries support all previous versions of the API. The API version specified by the client is used to control the behavior of the binding. You can therefore upgrade to more recent packages (and thus receive various improvements) without having to change your code.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When using the <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">multi-version client API</span></a>, setting an API version that is not supported by a particular client library will prevent that client from being used to connect to the cluster. In particular, you should not advance the API version of your application after upgrading your client until the cluster has also been upgraded.</p>
</div>
<p>For API changes between version 13 and 740 (for the purpose of porting older programs), see <a class="reference internal" href="release-notes/release-notes-720.html#release-notes"><span class="std std-ref">Release Notes</span></a> and <a class="reference internal" href="api-version-upgrade-guide.html"><span class="doc">API Version Upgrade Guide</span></a>.</p>
</section>
<section id="opening-a-database">
<h2>Opening a database</h2>
<p>After importing the <code class="docutils literal notranslate"><span class="pre">fdb</span></code> module and selecting an API version, you probably want to open a <a class="reference internal" href="#fdb.Database" title="fdb.Database"><code class="xref py py-class docutils literal notranslate"><span class="pre">Database</span></code></a> using <a class="reference internal" href="#fdb.open" title="fdb.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">fdb</span>
<span class="n">fdb</span><span class="o">.</span><span class="n">api_version</span><span class="p">(</span><span class="mi">740</span><span class="p">)</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="fdb.open">
<span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cluster_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Connects to the cluster specified by the <a class="reference internal" href="administration.html#foundationdb-cluster-file"><span class="std std-ref">cluster file</span></a>. This function is often called without any parameters, using only the defaults. If no cluster file is passed, FoundationDB automatically <a class="reference internal" href="administration.html#specifying-a-cluster-file"><span class="std std-ref">determines a cluster file</span></a> with which to connect to a cluster.</p>
<p>A single client can use this function multiple times to connect to different clusters simultaneously, with each invocation requiring its own cluster file. To connect to multiple clusters running at different, incompatible versions, the <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">multi-version client API</span></a> must be used.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="fdb.options">
<span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">options</span></span></dt>
<dd><p>A singleton providing options which affect the entire FoundationDB client. Note that network options can also be <a class="reference internal" href="api-general.html#network-options-using-environment-variables"><span class="std std-ref">set using environment variables</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is an error to set these options after the first call to <a class="reference internal" href="#fdb.open" title="fdb.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">fdb.open()</span></code></a> anywhere in your application.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_knob">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_knob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">knob</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets internal tuning or debugging knobs. The argument to this function should be a string representing the knob name and the value, e.g. “transaction_size_limit=1000”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_trace_enable">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_trace_enable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_directory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Enables trace file generation on this FoundationDB client. Trace files will be generated in the specified output directory. If the directory is specified as <code class="docutils literal notranslate"><span class="pre">None</span></code>, then the output directory will be the current working directory.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The specified output directory must be unique to this client. In the present release, trace logging does not allow two clients to share a directory.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_trace_max_logs_size">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_trace_max_logs_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the maximum size in bytes for the sum of this FoundationDB client’s trace output files in a single log directory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_trace_roll_size">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_trace_roll_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the maximum size in bytes of a single trace output file for this FoundationDB client.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_trace_format">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_trace_format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Select the format of the trace files for this FoundationDB client. xml (the default) and json are supported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_trace_clock_source">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_trace_clock_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Select clock source for trace files. now (the default) or realtime are supported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_disable_multi_version_client_api">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_disable_multi_version_client_api</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Disables the <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">multi-version client API</span></a> and instead uses the local client directly. Must be set before setting up the network.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_callbacks_on_external_threads">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_callbacks_on_external_threads</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>If set, callbacks from <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">external client libraries</span></a> can be called from threads created by the FoundationDB client library. Otherwise, callbacks will be called from either the thread used to add the callback or the network thread. Setting this option can improve performance when connected using an external client, but may not be safe to use in all environments. Must be set before setting up the network. WARNING: This feature is considered experimental at this time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_external_client_library">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_external_client_library</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_lib</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Adds an external client library for use by the <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">multi-version client API</span></a>. Must be set before setting up the network.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_external_client_directory">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_external_client_directory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_lib_directory</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Searches the specified path for dynamic libraries and adds them to the list of client libraries for use by the <a class="reference internal" href="api-general.html#multi-version-client-api"><span class="std std-ref">multi-version client API</span></a>. Must be set before setting up the network.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following options are only used when connecting to a <a class="reference internal" href="tls.html"><span class="doc">TLS-enabled cluster</span></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_tls_plugin">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_tls_plugin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plugin_path_or_name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the <a class="reference internal" href="tls.html#configuring-tls"><span class="std std-ref">TLS plugin</span></a> to load. This option, if used, must be set before any other TLS options.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_tls_cert_path">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_tls_cert_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_file</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the path for the file from which the <a class="reference internal" href="tls.html#tls-certificate-file"><span class="std std-ref">certificate chain</span></a> will be loaded.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_tls_key_path">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_tls_key_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_file</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the path for the file from which to load the <a class="reference internal" href="tls.html#tls-key-file"><span class="std std-ref">private key</span></a> corresponding to your own certificate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_tls_verify_peers">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_tls_verify_peers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">criteria</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the <a class="reference internal" href="tls.html#tls-verify-peers"><span class="std std-ref">peer certificate field verification criteria</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_tls_cert_bytes">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_tls_cert_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the certificate chain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_tls_key_bytes">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_tls_key_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the private key corresponding to your own certificate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_tls_ca_bytes">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_tls_ca_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ca_bundle</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the certificate authority bundle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_tls_ca_path">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_tls_ca_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the file from which to load the certificate authority bundle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_tls_password">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_tls_password</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the passphrase for encrypted private key. Password should be set before setting the key for the password to be used.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_tls_disable_plaintext_connection">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_tls_disable_plaintext_connection</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Disable non-TLS connections from the client, allowing only TLS connections. Plaintext connections will timeout.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_disable_local_client">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_disable_local_client</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Prevents connections through the local client, allowing only connections through externally loaded client libraries.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_client_threads_per_version">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_client_threads_per_version</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Spawns multiple worker threads for each version of the client that is loaded.  Setting this to a number greater than one implies disable_local_client.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_disable_client_statistics_logging">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_disable_client_statistics_logging</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Disables logging of client statistics, such as sampled transaction activity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_enable_run_loop_profiling">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_enable_run_loop_profiling</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Enables debugging feature to perform run loop profiling. Requires trace logging to be enabled. WARNING: this feature is not recommended for use in production.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.fdb.options.set_distributed_client_tracer">
<span class="sig-prename descclassname"><span class="pre">fdb.options.</span></span><span class="sig-name descname"><span class="pre">set_distributed_client_tracer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tracer_type</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets a tracer to run on the client. Should be set to the same value as the tracer set on the server.</p>
</dd></dl>

<p>Please refer to fdboptions.py (generated) for a comprehensive list of options.</p>
</dd></dl>

</section>
<section id="keys-and-values">
<span id="api-python-keys"></span><h2>Keys and values</h2>
<p>Keys and values in FoundationDB are simple byte strings. In Python 3, a byte string has type <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.</p>
<p>To encode other data types, see <a class="reference internal" href="data-modeling.html#encoding-data-types"><span class="std std-ref">Encoding data types</span></a> and the <a class="reference internal" href="#api-python-tuple-layer"><span class="std std-ref">tuple layer</span></a>.</p>
<section id="as-foundationdb-key-and-as-foundationdb-value">
<h3><code class="docutils literal notranslate"><span class="pre">as_foundationdb_key</span></code> and <code class="docutils literal notranslate"><span class="pre">as_foundationdb_value</span></code></h3>
<p>In some cases, you may have objects that are used to <em>represent</em> specific keys or values (for example, see <a class="reference internal" href="#fdb.Subspace" title="fdb.Subspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subspace</span></code></a>). As a convenience, the language binding API can work seamlessly with such objects if they implement the <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_foundationdb_key()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_foundationdb_value()</span></code> methods, respectively. API methods that accept a key will alternately accept an object that implements the <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_foundationdb_key()</span></code> method. Likewise, API methods accepting a value will also accept an object that implements the <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_foundationdb_value()</span></code> method.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_foundationdb_key()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_foundationdb_value()</span></code> are not intended to implement serialization protocols for object storage. Use these functions only when your object represents a specific key or value.</p>
</div>
</section>
</section>
<section id="keyvalue-objects">
<h2>KeyValue objects</h2>
<dl class="py class">
<dt class="sig sig-object py" id="fdb.KeyValue">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">KeyValue</span></span></dt>
<dd><p>Represents a single key-value pair in the database.  This is a simple value type; mutating it won’t affect your <a class="reference internal" href="#fdb.Transaction" title="fdb.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a> or <a class="reference internal" href="#fdb.Database" title="fdb.Database"><code class="xref py py-class docutils literal notranslate"><span class="pre">Database</span></code></a>.</p>
<p>KeyValue supports the Python iterator protocol so that you can unpack a key and value directly into two variables:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">[</span><span class="n">begin</span><span class="p">:</span><span class="n">end</span><span class="p">]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
</dd></dl>

<section id="attributes">
<h3>Attributes</h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="fdb.KeyValue.key">
<span class="sig-prename descclassname"><span class="pre">KeyValue.</span></span><span class="sig-name descname"><span class="pre">key</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fdb.KeyValue.value">
<span class="sig-prename descclassname"><span class="pre">KeyValue.</span></span><span class="sig-name descname"><span class="pre">value</span></span></dt>
<dd></dd></dl>

</section>
</section>
<section id="key-selectors">
<h2>Key selectors</h2>
<p>FoundationDB’s lexicographically ordered data model permits finding keys based on their order (for example, finding the first key in the database greater than a given key). Key selectors represent a description of a key in the database that could be resolved to an actual key by <a class="reference internal" href="#fdb.Transaction.get_key" title="fdb.Transaction.get_key"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.get_key()</span></code></a> or used directly as the beginning or end of a range in <a class="reference internal" href="#fdb.Transaction.get_range" title="fdb.Transaction.get_range"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.get_range()</span></code></a>.</p>
<p>For more about how key selectors work, see <a class="reference internal" href="developer-guide.html#key-selectors"><span class="std std-ref">Key selectors</span></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="fdb.KeySelector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">KeySelector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">or_equal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a key selector with the given reference key, equality flag, and offset. It is usually more convenient to obtain a key selector with one of the following methods:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.KeySelector.last_less_than">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">KeySelector.</span></span><span class="sig-name descname"><span class="pre">last_less_than</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a key selector referencing the last (greatest) key in the database less than the specified key.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.KeySelector.last_less_or_equal">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">KeySelector.</span></span><span class="sig-name descname"><span class="pre">last_less_or_equal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a key selector referencing the last (greatest) key less than, or equal to, the specified key.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.KeySelector.first_greater_than">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">KeySelector.</span></span><span class="sig-name descname"><span class="pre">first_greater_than</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a key selector referencing the first (least) key greater than the specified key.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.KeySelector.first_greater_or_equal">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">KeySelector.</span></span><span class="sig-name descname"><span class="pre">first_greater_or_equal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a key selector referencing the first key greater than, or equal to, the specified key.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">KeySelector</span> <span class="pre">+</span> <span class="pre">offset</span></code></dt><dd><p>Adding an integer <code class="docutils literal notranslate"><span class="pre">offset</span></code> to a <code class="docutils literal notranslate"><span class="pre">KeySelector</span></code> returns a key selector referencing a key <code class="docutils literal notranslate"><span class="pre">offset</span></code> keys after the original <code class="docutils literal notranslate"><span class="pre">KeySelector</span></code>.  FoundationDB does not efficiently resolve key selectors with large offsets, so <a class="reference internal" href="known-limitations.html#dont-use-key-selectors-for-paging"><span class="std std-ref">Key selectors with large offsets are slow</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KeySelector</span> <span class="pre">-</span> <span class="pre">offset</span></code></dt><dd><p>Subtracting an integer <code class="docutils literal notranslate"><span class="pre">offset</span></code> from a <code class="docutils literal notranslate"><span class="pre">KeySelector</span></code> returns a key selector referencing a key <code class="docutils literal notranslate"><span class="pre">offset</span></code> keys before the original <code class="docutils literal notranslate"><span class="pre">KeySelector</span></code>.  FoundationDB does not efficiently resolve key selectors with large offsets, so <a class="reference internal" href="known-limitations.html#dont-use-key-selectors-for-paging"><span class="std std-ref">Key selectors with large offsets are slow</span></a>.</p>
</dd>
</dl>
</section>
<section id="database-objects">
<h2>Database objects</h2>
<dl class="py class">
<dt class="sig sig-object py" id="fdb.Database">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">Database</span></span></dt>
<dd></dd></dl>

<p>A <code class="docutils literal notranslate"><span class="pre">Database</span></code> represents a FoundationDB database — a mutable, lexicographically ordered mapping from binary keys to binary values. Although <code class="docutils literal notranslate"><span class="pre">Database</span></code> provides convenience methods for reading and writing, modifications to a database are usually via transactions, which are usually created and committed automatically by the <a class="reference internal" href="#fdb.transactional" title="fdb.transactional"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code></a> decorator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The convenience methods provided by <code class="docutils literal notranslate"><span class="pre">Database</span></code> have the same signature as the corresponding methods of <code class="docutils literal notranslate"><span class="pre">Transaction</span></code>. However, most of the <code class="docutils literal notranslate"><span class="pre">Database</span></code> methods are fully synchronous. (An exception is the methods for watches.) As a result, the <code class="docutils literal notranslate"><span class="pre">Database</span></code> methods do not support the use of <a class="reference internal" href="developer-guide.html#developer-guide-programming-with-futures"><span class="std std-ref">implicit parallelism with futures</span></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.create_transaction">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">create_transaction</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns a new <a class="reference internal" href="#fdb.Transaction" title="fdb.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a> object.  Consider using the <a class="reference internal" href="#fdb.transactional" title="fdb.transactional"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code></a> decorator to create transactions instead, since it will automatically provide you with appropriate retry behavior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.open_tenant">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">open_tenant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tenant_name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Opens an existing tenant to be used for running transactions and returns it as a :class`Tenant` object.</p>
<p>The tenant name can be either a byte string or a tuple. If a tuple is provided, the tuple will be packed using the tuple layer to generate the byte string tenant name.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Opening a tenant does not check its existence in the cluster. If the tenant does not exist, attempts to read or write data with it will fail.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.get">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the value associated with the specified key in the database (or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the key does not exist). This read is fully synchronous.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">db[key]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">db.get(key)</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.get_key">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">get_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key_selector</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the key referenced by the specified <a class="reference internal" href="#fdb.KeySelector" title="fdb.KeySelector"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeySelector</span></code></a>. This read is fully synchronous.</p>
<p>The key is cached, providing a potential performance benefit. However, the
value of the key is also retrieved, using network bandwidth.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.get_range">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">get_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streaming_mode</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Returns all keys <code class="docutils literal notranslate"><span class="pre">k</span></code> such that <code class="docutils literal notranslate"><span class="pre">begin</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">end</span></code> and their associated values as a list of <a class="reference internal" href="#fdb.KeyValue" title="fdb.KeyValue"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyValue</span></code></a> objects. Note the exclusion of <code class="docutils literal notranslate"><span class="pre">end</span></code> from the range. This read is fully synchronous.</p>
<p>Each of <code class="docutils literal notranslate"><span class="pre">begin</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> may be a key or a <a class="reference internal" href="#fdb.KeySelector" title="fdb.KeySelector"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeySelector</span></code></a>. Note that in the case of a <a class="reference internal" href="#fdb.KeySelector" title="fdb.KeySelector"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeySelector</span></code></a>, the exclusion of <code class="docutils literal notranslate"><span class="pre">end</span></code> from the range still applies.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">limit</span></code> is specified, then only the first <code class="docutils literal notranslate"><span class="pre">limit</span></code> keys (and their values) in the range will be returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">reverse</span></code> is True, then the last <code class="docutils literal notranslate"><span class="pre">limit</span></code> keys in the range will be returned in reverse order. Reading ranges in reverse is supported natively by the database and should have minimal extra cost.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">streaming_mode</span></code> is specified, it must be a value from the <a class="reference internal" href="#fdb.StreamingMode" title="fdb.StreamingMode"><code class="xref py py-data docutils literal notranslate"><span class="pre">StreamingMode</span></code></a> enumeration. It provides a hint to FoundationDB about how to retrieve the specified range. This option should generally not be specified, allowing FoundationDB to retrieve the full range very efficiently.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">db[begin:end]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">db.get_range(begin,</span> <span class="pre">end)</span></code>. The default slice begin is <code class="docutils literal notranslate"><span class="pre">''</span></code>; the default slice end is <code class="docutils literal notranslate"><span class="pre">'\xFF'</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">db[begin:end:-1]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">db.get_range(begin,</span> <span class="pre">end,</span> <span class="pre">reverse=True)</span></code>. The default slice begin is <code class="docutils literal notranslate"><span class="pre">''</span></code>; the default slice end is <code class="docutils literal notranslate"><span class="pre">'\xFF'</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.get_range_startswith">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">get_range_startswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streaming_mode</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Returns all keys <code class="docutils literal notranslate"><span class="pre">k</span></code> such that <code class="docutils literal notranslate"><span class="pre">k.startswith(prefix)</span></code>, and their associated values, as a list of <a class="reference internal" href="#fdb.KeyValue" title="fdb.KeyValue"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyValue</span></code></a> objects. The <code class="docutils literal notranslate"><span class="pre">limit</span></code>, <code class="docutils literal notranslate"><span class="pre">reverse</span></code> and <code class="docutils literal notranslate"><span class="pre">streaming_mode</span></code> parameters have the same meanings as in <a class="reference internal" href="#fdb.Database.get_range" title="fdb.Database.get_range"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Database.get_range()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.set">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Associates the given <code class="docutils literal notranslate"><span class="pre">key</span></code> and <code class="docutils literal notranslate"><span class="pre">value</span></code>.  Overwrites any prior value associated with <code class="docutils literal notranslate"><span class="pre">key</span></code>. This change will be committed immediately, and is fully synchronous.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">db[key]</span> <span class="pre">=</span> <span class="pre">value</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">db.set(key,</span> <span class="pre">value)</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.clear">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes the specified key (and any associated value), if it exists. This change will be committed immediately, and is fully synchronous.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">db[key]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">db.clear(key)</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.clear_range">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">clear_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes all keys <code class="docutils literal notranslate"><span class="pre">k</span></code> such that <code class="docutils literal notranslate"><span class="pre">begin</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">end</span></code>, and their associated values. This change will be committed immediately, and is fully synchronous.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">db[begin:end]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">db.clear_range(begin,</span> <span class="pre">end)</span></code>. The default slice begin is <code class="docutils literal notranslate"><span class="pre">''</span></code>; the default slice end is <code class="docutils literal notranslate"><span class="pre">'\xFF'</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.clear_range_startswith">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">clear_range_startswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes all keys <code class="docutils literal notranslate"><span class="pre">k</span></code> such that <code class="docutils literal notranslate"><span class="pre">k.startswith(prefix)</span></code>, and their associated values. This change will be committed immediately, and is fully synchronous.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.get_and_watch">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">get_and_watch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a tuple <code class="docutils literal notranslate"><span class="pre">value,</span> <span class="pre">watch</span></code>, where <code class="docutils literal notranslate"><span class="pre">value</span></code> is the value associated with <code class="docutils literal notranslate"><span class="pre">key</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the key does not exist, and <code class="docutils literal notranslate"><span class="pre">watch</span></code> is a <a class="reference internal" href="#fdb.FutureVoid" title="fdb.FutureVoid"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureVoid</span></code></a> that will become ready after <code class="docutils literal notranslate"><span class="pre">value</span></code> changes.</p>
<p>See <a class="reference internal" href="#fdb.Transaction.watch" title="fdb.Transaction.watch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.watch()</span></code></a> for a general description of watches and their limitations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.set_and_watch">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">set_and_watch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">key</span></code> to <code class="docutils literal notranslate"><span class="pre">value</span></code> and returns a <a class="reference internal" href="#fdb.FutureVoid" title="fdb.FutureVoid"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureVoid</span></code></a> that will become ready after a subsequent change to <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>See <a class="reference internal" href="#fdb.Transaction.watch" title="fdb.Transaction.watch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.watch()</span></code></a> for a general description of watches and their limitations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.clear_and_watch">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">clear_and_watch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes <code class="docutils literal notranslate"><span class="pre">key</span></code> (and any associated value) if it exists and returns a <a class="reference internal" href="#fdb.FutureVoid" title="fdb.FutureVoid"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureVoid</span></code></a> that will become ready after the value is subsequently set.</p>
<p>See <a class="reference internal" href="#fdb.Transaction.watch" title="fdb.Transaction.watch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.watch()</span></code></a> for a general description of watches and their limitations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.add">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.bit_and">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">bit_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.bit_or">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">bit_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.bit_xor">
<span class="sig-prename descclassname"><span class="pre">Database.</span></span><span class="sig-name descname"><span class="pre">bit_xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>These atomic operations behave exactly like the <a class="reference internal" href="#api-python-transaction-atomic-operations"><span class="std std-ref">associated operations</span></a> on <a class="reference internal" href="#fdb.Transaction" title="fdb.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a> objects except that the change will immediately be committed, and is fully synchronous.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that since some atomic operations are not idempotent, the implicit use of the <a class="reference internal" href="#fdb.transactional" title="fdb.transactional"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code></a> decorator could interact with a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> exception in unpredictable ways. For more information, see <a class="reference internal" href="developer-guide.html#developer-guide-unknown-results"><span class="std std-ref">Transactions with unknown results</span></a>.</p>
</div>
</dd></dl>

<section id="database-options">
<span id="api-python-database-options"></span><h3>Database options</h3>
<p>Database options alter the behavior of FoundationDB databases.</p>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_location_cache_size">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_location_cache_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the size of the client location cache. Raising this value can boost performance in very large databases where clients access data in a near-random pattern. This value must be an integer in the range [0, 2<sup>31</sup>-1]. Defaults to 100000.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_max_watches">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_max_watches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_watches</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the maximum number of watches allowed to be outstanding on a database connection. Increasing this number could result in increased resource usage. Reducing this number will not cancel any outstanding watches. Defaults to 10000 and cannot be larger than 1000000.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_machine_id">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_machine_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Specify the machine ID of a server to be preferentially used for database operations. ID must be a string of up to 16 hexadecimal digits that was used to configure <a class="reference internal" href="configuration.html#foundationdb-conf-fdbserver"><span class="std std-ref">fdbserver processes</span></a>. Load balancing uses this option for location-awareness, attempting to send database operations first to servers on a specified machine, then a specified datacenter, then returning to its default algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_datacenter_id">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_datacenter_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Specify the datacenter ID to be preferentially used for database operations. ID must be a string of up to 16 hexadecimal digits that was used to configure <a class="reference internal" href="configuration.html#foundationdb-conf-fdbserver"><span class="std std-ref">fdbserver processes</span></a>. Load balancing uses this option for location-awareness, attempting to send database operations first to servers on a specified machine, then a specified datacenter, then returning to its default algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_transaction_timeout">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_transaction_timeout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the default timeout duration in milliseconds after which all transactions created by this database will automatically be cancelled. This is equivalent to calling <a class="reference internal" href="#fdb.Transaction.options.set_timeout" title="fdb.Transaction.options.set_timeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.options.set_timeout()</span></code></a> on each transaction created by this database. This option can only be called if the API version is at least 610.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_transaction_retry_limit">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_transaction_retry_limit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">retry_limit</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the default maximum number of retries for each transaction after which additional calls to <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a> will throw the most recently seen error code. This is equivalent to calling <a class="reference internal" href="#fdb.Transaction.options.set_retry_limit" title="fdb.Transaction.options.set_retry_limit"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.options.set_retry_limit()</span></code></a> on each transaction created by this database.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_transaction_max_retry_delay">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_transaction_max_retry_delay</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay_limit</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the default maximum backoff delay incurred by each transaction in the call to <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a> if the error is retryable. This is equivalent to calling <a class="reference internal" href="#fdb.Transaction.options.set_max_retry_delay" title="fdb.Transaction.options.set_max_retry_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.options.set_max_retry_delay()</span></code></a> on each transaction created by this database.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_transaction_size_limit">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_transaction_size_limit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_limit</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the default maximum transaction size in bytes. This is equivalent to calling <a class="reference internal" href="#fdb.Database.options.set_transaction_size_limit" title="fdb.Database.options.set_transaction_size_limit"><code class="xref py py-func docutils literal notranslate"><span class="pre">Database.options.set_transaction_size_limit()</span></code></a> on each transaction created by this database.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_transaction_causal_read_risky">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_transaction_causal_read_risky</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Transactions do not require the strict causal consistency guarantee that FoundationDB provides by default.  The read version will be committed, and usually will be the latest committed, but might not be the latest committed in the event of a simultaneous fault and misbehaving clock. Enabling this option is equivalent to calling <a class="reference internal" href="#fdb.Transaction.options.set_causal_read_risky" title="fdb.Transaction.options.set_causal_read_risky"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.options.set_causal_read_risky()</span></code></a> on each transaction created by this database.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_transaction_logging_max_field_length">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_transaction_logging_max_field_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_limit</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the maximum escaped length of key and value fields to be logged to the trace file via the LOG_TRANSACTION option. This is equivalent to calling <a class="reference internal" href="#fdb.Transaction.options.set_transaction_logging_max_field_length" title="fdb.Transaction.options.set_transaction_logging_max_field_length"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.options.set_transaction_logging_max_field_length()</span></code></a> on each transaction created by this database.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_snapshot_ryw_enable">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_snapshot_ryw_enable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>If this option has been set an equal or more times with this database than the disable option, snapshot reads <em>will</em> see the effects of prior writes in the same transaction. Enabling this option is equivalent to calling <a class="reference internal" href="#fdb.Transaction.options.set_snapshot_ryw_enable" title="fdb.Transaction.options.set_snapshot_ryw_enable"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.options.set_snapshot_ryw_enable()</span></code></a> on each transaction created by this database.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Database.options.set_snapshot_ryw_disable">
<span class="sig-prename descclassname"><span class="pre">Database.options.</span></span><span class="sig-name descname"><span class="pre">set_snapshot_ryw_disable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>If this option has been set more times with this database than the disable option, snapshot reads will <em>not</em> see the effects of prior writes in the same transaction. Disabling this option is equivalent to calling <a class="reference internal" href="#fdb.Transaction.options.set_snapshot_ryw_disable" title="fdb.Transaction.options.set_snapshot_ryw_disable"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.options.set_snapshot_ryw_disable()</span></code></a> on each transaction created by this database.</p>
</dd></dl>

</section>
</section>
<section id="tenant-objects">
<h2>Tenant objects</h2>
<dl class="py class">
<dt class="sig sig-object py" id="fdb.Tenant">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">Tenant</span></span></dt>
<dd></dd></dl>

<p><a class="reference internal" href="#fdb.Tenant" title="fdb.Tenant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tenant</span></code></a> represents a FoundationDB tenant. Tenants are optional named transaction domains that can be used to provide multiple disjoint key-spaces to client applications. A transaction created in a tenant will be limited to the keys contained within that tenant, and transactions operating on different tenants can use the same key names without interfering with each other.</p>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Tenant.create_transaction">
<span class="sig-prename descclassname"><span class="pre">Tenant.</span></span><span class="sig-name descname"><span class="pre">create_transaction</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns a new <a class="reference internal" href="#fdb.Transaction" title="fdb.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a> object.  Consider using the <a class="reference internal" href="#fdb.transactional" title="fdb.transactional"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code></a> decorator to create transactions instead, since it will automatically provide you with appropriate retry behavior.</p>
</dd></dl>

</section>
<section id="transactional-decoration">
<span id="api-python-transactional-decorator"></span><h2>Transactional decoration</h2>
<dl class="py function">
<dt class="sig sig-object py" id="fdb.transactional">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">transactional</span></span></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code> decorator is a convenience designed to concisely wrap a function with logic to automatically create a transaction and retry until success.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span><span class="w"> </span><span class="nf">simple_function</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">tr</span><span class="p">[</span><span class="sa">b</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">tr</span><span class="p">[</span><span class="sa">b</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code> decorator makes <code class="docutils literal notranslate"><span class="pre">simple_function</span></code> a transactional function.  All functions using this decorator must have an argument <strong>named</strong> <code class="docutils literal notranslate"><span class="pre">tr</span></code>.  This specially named argument is passed a transaction that the function can use to do reads and writes.</p>
<p>A caller of a transactionally decorated function can pass a <a class="reference internal" href="#fdb.Database" title="fdb.Database"><code class="xref py py-class docutils literal notranslate"><span class="pre">Database</span></code></a> or <a class="reference internal" href="#fdb.Tenant" title="fdb.Tenant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tenant</span></code></a> instead of a transaction for the <code class="docutils literal notranslate"><span class="pre">tr</span></code> parameter.  Then a transaction will be created automatically, and automatically committed before returning to the caller.  The decorator will retry calling the decorated function until the transaction successfully commits.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">db</span></code> is a <a class="reference internal" href="#fdb.Database" title="fdb.Database"><code class="xref py py-class docutils literal notranslate"><span class="pre">Database</span></code></a> or <a class="reference internal" href="#fdb.Tenant" title="fdb.Tenant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tenant</span></code></a>, a call like</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">simple_function</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>is equivalent to something like</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tr</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">create_transaction</span><span class="p">()</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">simple_function</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">break</span>
    <span class="k">except</span> <span class="n">fdb</span><span class="o">.</span><span class="n">FDBError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">on_error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>A caller may alternatively pass an actual transaction to the <code class="docutils literal notranslate"><span class="pre">tr</span></code> parameter.  In this case, the transactional function will not attempt to commit the transaction or to retry errors, since that is the responsibility of the caller who owns the transaction.  This design allows transactionally decorated functions to be composed freely into larger transactions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In some failure scenarios, it is possible that your transaction will be executed twice. See <a class="reference internal" href="developer-guide.html#developer-guide-unknown-results"><span class="std std-ref">Transactions with unknown results</span></a> for more information.</p>
</div>
</dd></dl>

</section>
<section id="transaction-objects">
<h2>Transaction objects</h2>
<dl class="py class">
<dt class="sig sig-object py" id="fdb.Transaction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">Transaction</span></span></dt>
<dd></dd></dl>

<p>A <code class="docutils literal notranslate"><span class="pre">Transaction</span></code> object represents a FoundationDB database transaction.  All operations on FoundationDB take place, explicitly or implicitly, through a <code class="docutils literal notranslate"><span class="pre">Transaction</span></code>.</p>
<p>In FoundationDB, a transaction is a mutable snapshot of a database. All read and write operations on a transaction see and modify an otherwise-unchanging version of the database and only change the underlying database if and when the transaction is committed. Read operations do see the effects of previous write operations on the same transaction. Committing a transaction usually succeeds in the absence of <a class="reference internal" href="developer-guide.html#conflict-ranges"><span class="std std-ref">conflicts</span></a>.</p>
<p>Transactions group operations into a unit with the properties of <em>atomicity</em>, <em>isolation</em>, and <em>durability</em>. Transactions also provide the ability to maintain an application’s invariants or integrity constraints, supporting the property of <em>consistency</em>. Together these properties are known as <a class="reference internal" href="developer-guide.html#acid"><span class="std std-ref">ACID</span></a>.</p>
<p>Transactions are also causally consistent: once a transaction has been successfully committed, all subsequently created transactions will see the modifications made by it.</p>
<p>The most convenient way to use Transactions is using the <a class="reference internal" href="#fdb.transactional" title="fdb.transactional"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code></a> decorator.</p>
<p>Keys and values in FoundationDB are byte strings (<code class="docutils literal notranslate"><span class="pre">bytes</span></code> type in Python 3).  To encode other data types, see the <a class="reference internal" href="#module-fdb.tuple" title="fdb.tuple"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fdb.tuple</span></code></a> module and <a class="reference internal" href="data-modeling.html#encoding-data-types"><span class="std std-ref">Encoding data types</span></a>.</p>
<section id="id1">
<h3>Attributes</h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="fdb.Transaction.db">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">db</span></span></dt>
<dd><p>The <a class="reference internal" href="#fdb.Database" title="fdb.Database"><code class="xref py py-class docutils literal notranslate"><span class="pre">Database</span></code></a> that this transaction is interacting with.</p>
</dd></dl>

</section>
<section id="reading-data">
<h3>Reading data</h3>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.get">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a (<a class="reference internal" href="#api-python-future"><span class="std std-ref">future</span></a>) <a class="reference internal" href="#fdb.Value" title="fdb.Value"><code class="xref py py-class docutils literal notranslate"><span class="pre">Value</span></code></a> associated with the specified key in the database.</p>
<p>To check whether the specified key was present in the database, call <a class="reference internal" href="#fdb.Value.present" title="fdb.Value.present"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Value.present()</span></code></a> on the return value.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr[key]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr.get(key)</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.get_key">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">get_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key_selector</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the (<a class="reference internal" href="#api-python-future"><span class="std std-ref">future</span></a>) <a class="reference internal" href="#fdb.Key" title="fdb.Key"><code class="xref py py-class docutils literal notranslate"><span class="pre">Key</span></code></a> referenced by the specified <a class="reference internal" href="#fdb.KeySelector" title="fdb.KeySelector"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeySelector</span></code></a>.</p>
<p>By default, the key is cached for the duration of the transaction, providing
a potential performance benefit. However, the value of the key is also retrieved,
using network bandwidth. Invoking <a class="reference internal" href="#fdb.Transaction.options.set_read_your_writes_disable" title="fdb.Transaction.options.set_read_your_writes_disable"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.options.set_read_your_writes_disable()</span></code></a> will avoid
both the caching and the increased network bandwidth.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.get_range">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">get_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streaming_mode</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Returns all keys <code class="docutils literal notranslate"><span class="pre">k</span></code> such that <code class="docutils literal notranslate"><span class="pre">begin</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">end</span></code> and their associated values as an iterator yielding <a class="reference internal" href="#fdb.KeyValue" title="fdb.KeyValue"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyValue</span></code></a> objects. Note the exclusion of <code class="docutils literal notranslate"><span class="pre">end</span></code> from the range.</p>
<p>Like a <a class="reference internal" href="#api-python-future"><span class="std std-ref">Future</span></a> object, the returned iterator issues asynchronous read operations. It fetches the data in one or more efficient batches (depending on the value of the <code class="docutils literal notranslate"><span class="pre">streaming_mode</span></code> parameter). However, the iterator will block if iteration reaches a value whose read has not yet completed.</p>
<p>Each of <code class="docutils literal notranslate"><span class="pre">begin</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> may be a key or a <a class="reference internal" href="#fdb.KeySelector" title="fdb.KeySelector"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeySelector</span></code></a>. Note that in the case of a <a class="reference internal" href="#fdb.KeySelector" title="fdb.KeySelector"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeySelector</span></code></a>, the exclusion of <code class="docutils literal notranslate"><span class="pre">end</span></code> from the range still applies.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">limit</span></code> is specified, then only the first <code class="docutils literal notranslate"><span class="pre">limit</span></code> keys (and their values) in the range will be returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">reverse</span></code> is True, then the last <code class="docutils literal notranslate"><span class="pre">limit</span></code> keys in the range will be returned in reverse order. Reading ranges in reverse is supported natively by the database and should have minimal extra cost.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">streaming_mode</span></code> is specified, it must be a value from the <a class="reference internal" href="#fdb.StreamingMode" title="fdb.StreamingMode"><code class="xref py py-data docutils literal notranslate"><span class="pre">StreamingMode</span></code></a> enumeration. It provides a hint to FoundationDB about how the returned container is likely to be used.  The default is <a class="reference internal" href="#fdb.StreamingMode.iterator" title="fdb.StreamingMode.iterator"><code class="xref py py-data docutils literal notranslate"><span class="pre">StreamingMode.iterator</span></code></a>.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr[begin:end]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr.get_range(begin,</span> <span class="pre">end)</span></code>. The default slice begin is <code class="docutils literal notranslate"><span class="pre">''</span></code>; the default slice end is <code class="docutils literal notranslate"><span class="pre">'\xFF'</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr[begin:end:-1]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr.get_range(begin,</span> <span class="pre">end,</span> <span class="pre">reverse=True)</span></code>. The default slice begin is <code class="docutils literal notranslate"><span class="pre">''</span></code>; the default slice end is <code class="docutils literal notranslate"><span class="pre">'\xFF'</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.get_range_startswith">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">get_range_startswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streaming_mode</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Returns all keys <code class="docutils literal notranslate"><span class="pre">k</span></code> such that <code class="docutils literal notranslate"><span class="pre">k.startswith(prefix)</span></code>, and their associated values, as a container of <a class="reference internal" href="#fdb.KeyValue" title="fdb.KeyValue"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyValue</span></code></a> objects (see <a class="reference internal" href="#fdb.Transaction.get_range" title="fdb.Transaction.get_range"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.get_range()</span></code></a> for a description of the returned container).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">limit</span></code>, <code class="docutils literal notranslate"><span class="pre">reverse</span></code> and <code class="docutils literal notranslate"><span class="pre">streaming_mode</span></code> parameters have the same meanings as in <a class="reference internal" href="#fdb.Transaction.get_range" title="fdb.Transaction.get_range"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.get_range()</span></code></a>.</p>
</dd></dl>

</section>
<section id="snapshot-reads">
<span id="api-python-snapshot-reads"></span><h3>Snapshot reads</h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="fdb.Transaction.snapshot">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">snapshot</span></span></dt>
<dd><p>Snapshot reads selectively relax FoundationDB’s isolation property, reducing <a class="reference internal" href="developer-guide.html#developer-guide-transaction-conflicts"><span class="std std-ref">conflicts</span></a> but making it harder to reason about concurrency.</p>
<p>By default, FoundationDB transactions guarantee <a class="reference internal" href="developer-guide.html#acid"><span class="std std-ref">strictly serializable isolation</span></a>, resulting in a state that is <em>as if</em> transactions were executed one at a time, even if they were executed concurrently. Serializability has little performance cost when there are few <a class="reference internal" href="developer-guide.html#developer-guide-transaction-conflicts"><span class="std std-ref">conflicts</span></a> but can be expensive when there are many. FoundationDB therefore also permits individual reads within a transaction to be done as snapshot reads.</p>
<p>Snapshot reads differ from ordinary (strictly serializable) reads by permitting the values they read to be modified by concurrent transactions, whereas strictly serializable reads cause conflicts in that case. Like strictly serializable reads, snapshot reads see the effects of prior writes in the same transaction. For more information on the use of snapshot reads, see <a class="reference internal" href="developer-guide.html#snapshot-isolation"><span class="std std-ref">Snapshot reads</span></a>.</p>
<p>Snapshot reads also interact with transaction commit a little differently than normal reads. If a snapshot read is outstanding when transaction commit is called that read will immediately return an error. (Normally, transaction commit will wait until outstanding reads return before committing.)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fdb.Transaction.snapshot.db">
<span class="sig-prename descclassname"><span class="pre">Transaction.snapshot.</span></span><span class="sig-name descname"><span class="pre">db</span></span></dt>
<dd><p>The <a class="reference internal" href="#fdb.Database" title="fdb.Database"><code class="xref py py-class docutils literal notranslate"><span class="pre">Database</span></code></a> that this transaction is interacting with.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.snapshot.get">
<span class="sig-prename descclassname"><span class="pre">Transaction.snapshot.</span></span><span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Like <a class="reference internal" href="#fdb.Transaction.get" title="fdb.Transaction.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.get()</span></code></a>, but as a snapshot read.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr.snapshot[key]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr.snapshot.get(key)</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.snapshot.get_key">
<span class="sig-prename descclassname"><span class="pre">Transaction.snapshot.</span></span><span class="sig-name descname"><span class="pre">get_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key_selector</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">key</span></span></span></dt>
<dd><p>Like <a class="reference internal" href="#fdb.Transaction.get_key" title="fdb.Transaction.get_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.get_key()</span></code></a>, but as a snapshot read.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.snapshot.get_range">
<span class="sig-prename descclassname"><span class="pre">Transaction.snapshot.</span></span><span class="sig-name descname"><span class="pre">get_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streaming_mode</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Like <a class="reference internal" href="#fdb.Transaction.get_range" title="fdb.Transaction.get_range"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.get_range()</span></code></a>, but as a snapshot read.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr.snapshot[begin:end]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr.snapshot.get_range(begin,</span> <span class="pre">end)</span></code>. The default slice begin is <code class="docutils literal notranslate"><span class="pre">''</span></code>; the default slice end is <code class="docutils literal notranslate"><span class="pre">'\xFF'</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr.snapshot[begin:end:-1]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">tr.snapshot.get_range(begin,</span> <span class="pre">end,</span> <span class="pre">reverse=True)</span></code>. The default slice begin is <code class="docutils literal notranslate"><span class="pre">''</span></code>; the default slice end is <code class="docutils literal notranslate"><span class="pre">'\xFF'</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.snapshot.get_range_startswith">
<span class="sig-prename descclassname"><span class="pre">Transaction.snapshot.</span></span><span class="sig-name descname"><span class="pre">get_range_startswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streaming_mode</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Like <a class="reference internal" href="#fdb.Transaction.get_range_startswith" title="fdb.Transaction.get_range_startswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.get_range_startswith()</span></code></a>, but as a snapshot read.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.snapshot.get_read_version">
<span class="sig-prename descclassname"><span class="pre">Transaction.snapshot.</span></span><span class="sig-name descname"><span class="pre">get_read_version</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Identical to <a class="reference internal" href="#fdb.Transaction.get_read_version" title="fdb.Transaction.get_read_version"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.get_read_version()</span></code></a> (since snapshot and strictly serializable reads use the same read version).</p>
</dd></dl>

</section>
<section id="writing-data">
<h3>Writing data</h3>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.set">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Associates the given <code class="docutils literal notranslate"><span class="pre">key</span></code> and <code class="docutils literal notranslate"><span class="pre">value</span></code>.  Overwrites any prior value associated with <code class="docutils literal notranslate"><span class="pre">key</span></code>. Returns immediately, having modified the snapshot represented by this <a class="reference internal" href="#fdb.Transaction" title="fdb.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a>.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tr[key]</span> <span class="pre">=</span> <span class="pre">value</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">tr.set(key,value)</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.clear">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes the specified key (and any associated value), if it exists. Returns immediately, having modified the snapshot represented by this <a class="reference internal" href="#fdb.Transaction" title="fdb.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a>.</p>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">tr[key]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">tr.clear(key)</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.clear_range">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">clear_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes all keys <code class="docutils literal notranslate"><span class="pre">k</span></code> such that <code class="docutils literal notranslate"><span class="pre">begin</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">end</span></code>, and their associated values. Returns immediately, having modified the snapshot represented by this <a class="reference internal" href="#fdb.Transaction" title="fdb.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a>.</p>
<p>Range clears are efficient with FoundationDB – clearing large amounts of data will be fast. However, this will not immediately free up disk - data for the deleted range is cleaned up in the background. For purposes of computing the transaction size, only the begin and end keys of a clear range are counted. The size of the data stored in the range does not count against the transaction size limit.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike in the case of <a class="reference internal" href="#fdb.Transaction.get_range" title="fdb.Transaction.get_range"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_range()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">begin</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> must be keys (byte strings), not <a class="reference internal" href="#fdb.KeySelector" title="fdb.KeySelector"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeySelector</span></code></a>s.  (Resolving arbitrary key selectors would prevent this method from returning immediately, introducing concurrency issues.)</p>
</div>
</dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">tr[begin:end]</span></code></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">tr.clear_range(begin,end)</span></code>. The default slice begin is <code class="docutils literal notranslate"><span class="pre">''</span></code>; the default slice end is <code class="docutils literal notranslate"><span class="pre">'\xFF'</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.clear_range_startswith">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">clear_range_startswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes all the keys <code class="docutils literal notranslate"><span class="pre">k</span></code> such that <code class="docutils literal notranslate"><span class="pre">k.startswith(prefix)</span></code>, and their associated values. Returns immediately, having modified the snapshot represented by this <a class="reference internal" href="#fdb.Transaction" title="fdb.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a>.</p>
<p>Range clears are efficient with FoundationDB – clearing large amounts of data will be fast. However, this will not immediately free up disk - data for the deleted range is cleaned up in the background. For purposes of computing the transaction size, only the begin and end keys of a clear range are counted. The size of the data stored in the range does not count against the transaction size limit.</p>
</dd></dl>

</section>
<section id="atomic-operations">
<span id="api-python-transaction-atomic-operations"></span><h3>Atomic operations</h3>
<p>An atomic operation is a single database command that carries out several logical steps: reading the value of a key, performing a transformation on that value, and writing the result. Different atomic operations perform different transformations. Like other database operations, an atomic operation is used within a transaction; however, its use within a transaction will not cause the transaction to conflict.</p>
<p>Atomic operations do not expose the current value of the key to the client but simply send the database the transformation to apply. In regard to conflict checking, an atomic operation is equivalent to a write without a read. It can only cause <em>other</em> transactions performing reads of the key to conflict.</p>
<p>By combining these logical steps into a single, read-free operation, FoundationDB can guarantee that the transaction will not conflict due to the operation. This makes atomic operations ideal for operating on keys that are frequently modified. A common example is the use of a key-value pair as a counter.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If a transaction uses both an atomic operation and a strictly serializable read on the same key, the benefits of using the atomic operation (for both conflict checking and performance) are lost.</p>
</div>
<p>In each of the methods below, <code class="docutils literal notranslate"><span class="pre">param</span></code> should be a string appropriately packed to represent the desired value. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># wrong</span>
<span class="n">tr</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># right</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">struct</span>
<span class="n">tr</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;q&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.add">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Performs an addition of little-endian integers. If the existing value in the database is not present or shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes.  If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>. In case of overflow, the result is truncated to the width of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<p>The integers to be added must be stored in a little-endian representation. They can be signed in two’s complement representation or unsigned. You can add to an integer at a known offset in the value by prepending the appropriate number of zero bytes to <code class="docutils literal notranslate"><span class="pre">param</span></code> and padding with zero bytes to match the length of the value. However, this offset technique requires that you know the addition will not cause the integer field within the value to overflow.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.bit_and">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">bit_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Performs a bitwise “and” operation. If the existing value in the database is not present, then <code class="docutils literal notranslate"><span class="pre">param</span></code> is stored in the database. If the existing value in the database is  shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.bit_or">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">bit_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Performs a bitwise “or” operation. If the existing value in the database is not present or shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.bit_xor">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">bit_xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Performs a bitwise “xor” operation. If the existing value in the database is not present or shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.compare_and_clear">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">compare_and_clear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Performs an atomic <code class="docutils literal notranslate"><span class="pre">compare</span> <span class="pre">and</span> <span class="pre">clear</span></code> operation. If the existing value in the database is equal to the given value, then given key is cleared.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.max">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the value in the database to the larger of the existing value and <code class="docutils literal notranslate"><span class="pre">param</span></code>. If the existing value in the database is not present or shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<p>Both the existing value and <code class="docutils literal notranslate"><span class="pre">param</span></code> are treated as unsigned integers. (This differs from the behavior of atomic addition.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.byte_max">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">byte_max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Performs lexicographic comparison of byte strings. If the existing value in the database is not present, then <code class="docutils literal notranslate"><span class="pre">param</span></code> is stored. Otherwise the larger of the two values is then stored in the database.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.min">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the value in the database to the smaller of the existing value and <code class="docutils literal notranslate"><span class="pre">param</span></code>. If the existing value in the database is not present, then <code class="docutils literal notranslate"><span class="pre">param</span></code> is stored in the database. If the existing value in the database is shorter than <code class="docutils literal notranslate"><span class="pre">param</span></code>, it is first extended to the length of <code class="docutils literal notranslate"><span class="pre">param</span></code> with zero bytes. If <code class="docutils literal notranslate"><span class="pre">param</span></code> is shorter than the existing value in the database, the existing value is truncated to match the length of <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<p>Both the existing value and <code class="docutils literal notranslate"><span class="pre">param</span></code> are treated as unsigned integers. (This differs from the behavior of atomic addition.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.byte_min">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">byte_min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Performs lexicographic comparison of byte strings. If the existing value in the database is not present, then <code class="docutils literal notranslate"><span class="pre">param</span></code> is stored. Otherwise the smaller of the two values is then stored in the database.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.set_versionstamped_key">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">set_versionstamped_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Transforms <code class="docutils literal notranslate"><span class="pre">key</span></code> using a versionstamp for the transaction. This key must be at least 14 bytes long. The final 4 bytes will be interpreted as a 32-bit little-endian integer denoting an index into the key at which to perform the transformation, and then trimmed off the key. The 10 bytes in the key beginning at the index will be overwritten with the versionstamp. If the index plus 10 bytes points past the end of the key, the result will be an error. Sets the transformed key in the database to <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<p>A versionstamp is a 10 byte, unique, monotonically (but not sequentially) increasing value for each committed transaction. The first 8 bytes are the committed version of the database (serialized in big-endian order). The last 2 bytes are monotonic in the serialization order for transactions (serialized in big-endian order).</p>
<p>A transaction is not permitted to read any transformed key or value previously set within that transaction, and an attempt to do so will result in an <code class="docutils literal notranslate"><span class="pre">accessed_unreadable</span></code> error.  The range of keys marked unreadable when setting a versionstamped key begins at the transactions’s read version if it is known, otherwise a versionstamp of all <code class="docutils literal notranslate"><span class="pre">0x00</span></code> bytes is conservatively assumed.  The upper bound of the unreadable range is a versionstamp of all <code class="docutils literal notranslate"><span class="pre">0xFF</span></code> bytes.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>At this time, versionstamped keys are not compatible with the Tuple layer except in Java, Python, and Go. Note that this implies versionstamped keys may not be used with the Subspace and Directory layers except in those languages.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.set_versionstamped_value">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">set_versionstamped_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Transforms <code class="docutils literal notranslate"><span class="pre">param</span></code> using a versionstamp for the transaction. This parameter must be at least 14 bytes long. The final 4 bytes will be interpreted as a 32-bit little-endian integer denoting an index into the parameter at which to perform the transformation, and then trimmed off the key. The 10 bytes in the parameter beginning at the index will be overwritten with the versionstamp. If the index plus 10 bytes points past the end of the parameter, the result will be an error. Sets <code class="docutils literal notranslate"><span class="pre">key</span></code> in the database to the transformed parameter.</p>
<p>A versionstamp is a 10 byte, unique, monotonically (but not sequentially) increasing value for each committed transaction. The first 8 bytes are the committed version of the database (serialized in big-endian order). The last 2 bytes are monotonic in the serialization order for transactions (serialized in big-endian order).</p>
<p>A transaction is not permitted to read any transformed key or value previously set within that transaction, and an attempt to do so will result in an <code class="docutils literal notranslate"><span class="pre">accessed_unreadable</span></code> error.  The range of keys marked unreadable when setting a versionstamped key begins at the transactions’s read version if it is known, otherwise a versionstamp of all <code class="docutils literal notranslate"><span class="pre">0x00</span></code> bytes is conservatively assumed.  The upper bound of the unreadable range is a versionstamp of all <code class="docutils literal notranslate"><span class="pre">0xFF</span></code> bytes.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>At this time, versionstamped values are not compatible with the Tuple layer except in Java, Python, and Go. Note that this implies versionstamped values may not be used with the Subspace and Directory layers except in those languages.</p>
</div>
</dd></dl>

</section>
<section id="committing">
<span id="api-python-committing"></span><h3>Committing</h3>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.commit">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">commit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Attempt to commit the changes made in the transaction to the database.  Returns a <a class="reference internal" href="#fdb.FutureVoid" title="fdb.FutureVoid"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureVoid</span></code></a> representing the asynchronous result of the commit. You <strong>must</strong> call the <a class="reference internal" href="#fdb.Future.wait" title="fdb.Future.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.wait()</span></code></a> method on the returned <a class="reference internal" href="#fdb.FutureVoid" title="fdb.FutureVoid"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureVoid</span></code></a>, which will raise an exception if the commit failed.</p>
<p>As with other client/server databases, in some failure scenarios a client may be unable to determine whether a transaction succeeded. In these cases, <a class="reference internal" href="#fdb.Transaction.commit" title="fdb.Transaction.commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.commit()</span></code></a> will raise a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> exception. The <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a> function treats this exception as retryable, so retry loops that don’t check for <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> could execute the transaction twice. In these cases, you must consider the idempotence of the transaction. For more information, see <a class="reference internal" href="developer-guide.html#developer-guide-unknown-results"><span class="std std-ref">Transactions with unknown results</span></a>.</p>
<p>Normally, commit will wait for outstanding reads to return. However, if those reads were snapshot reads or the transaction option for disabling “read-your-writes” has been invoked, any outstanding reads will immediately return errors.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Consider using the <a class="reference internal" href="#fdb.transactional" title="fdb.transactional"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code></a> decorator, which not only calls <a class="reference internal" href="#fdb.Database.create_transaction" title="fdb.Database.create_transaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Database.create_transaction()</span></code></a> or :meth`Tenant.create_transaction` and <a class="reference internal" href="#fdb.Transaction.commit" title="fdb.Transaction.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.commit()</span></code></a> for you but also implements the required error handling and retry logic for transactions.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If any operation is performed on a transaction after a commit has been issued but before it has returned, both the commit and the operation will raise a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">used_during_commit</span></a> exception. In this case, all subsequent operations on this transaction will raise this error until <a class="reference internal" href="#fdb.Transaction.reset" title="fdb.Transaction.reset"><code class="xref py py-func docutils literal notranslate"><span class="pre">reset</span></code></a> is called.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.on_error">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">on_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Determine whether an exception raised by a <a class="reference internal" href="#fdb.Transaction" title="fdb.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a> method is retryable. Returns a <a class="reference internal" href="#fdb.FutureVoid" title="fdb.FutureVoid"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureVoid</span></code></a>. You <strong>must</strong> call the <a class="reference internal" href="#fdb.Future.wait" title="fdb.Future.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.wait()</span></code></a> method on the <a class="reference internal" href="#fdb.FutureVoid" title="fdb.FutureVoid"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureVoid</span></code></a>, which will return after a delay if the exception was retryable, or re-raise the exception if it was not.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Consider using the <a class="reference internal" href="#fdb.transactional" title="fdb.transactional"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code></a> decorator, which calls this method for you.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.reset">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Rollback a transaction, completely resetting it to its initial state. This is logically equivalent to destroying the transaction and creating a new one.</p>
</dd></dl>

<span class="target" id="api-python-cancel"></span><dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.cancel">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">cancel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Cancels the transaction. All pending or future uses of the transaction will raise a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">transaction_cancelled</span></a> exception. The transaction can be used again after it is <a class="reference internal" href="#fdb.Transaction.reset" title="fdb.Transaction.reset"><code class="xref py py-func docutils literal notranslate"><span class="pre">reset</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Be careful if you are using <a class="reference internal" href="#fdb.Transaction.reset" title="fdb.Transaction.reset"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.reset()</span></code></a> and <a class="reference internal" href="#fdb.Transaction.cancel" title="fdb.Transaction.cancel"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.cancel()</span></code></a> concurrently with the same transaction. Since they negate each other’s effects, a race condition between these calls will leave the transaction in an unknown state.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If your program attempts to cancel a transaction after <a class="reference internal" href="#fdb.Transaction.commit" title="fdb.Transaction.commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.commit()</span></code></a> has been called but before it returns, unpredictable behavior will result. While it is guaranteed that the transaction will eventually end up in a cancelled state, the commit may or may not occur. Moreover, even if the call to <a class="reference internal" href="#fdb.Transaction.commit" title="fdb.Transaction.commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.commit()</span></code></a> appears to raise a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">transaction_cancelled</span></a> exception,  the commit may have occurred or may occur in the future. This can make it more difficult to reason about the order in which transactions occur.</p>
</div>
</dd></dl>

</section>
<section id="watches">
<span id="api-python-watches"></span><h3>Watches</h3>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.watch">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">watch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a watch and returns a <a class="reference internal" href="#fdb.FutureVoid" title="fdb.FutureVoid"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureVoid</span></code></a> that will become ready when the watch reports a change to the value of the specified key.</p>
<p>A watch’s behavior is relative to the transaction that created it. A watch will report a change in relation to the key’s value as readable by that transaction. The initial value used for comparison is either that of the transaction’s read version or the value as modified by the transaction itself prior to the creation of the watch. If the value changes and then changes back to its initial value, the watch might not report the change.</p>
<p>Until the transaction that created it has been committed, a watch will not report changes made by <em>other</em> transactions. In contrast, a watch will immediately report changes made by the transaction itself. Watches cannot be created if the transaction has set <a class="reference internal" href="#fdb.Transaction.options.set_read_your_writes_disable" title="fdb.Transaction.options.set_read_your_writes_disable"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.options.set_read_your_writes_disable()</span></code></a>, and an attempt to do so will raise an <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">watches_disabled</span></a> exception.</p>
<p>If the transaction used to create a watch encounters an exception during commit, then the watch will be set with that exception. A transaction whose <a class="reference internal" href="developer-guide.html#developer-guide-unknown-results"><span class="std std-ref">commit result is unknown</span></a> will set all of its watches with the <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">commit_unknown_result</span></a> exception. If an uncommitted transaction is reset or destroyed, then any watches it created will be set with the <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">transaction_cancelled</span></a> exception.</p>
<p>By default, each database connection can have no more than 10,000 watches that have not yet reported a change. When this number is exceeded, an attempt to create a watch will raise a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">too_many_watches</span></a> exception. This limit can be changed using <a class="reference internal" href="#fdb.Database.options.set_max_watches" title="fdb.Database.options.set_max_watches"><code class="xref py py-func docutils literal notranslate"><span class="pre">Database.options.set_max_watches()</span></code></a>. Because a watch outlives the transaction that creates it, any watch that is no longer needed should be cancelled by calling <a class="reference internal" href="#fdb.Future.cancel" title="fdb.Future.cancel"><code class="xref py py-func docutils literal notranslate"><span class="pre">Future.cancel()</span></code></a> on its returned future.</p>
</dd></dl>

</section>
<section id="conflict-ranges">
<span id="api-python-conflict-ranges"></span><h3>Conflict ranges</h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Most applications will use the strictly serializable isolation that transactions provide by default and will not need to manipulate conflict ranges.</p>
</div>
<p>The following make it possible to add <a class="reference internal" href="developer-guide.html#conflict-ranges"><span class="std std-ref">conflict ranges</span></a> to a transaction.</p>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.add_read_conflict_range">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">add_read_conflict_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Adds a range of keys to the transaction’s read conflict ranges as if you had read the range. As a result, other transactions that write a key in this range could cause the transaction to fail with a conflict.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.add_read_conflict_key">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">add_read_conflict_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Adds a key to the transaction’s read conflict ranges as if you had read the key. As a result, other transactions that concurrently write this key could cause the transaction to fail with a conflict.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.add_write_conflict_range">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">add_write_conflict_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Adds a range of keys to the transaction’s write conflict ranges as if you had cleared the range. As a result, other transactions that concurrently read a key in this range could fail with a conflict.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.add_write_conflict_key">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">add_write_conflict_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Adds a key to the transaction’s write conflict ranges as if you had written the key. As a result, other transactions that concurrently read this key could fail with a conflict.</p>
</dd></dl>

</section>
<section id="versions">
<h3>Versions</h3>
<p>Most applications should use the read version that FoundationDB determines automatically during the transaction’s first read, and ignore all of these methods.</p>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.set_read_version">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">set_read_version</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">version</span></span></em><span class="sig-paren">)</span></dt>
<dd><p><em>Infrequently used</em>. Sets the database version that the transaction will read from the database.  The database cannot guarantee causal consistency if this method is used (the transaction’s reads will be causally consistent only if the provided read version has that property).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.get_read_version">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">get_read_version</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p><em>Infrequently used</em>. Returns a <code class="xref py py-class docutils literal notranslate"><span class="pre">FutureVersion</span></code> representing the transaction’s (<a class="reference internal" href="#api-python-future"><span class="std std-ref">future</span></a>) read version. You must call the <a class="reference internal" href="#fdb.Future.wait" title="fdb.Future.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.wait()</span></code></a> method on the returned object to retrieve the version as an integer.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.get_committed_version">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">get_committed_version</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p><em>Infrequently used</em>. Gets the version number at which a successful commit modified the database. This must be called only after the successful (non-error) completion of a call to <a class="reference internal" href="#fdb.Transaction.commit" title="fdb.Transaction.commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.commit()</span></code></a> on this Transaction, or the behavior is undefined. Read-only transactions do not modify the database when committed and will have a committed version of -1. Keep in mind that a transaction which reads keys and then sets them to their current values may be optimized to a read-only transaction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.get_versionstamp">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">get_versionstamp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p><em>Infrequently used</em>. Returns a future which will contain the versionstamp which was used by any versionstamp operations in this transaction. This function must be called before a call to <a class="reference internal" href="#fdb.Transaction.commit" title="fdb.Transaction.commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.commit()</span></code></a> on this Transaction. The future will be ready only after the successful completion of a call to <a class="reference internal" href="#fdb.Transaction.commit" title="fdb.Transaction.commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.commit()</span></code></a> on this Transaction. Read-only transactions do not modify the database when committed and will result in the future completing with an error. Keep in mind that a transaction which reads keys and then sets them to their current values may be optimized to a read-only transaction.</p>
</dd></dl>

</section>
<section id="transaction-misc-functions">
<h3>Transaction misc functions</h3>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.get_estimated_range_size_bytes">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">get_estimated_range_size_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">begin_key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Gets the estimated byte size of the given key range. Returns a <a class="reference internal" href="#fdb.FutureInt64" title="fdb.FutureInt64"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureInt64</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The estimated size is calculated based on the sampling done by FDB server. The sampling algorithm works roughly in this way: the larger the key-value pair is, the more likely it would be sampled and the more accurate its sampled size would be. And due to that reason it is recommended to use this API to query against large ranges for accuracy considerations. For a rough reference, if the returned size is larger than 3MB, one can consider the size to be accurate.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.get_range_split_points">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">get_range_split_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">begin_key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunk_size</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Gets a list of keys that can split the given range into (roughly) equally sized chunks based on <code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>. Returns a <code class="xref py py-class docutils literal notranslate"><span class="pre">FutureKeyArray</span></code>.
.. note:: The returned split points contain the start key and end key of the given range</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.get_approximate_size">
<span class="sig-prename descclassname"><span class="pre">Transaction.</span></span><span class="sig-name descname"><span class="pre">get_approximate_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Gets the the approximate transaction size so far, which is the summation of the estimated size of mutations, read conflict ranges, and write conflict ranges. Returns a <a class="reference internal" href="#fdb.FutureInt64" title="fdb.FutureInt64"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureInt64</span></code></a>.</p>
</dd></dl>

</section>
<section id="transaction-options">
<span id="api-python-transaction-options"></span><h3>Transaction options</h3>
<p>Transaction options alter the behavior of FoundationDB transactions. FoundationDB defaults to extremely safe transaction behavior, and we have worked hard to make the performance excellent with the default setting, so you should not often need to use transaction options.</p>
<span class="target" id="api-python-snapshot-ryw"></span><dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_snapshot_ryw_disable">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_snapshot_ryw_disable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>If this option is set more times in this transaction than the enable option, snapshot reads will <em>not</em> see the effects of prior writes in the same transaction. Note that prior to API version 300, this was the default behavior. This option can be disabled one or more times at the database level by calling <a class="reference internal" href="#fdb.Database.options.set_snapshot_ryw_disable" title="fdb.Database.options.set_snapshot_ryw_disable"><code class="xref py py-func docutils literal notranslate"><span class="pre">Database.options.set_snapshot_ryw_disable()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_snapshot_ryw_enable">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_snapshot_ryw_enable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>If this option is set an equal or more times in this transaction than the disable option, snapshot reads <em>will</em> see the effects of prior writes in the same transaction. This option can be enabled one or more times at the database-level by calling <a class="reference internal" href="#fdb.Database.options.set_snapshot_ryw_enable" title="fdb.Database.options.set_snapshot_ryw_enable"><code class="xref py py-func docutils literal notranslate"><span class="pre">Database.options.set_snapshot_ryw_enable()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_priority_batch">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_priority_batch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>This transaction should be treated as low priority (other transactions will be processed first). Batch priority transactions will also be throttled at load levels smaller than for other types of transactions and may be fully cut off in the event of machine failures. Useful for doing potentially saturating batch work without interfering with the latency of other operations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_priority_system_immediate">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_priority_system_immediate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>This transaction should be treated as extremely high priority, taking priority over other transactions and bypassing controls on transaction queuing.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is intended for the use of internal database functions and low-level tools; use by applications may result in severe database performance or availability problems.</p>
</div>
</dd></dl>

<span class="target" id="api-python-option-set-causal-read-risky"></span><dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_causal_read_risky">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_causal_read_risky</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>This transaction does not require the strict causal consistency guarantee that FoundationDB provides by default.  The read version will be committed, and usually will be the latest committed, but might not be the latest committed in the event of a simultaneous fault and misbehaving clock. One can set this for all transactions by calling <a class="reference internal" href="#fdb.Database.options.set_transaction_causal_read_risky" title="fdb.Database.options.set_transaction_causal_read_risky"><code class="xref py py-func docutils literal notranslate"><span class="pre">Database.options.set_transaction_causal_read_risky()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_causal_write_risky">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_causal_write_risky</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>The application either knows that this transaction will be self-conflicting (at least one read overlaps at least one set or clear), or is willing to accept a small risk that the transaction could be committed a second time after its commit apparently succeeds.  This option provides a small performance benefit.</p>
</dd></dl>

<span class="target" id="api-python-no-write-conflict-range"></span><dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_next_write_no_write_conflict_range">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_next_write_no_write_conflict_range</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>The next write performed on this transaction will not generate a write conflict range. As a result, other transactions which read the key(s) being modified by the next write will not necessarily conflict with this transaction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Care needs to be taken when using this option on a transaction that is shared between multiple threads. When setting this option, write conflict ranges will be disabled on the next write operation, regardless of what thread it is on.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_read_your_writes_disable">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_read_your_writes_disable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>When this option is invoked, a read performed by a transaction will not see any prior mutations that occurred in that transaction, instead seeing the value which was in the database at the transaction’s read version. This option may provide a small performance benefit for the client, but also disables a number of client-side optimizations which are beneficial for transactions which tend to read and write the same keys within a single transaction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is an error to set this option after performing any reads or writes on the transaction.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_read_ahead_disable">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_read_ahead_disable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Disables read-ahead caching for range reads. Under normal operation, a transaction will read extra rows from the database into cache if range reads are used to page through a series of data one row at a time (i.e. if a range read with a one row limit is followed by another one row range read starting immediately after the result of the first).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_access_system_keys">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_access_system_keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Allows this transaction to read and modify system keys (those that start with the byte <code class="docutils literal notranslate"><span class="pre">0xFF</span></code>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Writing into system keys will likely break your database. Further, even for readers, the format of data in the system keys may change from version to version in FoundationDB.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_read_system_keys">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_read_system_keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Allows this transaction to read system keys (those that start with the byte <code class="docutils literal notranslate"><span class="pre">0xFF</span></code>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The format of data in the system keys may change from version to version in FoundationDB.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_retry_limit">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_retry_limit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a maximum number of retries after which additional calls to <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a> will throw the most recently seen error code. (By default, a transaction permits an unlimited number of retries.) Valid parameter values are [-1, INT_MAX]. If set to -1, the transaction returns to the default of unlimited retries.</p>
<p>Prior to API version 610, Like all other transaction options, the retry limit must be reset after a call to <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a>. If the API version is 610 or newer, then the retry limit is not reset. Note that at all API versions, it is safe and legal to call this option after each call to <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a>, so most code written assuming the older behavior can be upgraded without requiring any modification. This also means there is no need to introduce logic to conditionally set this option within retry loops. One can also set the default retry limit for all transactions by calling <a class="reference internal" href="#fdb.Database.options.set_transaction_retry_limit" title="fdb.Database.options.set_transaction_retry_limit"><code class="xref py py-func docutils literal notranslate"><span class="pre">Database.options.set_transaction_retry_limit()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_max_retry_delay">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_max_retry_delay</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set the maximum backoff delay incurred in the call to <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a> if the error is retryable. Prior to API version 610, like all other transaction options, the maximum retry delay must be reset after a call to <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a>. If the API version is 610 or newer, then the maximum retry delay is not reset. Note that at all API versions, it is safe and legal to call this option after each call to <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a>, so most cade written assuming the older behavior can be upgraded without requiring any modification. This also means there is no need to introduce logic to conditionally set this option within retry loops. One can set the default retry limit for all transactions by calling <a class="reference internal" href="#fdb.Database.options.set_transaction_max_retry_delay" title="fdb.Database.options.set_transaction_max_retry_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">Database.options.set_transaction_max_retry_delay()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_size_limit">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_size_limit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set the transaction size limit in bytes. The size is calculated by combining the sizes of all keys and values written or mutated, all key ranges cleared, and all read and write conflict ranges. (In other words, it includes the total size of all data included in the request to the cluster to commit the transaction.) Large transactions can cause performance problems on FoundationDB clusters, so setting this limit to a smaller value than the default can help prevent the client from accidentally degrading the cluster’s performance. This value must be at least 32 and cannot be set to higher than 10,000,000, the default transaction size limit.</p>
</dd></dl>

<span class="target" id="api-python-timeout"></span><dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_timeout">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_timeout</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a timeout duration in milliseconds after which the transaction automatically to be cancelled. The time is measured from transaction creation (or the most call to <a class="reference internal" href="#fdb.Transaction.reset" title="fdb.Transaction.reset"><code class="xref py py-func docutils literal notranslate"><span class="pre">reset</span></code></a>, if any). Valid parameter values are [0, INT_MAX]. If set to 0, all timeouts will be disabled. Once a transaction has timed out, all pending or future uses of the transaction will raise a <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">transaction_timed_out</span></a> exception. The transaction can be used again after it is <a class="reference internal" href="#fdb.Transaction.reset" title="fdb.Transaction.reset"><code class="xref py py-func docutils literal notranslate"><span class="pre">reset</span></code></a>.</p>
<p>Timeouts employ transaction cancellation, so you should note the issues raised by <a class="reference internal" href="#fdb.Transaction.cancel" title="fdb.Transaction.cancel"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.cancel()</span></code></a> when using timeouts.</p>
<p>Prior to API version 610, like all other transaction options, a timeout must be reset after a call to <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a>. Note that resetting this option resets only the timeout <em>duration</em>, not the starting point from which the time is measured. If the API version is 610 or newer, then the timeout is not reset. This allows the user to specify a timeout for specific transactions that is longer than the timeout specified by <a class="reference internal" href="#fdb.Database.options.set_transaction_timeout" title="fdb.Database.options.set_transaction_timeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">Database.options.set_transaction_timeout()</span></code></a>. Note that at all API versions, it is safe and legal to call this option after each call to <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a>, so most code written assuming the older behavior can be upgraded without requiring any modification. This also means that there is no need to introduce logic to conditionally set this option within retry loops. One can set the default timeout for all transactions by calling <a class="reference internal" href="#fdb.Database.options.set_transaction_timeout" title="fdb.Database.options.set_transaction_timeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">Database.options.set_transaction_timeout()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_transaction_logging_max_field_length">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_transaction_logging_max_field_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_limit</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the maximum escaped length of key and value fields to be logged to the trace file via the LOG_TRANSACTION option, after which the field will be truncated. A negative value disables truncation. One can set the default max field length for all transactions by calling <a class="reference internal" href="#fdb.Database.options.set_transaction_logging_max_field_length" title="fdb.Database.options.set_transaction_logging_max_field_length"><code class="xref py py-func docutils literal notranslate"><span class="pre">Database.options.set_transaction_logging_max_field_length()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_debug_transaction_identifier">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_debug_transaction_identifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id_string</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets a client provided string identifier for the transaction that will be used in scenarios like tracing or profiling. Client trace logging or transaction profiling must be separately enabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Transaction.options.set_log_transaction">
<span class="sig-prename descclassname"><span class="pre">Transaction.options.</span></span><span class="sig-name descname"><span class="pre">set_log_transaction</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Enables tracing for this transaction and logs results to the client trace logs. The DEBUG_TRANSACTION_IDENTIFIER option must be set before using this option, and client trace logging must be enabled to get log output.</p>
</dd></dl>

</section>
</section>
<section id="future-objects">
<span id="api-python-future"></span><h2>Future objects</h2>
<p>Many FoundationDB API functions return “future” objects. A brief overview of futures is included in the <a class="reference internal" href="class-scheduling.html"><span class="doc">class scheduling tutorial</span></a>. Most future objects behave just like a normal object, but block when you use them for the first time if the asynchronous function which returned the future has not yet completed its action. A future object is considered ready when either a value is available, or when an error has occurred.</p>
<p id="api-python-block">When a future object “blocks”, what actually happens is determined by the <a class="reference internal" href="#api-python-event-models"><span class="std std-ref">event model</span></a>.  A threaded program will block a thread, but a program using the gevent model will block a greenlet.</p>
<p>All future objects are a subclass of the <a class="reference internal" href="#fdb.Future" title="fdb.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a> type.</p>
<dl class="py class">
<dt class="sig sig-object py" id="fdb.Future">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">Future</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Future.wait">
<span class="sig-prename descclassname"><span class="pre">Future.</span></span><span class="sig-name descname"><span class="pre">wait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Blocks until the object is ready, and returns the object value (or raises an exception if the asynchronous function failed).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Future.is_ready">
<span class="sig-prename descclassname"><span class="pre">Future.</span></span><span class="sig-name descname"><span class="pre">is_ready</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Immediately returns true if the future object is ready, false otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Future.block_until_ready">
<span class="sig-prename descclassname"><span class="pre">Future.</span></span><span class="sig-name descname"><span class="pre">block_until_ready</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Blocks until the future object is ready.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Future.on_ready">
<span class="sig-prename descclassname"><span class="pre">Future.</span></span><span class="sig-name descname"><span class="pre">on_ready</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calls the specified callback function, passing itself as a single argument, when the future object is ready. If the future object is ready at the time <a class="reference internal" href="#fdb.Future.on_ready" title="fdb.Future.on_ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">on_ready()</span></code></a> is called, the call may occur immediately in the current thread (although this behavior is not guaranteed). Otherwise, the call may be delayed and take place on the thread with which the client was initialized. Therefore, the callback is responsible for any needed thread synchronization (and/or for posting work to your application’s event loop, thread pool, etc., as may be required by your application’s architecture).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function guarantees the callback will be executed <strong>at most once</strong>.</p>
</div>
</dd></dl>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There are a number of requirements and constraints to be aware of when using callbacks with FoundationDB. Please read <a class="reference internal" href="developer-guide.html#developer-guide-programming-with-futures"><span class="std std-ref">Programming with futures</span></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.Future.cancel">
<span class="sig-prename descclassname"><span class="pre">Future.</span></span><span class="sig-name descname"><span class="pre">cancel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Cancels a <a class="reference internal" href="#api-python-future"><span class="std std-ref">future</span></a> and its associated asynchronous operation. If called before the future is ready, attempts to access its value will raise an <a class="reference internal" href="api-error-codes.html#developer-guide-error-codes"><span class="std std-ref">operation_cancelled</span></a> exception. Cancelling a future which is already ready has no effect. Note that even if a future is not ready, its associated asynchronous operation may have successfully completed and be unable to be cancelled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Future.wait_for_any">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Future.</span></span><span class="sig-name descname"><span class="pre">wait_for_any</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">futures</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Does not return until at least one of the given future objects is ready. Returns the index in the parameter list of a ready future object.</p>
</dd></dl>

<p>Asynchronous methods return one of the following subclasses of <a class="reference internal" href="#fdb.Future" title="fdb.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>:</p>
<dl class="py class">
<dt class="sig sig-object py" id="fdb.Value">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">Value</span></span></dt>
<dd><p>Represents a future string object and responds to the same methods as string in Python. They may be passed to FoundationDB methods that expect a string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Value.present">
<span class="sig-prename descclassname"><span class="pre">Value.</span></span><span class="sig-name descname"><span class="pre">present</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">False</span></code> if the key used to request this value was not present in the database. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">tr</span><span class="p">):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="sa">b</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">present</span><span class="p">():</span>
        <span class="nb">print</span> <span class="s1">&#39;Got value: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s1">&#39;foo was not present&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fdb.Key">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">Key</span></span></dt>
<dd><p>Represents a future string object and responds to the same methods as string in Python. They may be passed to FoundationDB methods that expect a string.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fdb.FutureInt64">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">FutureInt64</span></span></dt>
<dd><p>Represents a future integer. You must call the <a class="reference internal" href="#fdb.Future.wait" title="fdb.Future.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.wait()</span></code></a> method on this object to retrieve the integer.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fdb.FutureStringArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">FutureStringArray</span></span></dt>
<dd><p>Represents a future list of strings. You must call the <a class="reference internal" href="#fdb.Future.wait" title="fdb.Future.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.wait()</span></code></a> method on this object to retrieve the list of strings.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fdb.FutureVoid">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">FutureVoid</span></span></dt>
<dd><p>Represents a future returned from asynchronous methods that logically have no return value.</p>
<p>For a <a class="reference internal" href="#fdb.FutureVoid" title="fdb.FutureVoid"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureVoid</span></code></a> object returned by <a class="reference internal" href="#fdb.Transaction.commit" title="fdb.Transaction.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.commit()</span></code></a> or <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a>, you must call the <a class="reference internal" href="#fdb.Future.wait" title="fdb.Future.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.wait()</span></code></a> method, which will either raise an exception if an error occurred during the asynchronous call, or do nothing and return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

</section>
<section id="streaming-modes">
<span id="streaming-mode-python"></span><h2>Streaming modes</h2>
<dl class="py data">
<dt class="sig sig-object py" id="fdb.StreamingMode">
<span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">StreamingMode</span></span></dt>
<dd></dd></dl>

<p>When using <a class="reference internal" href="#fdb.Transaction.get_range" title="fdb.Transaction.get_range"><code class="xref py py-func docutils literal notranslate"><span class="pre">Transaction.get_range()</span></code></a> and similar interfaces, API clients can request large ranges of the database to iterate over.  Making such a request doesn’t necessarily mean that the client will consume all of the data in the range - sometimes the client doesn’t know how far it intends to iterate in advance.  FoundationDB tries to balance latency and bandwidth by requesting data for iteration in batches.</p>
<p>Streaming modes permit the API client to customize this performance tradeoff by providing extra information about how the iterator will be used.</p>
<p>The following streaming modes are available:</p>
<dl class="py data">
<dt class="sig sig-object py" id="fdb.StreamingMode.iterator">
<span class="sig-prename descclassname"><span class="pre">StreamingMode.</span></span><span class="sig-name descname"><span class="pre">iterator</span></span></dt>
<dd><p><em>The default.</em>  The client doesn’t know how much of the range it is likely to used and wants different performance concerns to be balanced.</p>
<p>Only a small portion of data is transferred to the client initially (in order to minimize costs if the client doesn’t read the entire range), and as the caller iterates over more items in the range larger batches will be transferred in order to maximize throughput.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="fdb.StreamingMode.want_all">
<span class="sig-prename descclassname"><span class="pre">StreamingMode.</span></span><span class="sig-name descname"><span class="pre">want_all</span></span></dt>
<dd><p>The client intends to consume the entire range and would like it all transferred as early as possible.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="fdb.StreamingMode.small">
<span class="sig-prename descclassname"><span class="pre">StreamingMode.</span></span><span class="sig-name descname"><span class="pre">small</span></span></dt>
<dd><p><em>Infrequently used</em>. Transfer data in batches small enough to not be much more expensive than reading individual rows, to minimize cost if iteration stops early.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="fdb.StreamingMode.medium">
<span class="sig-prename descclassname"><span class="pre">StreamingMode.</span></span><span class="sig-name descname"><span class="pre">medium</span></span></dt>
<dd><p><em>Infrequently used</em>. Transfer data in batches sized in between small and large.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="fdb.StreamingMode.large">
<span class="sig-prename descclassname"><span class="pre">StreamingMode.</span></span><span class="sig-name descname"><span class="pre">large</span></span></dt>
<dd><p><em>Infrequently used</em>. Transfer data in batches large enough to be, in a high-concurrency environment, nearly as efficient as possible.  If the client stops iteration early, some disk and network bandwidth may be wasted.  The batch size may still be too small to allow a single client to get high throughput from the database, so if that is what you need consider <a class="reference internal" href="#fdb.StreamingMode.serial" title="fdb.StreamingMode.serial"><code class="xref py py-data docutils literal notranslate"><span class="pre">StreamingMode.serial</span></code></a>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="fdb.StreamingMode.serial">
<span class="sig-prename descclassname"><span class="pre">StreamingMode.</span></span><span class="sig-name descname"><span class="pre">serial</span></span></dt>
<dd><p>Transfer data in batches large enough that an individual client can get reasonable read bandwidth from the database.  If the client stops iteration early, considerable disk and network bandwidth may be wasted.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="fdb.StreamingMode.exact">
<span class="sig-prename descclassname"><span class="pre">StreamingMode.</span></span><span class="sig-name descname"><span class="pre">exact</span></span></dt>
<dd><p><em>Infrequently used</em>. The client has passed a specific row limit and wants that many rows delivered in a single batch.  This is not particularly useful in Python because iterator functionality makes batches of data transparent, so use <a class="reference internal" href="#fdb.StreamingMode.want_all" title="fdb.StreamingMode.want_all"><code class="xref py py-data docutils literal notranslate"><span class="pre">StreamingMode.want_all</span></code></a> instead.</p>
</dd></dl>

</section>
<section id="event-models">
<span id="api-python-event-models"></span><h2>Event models</h2>
<p>By default, the FoundationDB Python API assumes that the calling program uses threads (as provided by the <code class="docutils literal notranslate"><span class="pre">threading</span></code> module) for concurrency.  This means that blocking operations will block the current Python thread.  This behavior can be changed by specifying the optional <code class="docutils literal notranslate"><span class="pre">event_model</span></code> parameter to the <a class="reference internal" href="#fdb.open" title="fdb.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> function.</p>
<p>The following event models are available:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">event_model=None</span></code></dt><dd><p>The default.  Blocking operations will block the current Python thread.  This is also fine for programs without any form of concurrency.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event_model=&quot;gevent&quot;</span></code></dt><dd><p>The calling program uses the <a class="reference external" href="http://www.gevent.org/">gevent</a> module for single-threaded concurrency. Blocking operations will block the current greenlet.</p>
<p>The FoundationDB Python API has been tested with gevent versions 0.13.8 and 1.0rc2 and should work with all gevent 0.13 and 1.0 releases.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">gevent</span></code> event model on Windows requires gevent 1.0 or newer.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event_model=&quot;debug&quot;</span></code></dt><dd><p>The calling program is threaded, but needs to be interruptible (by Ctrl-C).  Blocking operations will poll, effectively blocking the current thread but responding to keyboard interrupts.  This model is inefficient, but can be very useful for debugging.</p>
</dd>
</dl>
</section>
<section id="errors">
<span id="api-python-release-notes"></span><h2>Errors</h2>
<p>Errors in the FoundationDB API are raised as exceptions of type <a class="reference internal" href="#fdb.FDBError" title="fdb.FDBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">FDBError</span></code></a>. These errors may be displayed for diagnostic purposes, but generally should be passed to <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a>. When using <a class="reference internal" href="#fdb.transactional" title="fdb.transactional"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;fdb.transactional</span></code></a>, appropriate errors will be retried automatically.</p>
<dl class="py class">
<dt class="sig sig-object py" id="fdb.FDBError">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">FDBError</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fdb.FDBError.code">
<span class="sig-prename descclassname"><span class="pre">FDBError.</span></span><span class="sig-name descname"><span class="pre">code</span></span></dt>
<dd><p>An integer associated with the error type.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fdb.FDBError.description">
<span class="sig-prename descclassname"><span class="pre">FDBError.</span></span><span class="sig-name descname"><span class="pre">description</span></span></dt>
<dd><p>A somewhat human-readable description of the error.</p>
</dd></dl>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You should use only <a class="reference internal" href="#fdb.FDBError.code" title="fdb.FDBError.code"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FDBError.code</span></code></a> for programmatic comparisons, as the description of the error may change at any time. Whenever possible, use the <a class="reference internal" href="#fdb.Transaction.on_error" title="fdb.Transaction.on_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.on_error()</span></code></a> method to handle <a class="reference internal" href="#fdb.FDBError" title="fdb.FDBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">FDBError</span></code></a> exceptions.</p>
</div>
</section>
<section id="module-fdb.tuple">
<span id="tuple-layer"></span><span id="api-python-tuple-layer"></span><h2>Tuple layer</h2>
<p>The FoundationDB API comes with a built-in layer for encoding tuples into keys usable by FoundationDB. The encoded key maintains the same sort order as the original tuple: sorted first by the first element, then by the second element, etc. This makes the tuple layer ideal for building a variety of higher-level data models.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For general guidance on tuple usage, see the discussion in the document on <a class="reference internal" href="data-modeling.html#data-modeling-tuples"><span class="std std-ref">Data Modeling</span></a>.</p>
</div>
<p>The tuple layer in the FoundationDB Python API supports tuples that contain elements of the following data types:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Legal Values</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
<td><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> such that <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">==</span> <span class="pre">None</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Byte string</p></td>
<td><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> such that <code class="docutils literal notranslate"><span class="pre">isinstance(value,</span> <span class="pre">bytes)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Unicode string</p></td>
<td><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> such that <code class="docutils literal notranslate"><span class="pre">isinstance(value,</span> <span class="pre">str)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Integer</p></td>
<td><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> such that <code class="docutils literal notranslate"><span class="pre">isinstance(value,</span> <span class="pre">int)</span></code> and
<code class="docutils literal notranslate"><span class="pre">-2**2040+1</span> <span class="pre">&lt;=</span> <span class="pre">value</span> <span class="pre">&lt;=</span> <span class="pre">2**2040-1</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>Floating point number
(single-precision)</p></td>
<td><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> such that <code class="docutils literal notranslate"><span class="pre">isinstance(value,</span> <span class="pre">fdb.tuple.SingleFloat)</span></code> or
<code class="docutils literal notranslate"><span class="pre">isinstance(value,</span> <span class="pre">ctypes.c_float)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Floating point number
(double-precision)</p></td>
<td><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> such that <code class="docutils literal notranslate"><span class="pre">isinstance(value,</span> <span class="pre">(ctypes.c_double,</span> <span class="pre">float))</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Boolean</p></td>
<td><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> such that <code class="docutils literal notranslate"><span class="pre">isinstance(value,</span> <span class="pre">Boolean)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>UUID</p></td>
<td><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> such that <code class="docutils literal notranslate"><span class="pre">isinstance(value,</span> <span class="pre">uuid.UUID)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Versionstamp</p></td>
<td><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> such that <code class="docutils literal notranslate"><span class="pre">isinstance(value,</span> <span class="pre">fdb.tuple.Versionstamp)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Tuple or List</p></td>
<td><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> such that <code class="docutils literal notranslate"><span class="pre">isinstance(value,</span> <span class="pre">(tuple,</span> <span class="pre">list))</span></code> and each element
within <code class="docutils literal notranslate"><span class="pre">value</span></code> is one of the supported types with a legal value.</p></td>
</tr>
</tbody>
</table>
<p>If <code class="docutils literal notranslate"><span class="pre">T</span></code> is a Python tuple meeting these criteria, then:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">T</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
<p>That is, any tuple meeting these criteria will have the same semantic value if serialized and deserialized. For
the most part, this also implies that <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">==</span> <span class="pre">fdb.tuple.unpack(fdb.tuple.pack(T))</span></code> with the following caveats:</p>
<ul class="simple">
<li><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> of type <code class="docutils literal notranslate"><span class="pre">ctypes.c_double</span></code> is converted to the Python <code class="docutils literal notranslate"><span class="pre">float</span></code> type, but
<code class="docutils literal notranslate"><span class="pre">value.value</span> <span class="pre">==</span> <span class="pre">fdb.tuple.unpack(fdb.tuple.pack((value,)))[0]</span></code> will be true (as long as <code class="docutils literal notranslate"><span class="pre">value</span></code> is not NaN).</p></li>
<li><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> of type <code class="docutils literal notranslate"><span class="pre">ctypes.c_float</span></code> is converted into a <code class="docutils literal notranslate"><span class="pre">fdb.tuple.SingleFloat</span></code> instance, but
<code class="docutils literal notranslate"><span class="pre">value.value</span> <span class="pre">==</span> <span class="pre">fdb.tuple.unpack(fdb.tuple.pack((value,)))[0].value</span></code> will be true (as long as <code class="docutils literal notranslate"><span class="pre">value.value</span></code> is not NaN).</p></li>
<li><p>Any <code class="docutils literal notranslate"><span class="pre">value</span></code> of type <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">tuple</span></code> is converted to a <code class="docutils literal notranslate"><span class="pre">tuple</span></code> type where the elements of the serialized and deserialized <code class="docutils literal notranslate"><span class="pre">value</span></code>
will be equal (subject to these caveats) to the elements of the original <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p></li>
</ul>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">fdb.tuple</span></code></dt><dd><p>Imports the FoundationDB tuple layer.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.pack">
<span class="sig-prename descclassname"><span class="pre">fdb.tuple.</span></span><span class="sig-name descname"><span class="pre">pack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a key (byte string) encoding the specified tuple. If <code class="docutils literal notranslate"><span class="pre">prefix</span></code> is set, it will prefix the serialized
bytes with the prefix string. This throws an error if any of the tuple’s items are incomplete <a class="reference internal" href="#fdb.tuple.Versionstamp" title="fdb.tuple.Versionstamp"><code class="xref py py-class docutils literal notranslate"><span class="pre">Versionstamp</span></code></a>
instances.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.pack_with_versionstamp">
<span class="sig-prename descclassname"><span class="pre">fdb.tuple.</span></span><span class="sig-name descname"><span class="pre">pack_with_versionstamp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a key (byte string) encoding the specified tuple. This method will throw an error unless
exactly one of the items of the tuple is an incomplete <a class="reference internal" href="#fdb.tuple.Versionstamp" title="fdb.tuple.Versionstamp"><code class="xref py py-class docutils literal notranslate"><span class="pre">Versionstamp</span></code></a> instance. (It will
recurse down nested tuples if there are any to find one.) If so, it will produce a byte string
that can be fed into <a class="reference internal" href="#fdb.Transaction.set_versionstamped_key" title="fdb.Transaction.set_versionstamped_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fdb.Transaction.set_versionstamped_key()</span></code></a> and correctly fill in the
versionstamp information at commit time so that when the key is re-read and deserialized, the
only difference is that the <a class="reference internal" href="#fdb.tuple.Versionstamp" title="fdb.tuple.Versionstamp"><code class="xref py py-class docutils literal notranslate"><span class="pre">Versionstamp</span></code></a> instance is complete and has the transaction version
filled in. This throws an error if there are no incomplete <a class="reference internal" href="#fdb.tuple.Versionstamp" title="fdb.tuple.Versionstamp"><code class="xref py py-class docutils literal notranslate"><span class="pre">Versionstamp</span></code></a> instances in the tuple
or if there is more than one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.unpack">
<span class="sig-prename descclassname"><span class="pre">fdb.tuple.</span></span><span class="sig-name descname"><span class="pre">unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the tuple encoded by the given key.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.has_incomplete_versionstamp">
<span class="sig-prename descclassname"><span class="pre">fdb.tuple.</span></span><span class="sig-name descname"><span class="pre">has_incomplete_versionstamp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if there is at least one element contained within the tuple that is a
<a class="reference internal" href="#fdb.tuple.Versionstamp" title="fdb.tuple.Versionstamp"><code class="xref py py-class docutils literal notranslate"><span class="pre">Versionstamp</span></code></a> instance that is incomplete. If there are multiple incomplete
<a class="reference internal" href="#fdb.tuple.Versionstamp" title="fdb.tuple.Versionstamp"><code class="xref py py-class docutils literal notranslate"><span class="pre">Versionstamp</span></code></a> instances, this method will return <code class="docutils literal notranslate"><span class="pre">True</span></code>, but trying to pack it into a
byte string will result in an error.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.range">
<span class="sig-prename descclassname"><span class="pre">fdb.tuple.</span></span><span class="sig-name descname"><span class="pre">range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a Python slice object representing all keys that encode tuples strictly starting with <code class="docutils literal notranslate"><span class="pre">tuple</span></code> (that is, all tuples of greater length than tuple of which tuple is a prefix).</p>
<p>Can be used to directly index a Transaction object to retrieve a range.  For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tr</span><span class="p">[</span> <span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">range</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="p">]</span>
</pre></div>
</div>
<p>returns all key-value pairs in the database whose keys would unpack to tuples like (‘A’, 2, x), (‘A’, 2, x, y), etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.compare">
<span class="sig-prename descclassname"><span class="pre">fdb.tuple.</span></span><span class="sig-name descname"><span class="pre">compare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tuple1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tuple2</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compares two tuples in a way that respects the natural ordering of the elements within the tuples. It will
return -1 if <code class="docutils literal notranslate"><span class="pre">tuple1</span></code> would sort before <code class="docutils literal notranslate"><span class="pre">tuple2</span></code> when performing an element-wise comparison of the two
tuples, it will return 1 if <code class="docutils literal notranslate"><span class="pre">tuple1</span></code> would sort after <code class="docutils literal notranslate"><span class="pre">tuple2</span></code>, and it will return 0 if the two
tuples are equivalent. If the function must compare two elements of different types while doing the comparison,
it will sort the elements based on their internal type codes, so comparisons are consistent if not necessarily
semantically meaningful. Strings are sorted on their byte representation when encoded into UTF-8 (which may
differ from the default sort when non-ASCII characters are included within the string), and UUIDs are sorted
based on their big-endian byte representation. Single-precision floating point numbers are sorted before all
double-precision floating point numbers, and for floating point numbers, -NaN is sorted before -Infinity which
is sorted before finite numbers which are sorted before Infinity which is sorted before NaN. Different representations
of NaN are not treated as equal.</p>
<p>Additionally, the tuple serialization contract is such that after they are serialized, the byte-string representations
of <code class="docutils literal notranslate"><span class="pre">tuple1</span></code> and <code class="docutils literal notranslate"><span class="pre">tuple2</span></code> will sort in a manner that is consistent with this function. In particular, this function
obeys the following contract:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">tuple1</span><span class="p">,</span> <span class="n">tuple2</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">tuple1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">tuple2</span><span class="p">)</span> <span class="k">else</span> \
                                      <span class="mi">0</span> <span class="k">if</span> <span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">tuple2</span><span class="p">)</span> <span class="o">==</span> <span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">tuple2</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
</pre></div>
</div>
<p>As byte order is the comparator used within the database, this comparator can be used to determine the order
of keys within the database.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fdb.tuple.SingleFloat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.tuple.</span></span><span class="sig-name descname"><span class="pre">SingleFloat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Wrapper around a single-precision floating point value. When constructed, the <code class="docutils literal notranslate"><span class="pre">value</span></code> parameter should either be
an integral value, a <code class="docutils literal notranslate"><span class="pre">float</span></code>, or a <code class="docutils literal notranslate"><span class="pre">ctypes.c_float</span></code>. It will then properly store the value in its
<a class="reference internal" href="#fdb.tuple.SingleFloat.value" title="fdb.tuple.SingleFloat.value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SingleFloat.value</span></code></a> field (which should not be mutated). If the float does not fit within a IEEE 754 floating point
integer, there may be a loss of precision.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fdb.tuple.SingleFloat.value">
<span class="sig-prename descclassname"><span class="pre">SingleFloat.</span></span><span class="sig-name descname"><span class="pre">value</span></span></dt>
<dd><p>The underlying value of the <code class="docutils literal notranslate"><span class="pre">SingleFloat</span></code> object. This will have type <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.SingleFloat.__eq__">
<span class="sig-prename descclassname"><span class="pre">SingleFloat.</span></span><span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.SingleFloat.__ne__">
<span class="sig-prename descclassname"><span class="pre">SingleFloat.</span></span><span class="sig-name descname"><span class="pre">__ne__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.SingleFloat.__lt__">
<span class="sig-prename descclassname"><span class="pre">SingleFloat.</span></span><span class="sig-name descname"><span class="pre">__lt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.SingleFloat.__le__">
<span class="sig-prename descclassname"><span class="pre">SingleFloat.</span></span><span class="sig-name descname"><span class="pre">__le__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.SingleFloat.__gt__">
<span class="sig-prename descclassname"><span class="pre">SingleFloat.</span></span><span class="sig-name descname"><span class="pre">__gt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.SingleFloat.__ge__">
<span class="sig-prename descclassname"><span class="pre">SingleFloat.</span></span><span class="sig-name descname"><span class="pre">__ge__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Comparison functions for <code class="docutils literal notranslate"><span class="pre">SingleFloat</span></code> objects. This will sort according to the byte representation
of the object rather than using standard float comparison. In particular, this means that <code class="docutils literal notranslate"><span class="pre">-0.0</span> <span class="pre">!=</span> <span class="pre">0.0</span></code>
and that the <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values will sort in a way that is consistent with the <a class="reference internal" href="#fdb.tuple.compare" title="fdb.tuple.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> method between
tuples rather than using standard floating-point comparison.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.tuple.</span></span><span class="sig-name descname"><span class="pre">Versionstamp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr_version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Used to represent values written by versionstamp operations within the tuple layer. This
wraps a single byte array of length 12 that can be used to represent some global order
of items within the database. These versions are composed of two separate components:
(1) the 10-byte <code class="docutils literal notranslate"><span class="pre">tr_version</span></code> and (2) the two-byte <code class="docutils literal notranslate"><span class="pre">user_version</span></code>. The <code class="docutils literal notranslate"><span class="pre">tr_version</span></code>
is set by the database, and it is used to impose an order between different transactions.
This order is guaranteed to be monotonically increasing over time for a given database.
(In particular, it imposes an order that is consistent with a serialization order of
the database’s transactions.) If the client elects to leave the <code class="docutils literal notranslate"><span class="pre">tr_version</span></code> as its
default value of <code class="docutils literal notranslate"><span class="pre">None</span></code>, then the <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> is considered “incomplete”. This
will cause the first 10 bytes of the serialized <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> to be filled in with
dummy bytes when serialized. When used with <a class="reference internal" href="#fdb.Transaction.set_versionstamped_key" title="fdb.Transaction.set_versionstamped_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fdb.Transaction.set_versionstamped_key()</span></code></a>,
an incomplete version can be used to ensure that a key gets written with the
current transaction’s version which can be useful for maintaining append-only data
structures within the database. If the <code class="docutils literal notranslate"><span class="pre">tr_version</span></code> is set to something that is
not <code class="docutils literal notranslate"><span class="pre">None</span></code>, it should be set to a byte array of length 10. In this case, the
<code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> is considered “complete”. This is the usual case when one
reads a serialized <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> from the database.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">user_version</span></code> should be specified as an integer, but it must fit within a two-byte
unsigned integer. It is set by the client, and it is used to impose an order between items
serialized within a single transaction. If left unset, then final two bytes of the serialized
<code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> are filled in with a default (constant) value.</p>
<p>Sample usage of this class might be something like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span><span class="w"> </span><span class="nf">write_versionstamp</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
    <span class="n">tr</span><span class="o">.</span><span class="n">set_versionstamped_key</span><span class="p">(</span><span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">pack_with_versionstamp</span><span class="p">((</span><span class="n">prefix</span><span class="p">,</span> <span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">Versionstamp</span><span class="p">())),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tr</span><span class="o">.</span><span class="n">get_versionstamp</span><span class="p">()</span>

<span class="nd">@fdb</span><span class="o">.</span><span class="n">transactional</span>
<span class="k">def</span><span class="w"> </span><span class="nf">read_versionstamp</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
    <span class="n">subspace</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">Subspace</span><span class="p">((</span><span class="n">prefix</span><span class="p">,))</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">get_range</span><span class="p">(</span><span class="n">subspace</span><span class="o">.</span><span class="n">range</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">subspace</span><span class="o">.</span><span class="n">range</span><span class="p">()</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">subspace</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="kc">None</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
<span class="k">del</span> <span class="n">db</span><span class="p">[</span><span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">range</span><span class="p">((</span><span class="s1">&#39;prefix&#39;</span><span class="p">,))]</span>
<span class="n">tr_version</span> <span class="o">=</span> <span class="n">write_versionstamp</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="s1">&#39;prefix&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">read_versionstamp</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="s1">&#39;prefix&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">v</span> <span class="o">==</span> <span class="n">fdb</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="n">Versionstamp</span><span class="p">(</span><span class="n">tr_version</span><span class="o">=</span><span class="n">tr_version</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we serialize an incomplete <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> and then write it using the <code class="docutils literal notranslate"><span class="pre">set_versionstamped_key</span></code>
mutation so that it picks up the transaction’s version information. Then when we read it
back, we get a complete <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> with the committed transaction’s version.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.tr_version">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">tr_version</span></span></dt>
<dd><p>The inter-transaction component of the <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> class. It should be either <code class="docutils literal notranslate"><span class="pre">None</span></code> (to
indicate an incomplete <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> that will set the version later) or to some 10 byte value
indicating the commit version and batch version of some transaction.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.user_version">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">user_version</span></span></dt>
<dd><p>The intra-transaction component of the <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> class. It should be some number that can
fit within two bytes (i.e., between 0 and 65,535 inclusive). It can be used to impose an order
between items that are committed together in the same transaction. If left unset, then
the versionstamp is assigned a (constant) default user version value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.from_bytes">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">from_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Static initializer for <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> instances that takes a serialized <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> and
creates an instance of the class. The <code class="docutils literal notranslate"><span class="pre">bytes</span></code> parameter should be a byte string of length 12.
This method will serialize the version as a “complete” <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> unless the dummy bytes
are equal to the default transaction version assigned to incomplete <code class="docutils literal notranslate"><span class="pre">Versionstamps</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.is_complete">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">is_complete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns whether this version has been given a (non-<code class="docutils literal notranslate"><span class="pre">None</span></code>) <code class="docutils literal notranslate"><span class="pre">tr_version</span></code> or not.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.completed">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">completed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr_version</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>If this <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> is incomplete, this returns a copy of this instance except that the
<code class="docutils literal notranslate"><span class="pre">tr_version</span></code> is filled in with the passed parameter. If the <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> is already
complete, it will raise an error.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.to_bytes">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">to_bytes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Produces a serialized byte string corresponding to this versionstamp. It will have length 12 and
will combine the <code class="docutils literal notranslate"><span class="pre">tr_version</span></code> and <code class="docutils literal notranslate"><span class="pre">user_version</span></code> to produce a byte string that
lexicographically sorts appropriately with other <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> instances. If this instance is
incomplete, then the <code class="docutils literal notranslate"><span class="pre">tr_version</span></code> component gets filled in with dummy bytes that will cause it
to sort after every complete <code class="docutils literal notranslate"><span class="pre">Verionstamp</span></code>’s serialized bytes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.__eq__">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.__ne__">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">__ne__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.__lt__">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">__lt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.__le__">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">__le__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.__gt__">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">__gt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tuple.Versionstamp.__ge__">
<span class="sig-prename descclassname"><span class="pre">Versionstamp.</span></span><span class="sig-name descname"><span class="pre">__ge__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Comparison functions for <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> objects. For two complete <code class="docutils literal notranslate"><span class="pre">Versionstamps</span></code>, the
ordering is first lexicographically by <code class="docutils literal notranslate"><span class="pre">tr_version</span></code> and then by <code class="docutils literal notranslate"><span class="pre">user_version</span></code>.
Incomplete <code class="docutils literal notranslate"><span class="pre">Versionstamps</span></code> are defined to sort after all complete <code class="docutils literal notranslate"><span class="pre">Versionstamps</span></code> (the idea
being that for a given transaction, if a <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code> has been created as the result of
some prior transaction’s work, then the incomplete <code class="docutils literal notranslate"><span class="pre">Versionstamp</span></code>, when assigned a version,
will be assigned a greater version than the existing one), and for two incomplete <code class="docutils literal notranslate"><span class="pre">Versionstamps</span></code>,
the order is by <code class="docutils literal notranslate"><span class="pre">user_version</span></code> only.</p>
</dd></dl>

</section>
<section id="subspaces">
<span id="api-python-subspaces"></span><h2>Subspaces</h2>
<p>Subspaces provide a convenient way to use the <a class="reference internal" href="#api-python-tuple-layer"><span class="std std-ref">tuple layer</span></a> to define namespaces for different categories of data. The namespace is specified by a prefix tuple which is prepended to all tuples packed by the subspace. When unpacking a key with the subspace, the prefix tuple will be removed from the result.</p>
<p>As a best practice, API clients should use at least one subspace for application data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For general guidance on subspace usage, see the discussion in the <a class="reference internal" href="developer-guide.html#developer-guide-sub-keyspaces"><span class="std std-ref">Developer Guide</span></a>.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="fdb.Subspace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">Subspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefixTuple</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">tuple()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rawPrefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a subspace with the specified prefix tuple. If the raw prefix byte string is specified, then it will be prepended to all packed keys. Likewise, the raw prefix will be removed from all unpacked keys.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Subspace.key">
<span class="sig-prename descclassname"><span class="pre">Subspace.</span></span><span class="sig-name descname"><span class="pre">key</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the key encoding the prefix used for the subspace. This is equivalent to packing the empty tuple.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Subspace.pack">
<span class="sig-prename descclassname"><span class="pre">Subspace.</span></span><span class="sig-name descname"><span class="pre">pack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tuple</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">tuple()</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the key encoding the specified tuple in the subspace. For example, if you have a subspace with prefix tuple <code class="docutils literal notranslate"><span class="pre">('users')</span></code> and you use it to pack the tuple <code class="docutils literal notranslate"><span class="pre">('Smith')</span></code>, the result is the same as if you packed the tuple <code class="docutils literal notranslate"><span class="pre">('users',</span> <span class="pre">'Smith')</span></code> with the <a class="reference internal" href="#api-python-tuple-layer"><span class="std std-ref">tuple layer</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Subspace.pack_with_versionstamp">
<span class="sig-prename descclassname"><span class="pre">Subspace.</span></span><span class="sig-name descname"><span class="pre">pack_with_versionstamp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the key encoding the specified tuple in the subspace so that it may be used as the key in the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fdb.Transaction.set_versionstampe_key()</span></code> method. The passed tuple must contain exactly one incomplete
<a class="reference internal" href="#fdb.tuple.Versionstamp" title="fdb.tuple.Versionstamp"><code class="xref py py-class docutils literal notranslate"><span class="pre">fdb.tuple.Versionstamp</span></code></a> instance or the method will raise an error. The behavior here is the same
as if one used the <a class="reference internal" href="#fdb.tuple.pack_with_versionstamp" title="fdb.tuple.pack_with_versionstamp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fdb.tuple.pack_with_versionstamp()</span></code></a> method to appropriately pack together
this subspace and the passed tuple.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Subspace.unpack">
<span class="sig-prename descclassname"><span class="pre">Subspace.</span></span><span class="sig-name descname"><span class="pre">unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the tuple encoded by the given key, with the subspace’s prefix tuple and raw prefix removed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Subspace.range">
<span class="sig-prename descclassname"><span class="pre">Subspace.</span></span><span class="sig-name descname"><span class="pre">range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tuple</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">tuple()</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a range representing all keys in the subspace that encode tuples strictly starting with the specified tuple.</p>
<p>The range will be returned as a Python slice object, and may be used with any FoundationDB methods that require a range:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">subspace</span><span class="o">.</span><span class="n">range</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">rng_itr1</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
<span class="n">rng_itr2</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">get_range</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Subspace.contains">
<span class="sig-prename descclassname"><span class="pre">Subspace.</span></span><span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">key</span></code> starts with <a class="reference internal" href="#fdb.Subspace.key" title="fdb.Subspace.key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Subspace.key()</span></code></a>, indicating that the subspace logically contains <code class="docutils literal notranslate"><span class="pre">key</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Subspace.as_foundationdb_key">
<span class="sig-prename descclassname"><span class="pre">Subspace.</span></span><span class="sig-name descname"><span class="pre">as_foundationdb_key</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the key encoding the prefix used for the subspace, like <a class="reference internal" href="#fdb.Subspace.key" title="fdb.Subspace.key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Subspace.key()</span></code></a>. This method serves to support the <a class="reference internal" href="#api-python-keys"><span class="std std-ref">as_foundationdb_key()</span></a> convenience interface.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.Subspace.subspace">
<span class="sig-prename descclassname"><span class="pre">Subspace.</span></span><span class="sig-name descname"><span class="pre">subspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a new subspace which is equivalent to this subspace with its prefix tuple extended by the specified tuple.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">subspace[item]</span></code></p>
<p>Shorthand for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">subspace.subspace((item,))</span></code>. This function can be combined with the <a class="reference internal" href="#fdb.Subspace.as_foundationdb_key" title="fdb.Subspace.as_foundationdb_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Subspace.as_foundationdb_key()</span></code></a> convenience to turn this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">Subspace</span><span class="p">((</span><span class="s1">&#39;x&#39;</span><span class="p">,))</span>
<span class="n">tr</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">pack</span><span class="p">((</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</pre></div>
</div>
<p>into this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">fdb</span><span class="o">.</span><span class="n">Subspace</span><span class="p">((</span><span class="s1">&#39;x&#39;</span><span class="p">,))</span>
<span class="n">tr</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">][</span><span class="s1">&#39;bar&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="directories">
<span id="api-python-directories"></span><h2>Directories</h2>
<p>The FoundationDB API provides <a class="reference internal" href="developer-guide.html#developer-guide-directories"><span class="std std-ref">directories</span></a> as a tool for managing related <a class="reference internal" href="#api-python-subspaces"><span class="std std-ref">subspaces</span></a>. Directories are a recommended approach for administering applications. Each application should create or open at least one directory to manage its subspaces.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For general guidance on directory usage, see the discussion in the <a class="reference internal" href="developer-guide.html#developer-guide-directories"><span class="std std-ref">Developer Guide</span></a>.</p>
</div>
<p>Directories are identified by hierarchical paths analogous to the paths in a Unix-like file system. A path is represented as a tuple of strings. Each directory has an associated subspace used to store its content. The directory layer maps each path to a short prefix used for the corresponding subspace. In effect, directories provide a level of indirection for access to subspaces.</p>
<p>Except where noted, directory methods interpret the provided path(s) relative to the path of the directory object. When opening a directory, a byte string <code class="docutils literal notranslate"><span class="pre">layer</span></code> option may be specified as a metadata identifier.</p>
<dl class="py data">
<dt class="sig sig-object py" id="fdb.directory">
<span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">directory</span></span></dt>
<dd><p>The default instance of <a class="reference internal" href="#fdb.DirectoryLayer" title="fdb.DirectoryLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirectoryLayer</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fdb.DirectoryLayer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fdb.</span></span><span class="sig-name descname"><span class="pre">DirectoryLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_subspace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Subspace(rawPrefix='þ')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">content_subspace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Subspace()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_manual_prefixes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Each instance defines a new root directory. The subspaces <code class="docutils literal notranslate"><span class="pre">node_subspace</span></code> and <code class="docutils literal notranslate"><span class="pre">content_subspace</span></code> control where the directory metadata and contents, respectively, are stored. The default root directory has a <code class="docutils literal notranslate"><span class="pre">node_subspace</span></code> with raw prefix <code class="docutils literal notranslate"><span class="pre">\xFE</span></code> and a <code class="docutils literal notranslate"><span class="pre">content_subspace</span></code> with no prefix. Specifying more restrictive values for <code class="docutils literal notranslate"><span class="pre">node_subspace</span></code> and <code class="docutils literal notranslate"><span class="pre">content_subspace</span></code> will allow using the directory layer alongside other content in a database. If <code class="docutils literal notranslate"><span class="pre">allow_manual_prefixes</span></code> is false, attempts to create a directory with a manual prefix under the directory layer will raise an exception. The default root directory does not allow manual prefixes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.DirectoryLayer.create_or_open">
<span class="sig-prename descclassname"><span class="pre">DirectoryLayer.</span></span><span class="sig-name descname"><span class="pre">create_or_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Opens the directory with <code class="docutils literal notranslate"><span class="pre">path</span></code> specified as a tuple of strings. <code class="docutils literal notranslate"><span class="pre">path</span></code> can also be a string, in which case it will be automatically wrapped in a tuple. All string values in a path will be converted to unicode. If the directory does not exist, it is created (creating parent directories if necessary).</p>
<p>If the byte string <code class="docutils literal notranslate"><span class="pre">layer</span></code> is specified and the directory is new, it is recorded as the layer; if <code class="docutils literal notranslate"><span class="pre">layer</span></code> is specified and the directory already exists, it is compared against the layer specified when the directory was created, and the method will raise an exception if they differ.</p>
<p>Returns the directory and its contents as a <a class="reference internal" href="#api-python-directory-subspace"><span class="std std-ref">DirectorySubspace</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.DirectoryLayer.open">
<span class="sig-prename descclassname"><span class="pre">DirectoryLayer.</span></span><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Opens the directory with <code class="docutils literal notranslate"><span class="pre">path</span></code> specified as a tuple of strings. <code class="docutils literal notranslate"><span class="pre">path</span></code> can also be a string, in which case it will be automatically wrapped in a tuple. All string values in a path will be converted to unicode. The method will raise an exception if the directory does not exist.</p>
<p>If the byte string <code class="docutils literal notranslate"><span class="pre">layer</span></code> is specified, it is compared against the layer specified when the directory was created, and the method will raise an exception if they differ.</p>
<p>Returns the directory and its contents as a <a class="reference internal" href="#api-python-directory-subspace"><span class="std std-ref">DirectorySubspace</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.DirectoryLayer.create">
<span class="sig-prename descclassname"><span class="pre">DirectoryLayer.</span></span><span class="sig-name descname"><span class="pre">create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a directory with <code class="docutils literal notranslate"><span class="pre">path</span></code> specified as a tuple of strings. <code class="docutils literal notranslate"><span class="pre">path</span></code> can also be a string, in which case it will be automatically wrapped in a tuple. All string values in a path will be converted to unicode. Parent directories are created if necessary. The method will raise an exception if the given directory already exists.</p>
<p>If the byte string <code class="docutils literal notranslate"><span class="pre">prefix</span></code> is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically.</p>
<p>If the byte string <code class="docutils literal notranslate"><span class="pre">layer</span></code> is specified, it is recorded with the directory and will be checked by future calls to open.</p>
<p>Returns the directory and its contents as a <a class="reference internal" href="#api-python-directory-subspace"><span class="std std-ref">DirectorySubspace</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.DirectoryLayer.move">
<span class="sig-prename descclassname"><span class="pre">DirectoryLayer.</span></span><span class="sig-name descname"><span class="pre">move</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">old_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_path</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Moves the directory at <code class="docutils literal notranslate"><span class="pre">old_path</span></code> to <code class="docutils literal notranslate"><span class="pre">new_path</span></code>. There is no effect on the physical prefix of the given directory or on clients that already have the directory open. The method will raise an exception if a directory does not exist at <code class="docutils literal notranslate"><span class="pre">old_path</span></code>, a directory already exists at <code class="docutils literal notranslate"><span class="pre">new_path</span></code>, or the parent directory of <code class="docutils literal notranslate"><span class="pre">new_path</span></code> does not exist.</p>
<p>Returns the directory at its new location as a <a class="reference internal" href="#api-python-directory-subspace"><span class="std std-ref">DirectorySubspace</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.DirectoryLayer.remove">
<span class="sig-prename descclassname"><span class="pre">DirectoryLayer.</span></span><span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes the directory at <code class="docutils literal notranslate"><span class="pre">path</span></code>, its contents, and all subdirectories. The method will raise an exception if the directory does not exist.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Clients that have already opened the directory might still insert data into its contents after removal.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.DirectoryLayer.remove_if_exists">
<span class="sig-prename descclassname"><span class="pre">DirectoryLayer.</span></span><span class="sig-name descname"><span class="pre">remove_if_exists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Checks if the directory at <code class="docutils literal notranslate"><span class="pre">path</span></code> exists and, if so, removes the directory, its contents, and all subdirectories. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the directory existed and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Clients that have already opened the directory might still insert data into its contents after removal.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.DirectoryLayer.list">
<span class="sig-prename descclassname"><span class="pre">DirectoryLayer.</span></span><span class="sig-name descname"><span class="pre">list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a list of names of the immediate subdirectories of the directory at <code class="docutils literal notranslate"><span class="pre">path</span></code>. Each name is a unicode string representing the last component of a subdirectory’s path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.DirectoryLayer.exists">
<span class="sig-prename descclassname"><span class="pre">DirectoryLayer.</span></span><span class="sig-name descname"><span class="pre">exists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the directory at <code class="docutils literal notranslate"><span class="pre">path</span></code> exists and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.DirectoryLayer.get_layer">
<span class="sig-prename descclassname"><span class="pre">DirectoryLayer.</span></span><span class="sig-name descname"><span class="pre">get_layer</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the layer specified when the directory was created.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.DirectoryLayer.get_path">
<span class="sig-prename descclassname"><span class="pre">DirectoryLayer.</span></span><span class="sig-name descname"><span class="pre">get_path</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the path with which the directory was opened.</p>
</dd></dl>

<section id="directorysubspace">
<span id="api-python-directory-subspace"></span><h3>DirectorySubspace</h3>
<p>A directory subspace represents a specific directory and its contents. It stores the <code class="docutils literal notranslate"><span class="pre">path</span></code> with which it was opened and supports all <a class="reference internal" href="#fdb.DirectoryLayer" title="fdb.DirectoryLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirectoryLayer</span></code></a> methods for operating on itself and its subdirectories. It also implements all <a class="reference internal" href="#fdb.Subspace" title="fdb.Subspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subspace</span></code></a> methods for working with the contents of that directory.</p>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.DirectorySubspace.move_to">
<span class="sig-prename descclassname"><span class="pre">DirectorySubspace.</span></span><span class="sig-name descname"><span class="pre">move_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_path</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Moves this directory to <code class="docutils literal notranslate"><span class="pre">new_path</span></code>, interpreting <code class="docutils literal notranslate"><span class="pre">new_path</span></code> absolutely. There is no effect on the physical prefix of the given directory or on clients that already have the directory open. The method will raise an exception if a directory already exists at <code class="docutils literal notranslate"><span class="pre">new_path</span></code> or the parent directory of <code class="docutils literal notranslate"><span class="pre">new_path</span></code> does not exist.</p>
<p>Returns the directory at its new location as a <a class="reference internal" href="#api-python-directory-subspace"><span class="std std-ref">DirectorySubspace</span></a>.</p>
</dd></dl>

</section>
</section>
<section id="module-fdb.locality">
<span id="locality-information"></span><span id="api-python-locality"></span><h2>Locality information</h2>
<p>The FoundationDB API comes with a set of functions for discovering the storage locations of keys within your cluster. This information can be useful for advanced users who wish to take into account the location of keys in the design of applications or processes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.locality.fdb.locality.get_boundary_keys">
<span class="sig-prename descclassname"><span class="pre">fdb.locality.</span></span><span class="sig-name descname"><span class="pre">get_boundary_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">db_or_tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a generator of keys <code class="docutils literal notranslate"><span class="pre">k</span></code> such that <code class="docutils literal notranslate"><span class="pre">begin</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">end</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code> is located at the start of a contiguous range stored on a single server.</p>
<p>The first parameter to this function may be either a <a class="reference internal" href="#fdb.Database" title="fdb.Database"><code class="xref py py-class docutils literal notranslate"><span class="pre">Database</span></code></a> or a <a class="reference internal" href="#fdb.Transaction" title="fdb.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a>. If it is passed a <a class="reference internal" href="#fdb.Transaction" title="fdb.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a>, the transaction will not be committed, reset, or modified in any way, nor will its transaction options (such as retry limit) be applied within the function. However, if the database is unavailable prior to the function call, any timeout set on the transaction will still trigger.</p>
<p>Like a <a class="reference internal" href="#api-python-future"><span class="std std-ref">Future</span></a> object, the returned container issues asynchronous read operations to fetch the data in the range and may block while iterating over its values if the read has not completed.</p>
<p>This method is not transactional. It will return an answer no older than the Transaction or Database object it is passed, but the returned boundaries are an estimate and may not represent the exact boundary locations at any database version.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.locality.fdb.locality.get_addresses_for_key">
<span class="sig-prename descclassname"><span class="pre">fdb.locality.</span></span><span class="sig-name descname"><span class="pre">get_addresses_for_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns a <a class="reference internal" href="#fdb.FutureStringArray" title="fdb.FutureStringArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">fdb.FutureStringArray</span></code></a>. You must call the <a class="reference internal" href="#fdb.Future.wait" title="fdb.Future.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fdb.Future.wait()</span></code></a> method on this object to retrieve a list of public network addresses as strings, one for each of the storage servers responsible for storing <code class="docutils literal notranslate"><span class="pre">key</span></code> and its associated value.</p>
</dd></dl>

</section>
<section id="module-fdb.tenant_management">
<span id="tenant-management"></span><h2>Tenant management</h2>
<p>The FoundationDB API includes functions to manage the set of tenants in a cluster.</p>
<dl class="py method">
<dt class="sig sig-object py" id="fdb.tenant_management.fdb.tenant_management.create_tenant">
<span class="sig-prename descclassname"><span class="pre">fdb.tenant_management.</span></span><span class="sig-name descname"><span class="pre">create_tenant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">db_or_tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tenant_name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new tenant in the cluster.</p>
<p>The tenant name can be either a byte string or a tuple and cannot start with the <code class="docutils literal notranslate"><span class="pre">\xff</span></code> byte. If a tuple is provided, the tuple will be packed using the tuple layer to generate the byte string tenant name.</p>
<p>If a database is provided to this function for the <code class="docutils literal notranslate"><span class="pre">db_or_tr</span></code> parameter, then this function will first check if the tenant already exists. If it does, it will fail with a <code class="docutils literal notranslate"><span class="pre">tenant_already_exists</span></code> error. Otherwise, it will create a transaction and attempt to create the tenant in a retry loop. If the tenant is created concurrently by another transaction, this function may still return successfully.</p>
<p>If a transaction is provided to this function for the <code class="docutils literal notranslate"><span class="pre">db_or_tr</span></code> parameter, then this function will not check if the tenant already exists. It is up to the user to perform that check if required. The user must also successfully commit the transaction in order for the creation to take effect.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fdb.tenant_management.fdb.tenant_management.delete_tenant">
<span class="sig-prename descclassname"><span class="pre">fdb.tenant_management.</span></span><span class="sig-name descname"><span class="pre">delete_tenant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">db_or_tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tenant_name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Delete a tenant from the cluster.</p>
<p>The tenant name can be either a byte string or a tuple. If a tuple is provided, the tuple will be packed using the tuple layer to generate the byte string tenant name.</p>
<p>It is an error to delete a tenant that still has data. To delete a non-empty tenant, first clear all of the keys in the tenant.</p>
<p>If a database is provided to this function for the <code class="docutils literal notranslate"><span class="pre">db_or_tr</span></code> parameter, then this function will first check if the tenant already exists. If it does not, it will fail with a <code class="docutils literal notranslate"><span class="pre">tenant_not_found</span></code> error. Otherwise, it will create a transaction and attempt to delete the tenant in a retry loop. If the tenant is deleted concurrently by another transaction, this function may still return successfully.</p>
<p>If a transaction is provided to this function for the <code class="docutils literal notranslate"><span class="pre">db_or_tr</span></code> parameter, then this function will not check if the tenant already exists. It is up to the user to perform that check if required. The user must also successfully commit the transaction in order for the deletion to take effect.</p>
</dd></dl>

</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/api-python.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2013-2025 Apple, Inc and the FoundationDB project authors.<br/>
      Last updated on Sep 13, 2025.<br/>
    </p>
  </div>
</footer>
  </body>
</html>