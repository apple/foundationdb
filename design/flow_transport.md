# Flow Transport
​
This section describes the design and implementation of the flow transport wire protocol (as of release 7.1).
​
## ConnectPacket

The first bytes sent over a tcp connection in flow are the `ConnectPacket`.
This is a variable length message (though fixed length at a given protocol
version) designed with forward and backward compatibility in mind. The expected length of the `ConnectPacket` is encoded as the first 4 bytes (unsigned, little-endian). Upon receiving an incoming connection, a peer reads the `ProtocolVersion` (the next 8 bytes unsigned, little-endian. The most significant 4 bits encode flags and should be zeroed before interpreting numerically.) from the `ConnectPacket`.
​
Connect packet layout as of the 7.2 development cycle (including framing information).  Integers are little endian unless otherise noted.  See also: `FlowTransport.actor.cpp:serialize(Ar& ar)`:

    1. packet_length (u32)
    2. flags (u4)    // First 4 bits of C++ "protocolVersion"
    3. version (u60) // Remainder of "protocolVersion"
    4. canonicalRemotePort (u16)
    5. connection_id (u64)
    6. canonicalRemoteIp4 (u32, big endian)

The remaining fields must be present if the protocol version is >= 0x0FDB00B061030000LL, and absent otherwise:

    7. connectPacketFlags (u16)
    8. canonicalRemoteIp6 (u128, little endian(?))

## Protocol compatibility
​
Based on the incoming connection's `ProtocolVersion`, this connection is either
"compatible" or "incompatible". If this connection is incompatible, then we
will not actually look at any bytes sent after the `ConnectPacket`, but we will
keep the connection open so that the peer does not keep trying to open new
connections.
​
If this connection is compatible, then we know that our peer is using the same wire protocol as we are and we can proceed.
​
## Framing and checksumming protocol
​
This is implemented in FlowTransport.actor.cpp.  The read logic is simpler than the write logic.

The UID here is serialized as two raw 64 bit values.  Later, UIDs are serialized using flatbuffer, which is a more complex (and verbose) format.

As of release 7.1, the structure of subsequent messages is as follows.  All integers are little endian (often implemented as machine order, then compiled for x86 or little-endian arm variants):
​
* For TLS connections:
    1. packet_length (u32: 4 bytes unsigned; byte count includes token and message; excludes packet_length)
    2. token (u64[2]: 16 opaque bytes that identify the recipient of this message)
    3. message (u8[packet length - 16]: to be interpreted by the recipient)
* For non-TLS connections, there's additionally a checksum for message integrity:
    1. packet_length (u32: 4 bytes unsigned; exclusive of packet_length and xxhash3_64bit bytes)
    2. xxhash3_64bit (u64: checksum of token + message)
    3. token (u64[2])
    4. message (u8[packet_length - 16])
​
## Endpoint / token / UID layout

Note that the token (UID) is a 128 bit integer, but it is laid out as two 64-bit little endian values.  (So, it's "big endian" at the 64-bit granularity), and is therefore best represented in code as two 64-bit integers, called `first` and `second` in the code.

On a given machine, there is a 1:1 mapping between the bottom 32 bits of `second` and `NetworkMessageReceiver` instances (see `EndpointMap` in `FlowTransport.actor.cpp`).

In addition to checking that these 32 bits match, recipients of messages also confirm that all 64 bits of `first` match the values of their local tokens.  This probablistically prevents messages that are misrouted to the wrong `ip:port` from accidentally being applied by the wrong process.

The first 63 bits in `first` are a nonce generated by a standard random number generator.  The last bit (defined by the bitmask TOKEN_STREAM_FLAG) is used by
EndpointMap to determine if the endpoint is local (the bit is set to 1) or remote (the bit is set to 0).

TODO: What uses the top 32 bits of `second`?

`getAdjustedEndpoint` modifies the UID so that the bottom 32-bits are contiguous with those of the provided endpoint.  It is frequently used during protocol bootstrap to avoid sending multiple UIDs over the wire, so it is important that it is deterministic, and that the implementation matches for all processes in the cluster.

## Well-known endpoints
​
Endpoints are a pair of a 16 byte token that identifies the recipient and a
network address to send a message to. Endpoints are usually obtained over the
network - for example a request conventionally includes the endpoint the
reply should be sent to (like a self-addressed stamped envelope). So if you
can send a message and get endpoints in reply you can start sending messages
those endpoints. But how do you send that first message?
​
That's where the concept of a "well-known" endpoint comes in. Some endpoints
(for example the endpoints coordinators are listening on) use "well-known"
tokens that are agreed upon ahead of time. Technically the value of these
tokens could be changed as part of an incompatible protocol version bump, but
in practice this hasn't happened and shouldn't ever need to happen.
​
## Flatbuffers
​
Prior to release-6.2 the structure of messages (e.g. how many fields a
message has) was implicitly part of the protocol version, and so adding a
field to any message required a protocol version bump. Since release-6.2
messages are encoded as flatbuffers messages, and you can technically add
fields without a protocol version bump. This is a powerful and dangerous tool
that needs to be used with caution. If you add a field without a protocol version bump, then you can no longer be certain that this field will always be present (e.g. if you get a message from an old peer it might not include that field.) 
We don't have a good way to test two or more fdbserver binaries in
simulation, so we discourage adding fields or otherwise making any protocol
changes without a protocol version bump.
​
Bumping the protocol version is costly for clients though, since now they need a whole new libfdb_c.so to be able to talk to the cluster _at all_.
​
## Stable Endpoints
​
Stable endpoints are a proposal to allow protocol compatibility to be checked
per endpoint rather than per connection. The proposal is to commit to the
current (release-6.3) framing protocol for opening connections, and allow a
newer framing protocol (for example a new checksum) to be negotiated after
the connection has been established. This way even if peers are at different
protocol versions they can still read the token each message is addressed to,
and they can use that token to decide whether or not to attempt to handle the
message. By default, tokens will have the same compatibility requirements as
before where the protocol version must match exactly. But new tokens can
optionally have a different policy - e.g. handle anything from a protocol
version >= release-7.0.
​
One of the main features motivating "Stable Endpoints" is the ability to download a compatible libfdb_c from a coordinator.
​
### Changes to flow transport for Stable Endpoints
​
1. Well known endpoints must never change (this just makes it official)
2. The (initial) framing protocol must remain fixed. If we want to change the checksum, we can add a stable, well known endpoint that advertises what checksums are supported and use this to change the checksum after the connection has already been established.  (Though we changed the checksum at least once since this was written, and did not do this.)
3. Each endpoint can have a different compatibility policy: e.g. an endpoint can be marked as requiring at least `ProtocolVersion::withStableInterfaces()` like this:
​
```
	ReplyPromise<ProtocolInfoReply> reply{ PeerCompatibilityPolicy{ RequirePeer::AtLeast,
		                                                            ProtocolVersion::withStableInterfaces() } };
```
​
4. Well known endpoints no longer need to be added in a particular order. Instead you reserve the number of well known endpoints ahead of time and then you can add them in any order.

### Bootstrapping connections to the cluster

At startup, worker.actor.cpp is responsible for contacting the cluster controller, and
performs various handshakes.

registrationClient() tells the cluster controller that the worker interface exists, and re-registers when roles change.  It is invoked by workerServer(), which is invoked by fdbd().  fdbd() invokes the following at startup:

 - monitorAndWriteCCPriorityInfo() - this updates a file called fittnessFilePath when asyncPriorityInfo is updated
 - clusterController - if configured so that this is a decent fit for the current process
 - extractClusterInterface - this waits for changes to its first argument and writes them to its second argument.  The second argument is used by 'printOnFirstConnected' (only?)
 - workerServer - most interesting things happen here.
   - registrationClient sends a request that contains endpoints for a wide range of services, and information about role fittness.  It gets a response telling it what roles it should run.
 - printOnFirstConnected

These eventually invoke `getEndpoint()` to register various network listeners.  `getEndpoint()` abstracts away local
and remote endpoints (`NetSAV` and `NetNotifiedQueue`, respsectively).  When
working remotely, it invokes `FlowTransport::transport().addPeerReference()` in its constructor.

### Connection bookeeping

`addPeerReference()` is a no-op unless the enpoint has a valid, public primary address and the endpoint is a stream.  ("public" is determined by a flag passed into the NetworkAddress when it is instantiated; "valid" mostly means non-zero.  See `flow/network.h`)

`addPeerReference()` calls `getOrOpenPeer()`, and maintains a refcount of Peers.

`getOrOpenPeer()` maintains a hashmap of `NetworkAddress -> Peer`, and (on this path) starts a `ConnectionKeeper` for the `Peer`.

`ConnectionKeeper` retries connections, handles connection timeouts, performs failure monitoring, and sends the connect packet at connection startup.

### Obtaining sample flatbuffers for a given message type

There are a number of TEST_CASE blocks with names that start with `/flatbuffer/samples`.  These output a serialized flatbuffer to stdout in Rust language syntax.  Like any other unit test, they can be invoked with:

```
fdbserver -r unittests -f /flatbuffer/samples
```